<?xml version="1.0"?>
<doc>
  <assembly>
    <name>devDept.Geometry.v2022</name>
  </assembly>
  <members>
    <member name="T:devDept.Geometry.ConstraintSolver.CollinearConstraint">
      <summary>
            Collinear constraint (between lines) definition.
            </summary>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.SketchSpline">
      <summary>
            Sketch spline definition.
            </summary>
    </member>
    <member name="F:devDept.Geometry.ConstraintSolver.SketchSpline.ControlPoints">
      <summary>
            Gets or sets the curve control point array.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchSpline.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchSpline.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.Id">
      <summary>
            The Id of sketch items.
            </summary>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.IdGenerator">
      <summary>
            Contains methods to generate and assign Id when a Sketch item is created.
            </summary>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.IdPath">
      <summary>
            IdPath class definition. The IdPath contains references between a sketch curve and its child.
            </summary>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.ISketchBase">
      <summary>
            Common properties of sketch items.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.ISketchBase.ObjectId">
      <summary>
            Gets the sketch object Id.
            </summary>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.SketchBase">
      <summary>
            Base class for the sketch.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchBase.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchBase.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.SketchItem">
      <summary>
            Base class for sketch curves and constraints. 
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.SketchItem.IsDestroyed">
      <summary>
            Tells if the entity was destroyed.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchItem.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchItem.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.AngleConstraint">
      <summary>
            Angle constraint definition.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.AngleConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.AngleConstraint.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.ConcentricCirclesDistanceConstraint">
      <summary>
            Concentric circle distance constraint.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.ConcentricCirclesDistanceConstraint.FirstCircle">
      <summary>
            Gets/sets the first constrained circle.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.ConcentricCirclesDistanceConstraint.SecondCircle">
      <summary>
            Gets/sets the second constrained circle.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.ConcentricCirclesDistanceConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.CollinearPointsConstraint">
      <summary>
            Collinear points constraint definition.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.CollinearPointsConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.SketchCurve">
      <summary>
            Base class for all sketch entities.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.SketchCurve.Projected">
      <summary>
            True when the curve is the projection of an existing edge of a Brep.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.SketchCurve.Construction">
      <summary>
            Wen true, the sketch curve is marked as for construction prupose.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.SketchCurve.ParentCurve">
      <summary>
            Gets the parent entity of this sketch entity.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.SketchCurve.Constraints">
      <summary>
            Gets the constraints in which this entity is involved.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.SketchCurve.Vertices">
      <summary>
            Gets the entity vertices.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.SketchCurve.EntityType">
      <summary>
            Gets the sketch entity type.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchCurve.PointAt(System.Double)">
      <summary>
            Evaluates a point on the sketch entity.
            </summary>
      <param name="t">Evaluation parameters</param>
      <returns>The point on the entity.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchCurve.TangentAt(System.Double)">
      <summary>
            Computes the tangent vector of the entity corresponding to the input parameter. 
            </summary>
      <param name="t">The parameters.</param>
      <returns>The tangent vector.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchCurve.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchCurve.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.Constraint">
      <summary>
            Constraint class definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.Constraint.Visible">
      <summary>
            Gets or sets the constraint visibility.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Constraint.Destroy">
      <summary>
            Deletes the constraint from the sketch.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Constraint.GetEntities">
      <summary>
            Gets all constrained entities.
            </summary>
      <returns>A enumerable containing all entities.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Constraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Constraint.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.ValueConstraint">
      <summary>
            Value constraint definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.ValueConstraint.Reference">
      <summary>
            When true, the value constraint is not considered while solving the system and
            the constraint value is allowed to change. When false (default), the constraint
            behaves normally maintaining the specified value and influencing the solving
            process. Setting this field to trueÂ may be useful for measuring lengths,
            distances, angles, etc.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.ValueConstraint.GetValue">
      <summary>
            Gets the constraint value.
            </summary>
      <returns>The constraint value.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.ValueConstraint.SetValue(System.Double)">
      <summary>
            Sets the constraint value.
            </summary>
      <param name="val">The new value for the constraint</param>
    </member>
    <member name="F:devDept.Geometry.ConstraintSolver.ValueConstraint.DimPos">
      <summary>
            For internal use only. Maintains the position of the dimension.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.ValueConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.ValueConstraint.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.RadiusConstraint">
      <summary>
            Radius constraint definition.
            </summary>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.DiameterConstraint">
      <summary>
            Diameter constraint definition.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.DiameterConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.EqualConstraint">
      <summary>
            Equal constraint definition.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.EqualConstraint.IsEqualLength">
      <summary>
            Tells if the equal constraints refers to the entity length.
            </summary>
      <returns>Returns true if the equal constraint refers to the length, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.EqualConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.EqualConstraint.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.pointsDistanceOrientationType">
      <summary>
            PointsDistance constraint orientation type.
            </summary>
    </member>
    <member name="F:devDept.Geometry.ConstraintSolver.pointsDistanceOrientationType.Aligned">
      <summary>
            Aligned
            </summary>
    </member>
    <member name="F:devDept.Geometry.ConstraintSolver.pointsDistanceOrientationType.Horizontal">
      <summary>
            Horizontal
            </summary>
    </member>
    <member name="F:devDept.Geometry.ConstraintSolver.pointsDistanceOrientationType.Vertical">
      <summary>
            Vertical
            </summary>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.HVConstraint">
      <summary>
            Horizontal (Vertical) constraint definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.HVConstraint.IsHorizontal">
      <summary>
            Tells if the constraint is an horizontal constraint.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.HVConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.HVConstraint.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.LengthConstraint">
      <summary>
            Length constraint definition. Allows to constraint the length of a sketch curve.
            </summary>
      <remarks>This constraint is not implemented for SketchEllipse and SketchSpline.</remarks>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.LengthConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.LinesDistanceConstraint">
      <summary>
            Lines distance constraint.
            </summary>
      <remarks>This constraint is meaningful only for parallel lines.</remarks>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.LinesDistanceConstraint.FirstLine">
      <summary>
            Gets/sets the first constrained line.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.LinesDistanceConstraint.SecondLine">
      <summary>
            Gets/sets the second constrained line.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.LinesDistanceConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.MirrorConstraint">
      <summary>
            Mirror constraint definition
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.MirrorConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.ParallelConstraint">
      <summary>
            Parallel constraint definition.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.ParallelConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.ParallelConstraint.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.PerpendicularConstraint">
      <summary>
            Perpendicular constraint definition.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.PerpendicularConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.PerpendicularConstraint.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.PointFixedConstraint">
      <summary>
            Point fixed constraint definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.PointFixedConstraint.Point">
      <summary>
            Gets/sets the constrained point.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.PointFixedConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.PointFixedConstraint.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.PointLineDistanceConstraint">
      <summary>
            Point-line distance constraint definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.PointLineDistanceConstraint.Point">
      <summary>
            Gets/sets the constrained point.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.PointLineDistanceConstraint.Line">
      <summary>
            Gets/sets the constrained line.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.PointLineDistanceConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.PointLineDistanceConstraint.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.PointOnConstraint">
      <summary>
            Point on curve constraint definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.PointOnConstraint.Point">
      <summary>
            Gets/sets the constrained point.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.PointOnConstraint.Curve">
      <summary>
            Gets/sets the curve where the point lies.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.PointOnConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.PointAtConstraint">
      <summary>
            PointAt constraint definition.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.PointAtConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.MidPointConstraint">
      <summary>
            Mid point constraint definition.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.MidPointConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.CoincidentConstraint">
      <summary>
            Coincident constraint definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.CoincidentConstraint.FirstPoint">
      <summary>
            Gets/sets the first constrained point.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.CoincidentConstraint.SecondPoint">
      <summary>
            Gets/sets the second constrained point.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.CoincidentConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.PointsDistanceConstraint">
      <summary>
            Aligned distance constraint between two points.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.PointsDistanceConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.HorizontalPointsDistanceConstraint">
      <summary>
            Horizontal distance constraint between two points.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.HorizontalPointsDistanceConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.VerticalPointsDistanceConstraint">
      <summary>
            Vertical distance constraint between two points.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.VerticalPointsDistanceConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.TangentConstraint">
      <summary>
            Tangent constraint definition.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.TangentConstraint.GetTangentParameters(System.Double@,System.Double@)">
      <summary>
            Gets the two parameters of the tangent point on the respective curve.
            </summary>
      <param name="s0">The parameter on the first entity.</param>
      <param name="s1">The parameter on the second entity.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.TangentConstraint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.TangentConstraint.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.SketchArc">
      <summary>
            Sketch arc definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.SketchArc.Clockwise">
      <summary>
            True if the arc should be considered in clockwise direction.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.SketchArc.Radius">
      <summary>
            Gets or sets the sketch arc's radius.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchArc.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchArc.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.SketchCircle">
      <summary>
            Sketch circle definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.SketchCircle.Radius">
      <summary>
            Gets or sets the sketch circle's radius.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.SketchCircle.Center">
      <summary>
            Gets or sets the sketch circle's center.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchCircle.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchCircle.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.SketchEllipse">
      <summary>
            Sketch ellipse definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.SketchEllipse.Plane">
      <summary>
            Gets the Ellipse Plane
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.SketchEllipse.RadiusX">
      <summary>
            Gets or sets ellipse's X radius.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.SketchEllipse.RadiusY">
      <summary>
            Gets or sets ellipse's Y radius.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchEllipse.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchEllipse.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.SketchLine">
      <summary>
            Sketch line definition.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchLine.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchLine.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.SketchPoint">
      <summary>
            Sketch point definition.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchPoint.FixToOrigin">
      <summary>
            Add a PointFixed constraint to this sketch point.
            </summary>
      <returns>This point.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchPoint.FixToOrigin(devDept.Geometry.ConstraintSolver.PointFixedConstraint@)">
      <summary>
            Add a PointFixed constraint to this sketch point.
            </summary>
      <param name="pointFixedConstraint">The newly created constraint.</param>
      <returns>This point.</returns>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.SketchPoint.Position">
      <summary>
            Sets and gets the position of the point relative to Eyeshot
            world (and not to the sketch plane). This accessor should
            be used from outside the library instead of <see cref="P:devDept.Geometry.ConstraintSolver.SketchPoint.pos" />.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.SketchPoint.PlanePosition">
      <summary>
            Coordinates of the point relative to the sketch plane.
            </summary>
      <seealso cref="P:devDept.Geometry.ConstraintSolver.SketchPoint.Position" />
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchPoint.ToString">
      <summary>
            Converts this sketch point to a human readable string.
            </summary>
      <returns>A string that represents this sketch point.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchPoint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.SketchPoint.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.IEntityType">
      <summary>
            Sketch curve type
            </summary>
    </member>
    <member name="F:devDept.Geometry.ConstraintSolver.IEntityType.Point">
      <summary>
            Point.
            </summary>
    </member>
    <member name="F:devDept.Geometry.ConstraintSolver.IEntityType.Line">
      <summary>
            Line.
            </summary>
    </member>
    <member name="F:devDept.Geometry.ConstraintSolver.IEntityType.Arc">
      <summary>
            Arc.
            </summary>
    </member>
    <member name="F:devDept.Geometry.ConstraintSolver.IEntityType.Circle">
      <summary>
            Circle.
            </summary>
    </member>
    <member name="F:devDept.Geometry.ConstraintSolver.IEntityType.Spline">
      <summary>
            Spline.
            </summary>
    </member>
    <member name="F:devDept.Geometry.ConstraintSolver.IEntityType.Ellipse">
      <summary>
            Ellipse.
            </summary>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.ISketchCurve">
      <summary>
            Common properties of sketch curve entities.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.ISketchCurve.StartPoint">
      <summary>
            Gets the ISketchCurve start point.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.ISketchCurve.EndPoint">
      <summary>
            Gets the ISketchCurve end point.
            </summary>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.Sketch">
      <summary>
            Sketch class definition. Allows to create 2D Sketch with constraints between entities.
            </summary>
      <summary>
            Sketch class definition. Allows to create 2D Sketch with constraints between entities.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.Sketch.RankExcess">
      <summary>
            Number of exceeding ranks (additional rows in the system): when
            greater than zero, the sketch is over-constrained.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.Clear">
      <summary>
            Clears the sketch.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.Sketch.SketchPlane">
      <summary>
            The Sketch Plane
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.#ctor">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.DragEnd">
      <summary>
            Stops the dragging process (clears the drag equations from the sketch). This
            method should be invoked after <see cref="M:devDept.Geometry.ConstraintSolver.Sketch.DragStart(devDept.Geometry.ConstraintSolver.SketchCurve[])" />.
            </summary>
      <seealso cref="M:devDept.Geometry.ConstraintSolver.Sketch.DragStart(devDept.Geometry.ConstraintSolver.SketchCurve[])" />
      <seealso cref="M:devDept.Geometry.ConstraintSolver.Sketch.Drag(System.Double,System.Double)" />
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.DragStart(devDept.Geometry.ConstraintSolver.SketchCurve[])">
      <summary>
        <para>Starts dragging the specified entities (adds two drag equations to the
            system for each given entity). This method may be called multiple times with
            different entities. For example:</para>
        <code lang="C#"><![CDATA[sketch.DragStart(entityA, entityB);]]></code>
        <para>Is equivalent to:</para>
        <code lang="C#"><![CDATA[sketch.DragStart(entityA);
            sketch.DragStart(entityB);]]></code>
      </summary>
      <param name="entities">The entities to drag</param>
      <seealso cref="M:devDept.Geometry.ConstraintSolver.Sketch.Drag(System.Double,System.Double)" />
      <seealso cref="M:devDept.Geometry.ConstraintSolver.Sketch.DragEnd" />
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.Drag(System.Double,System.Double)">
      <summary>
            Drags the entities using the specified delta values. This method should be called
            after <see cref="M:devDept.Geometry.ConstraintSolver.Sketch.DragStart(devDept.Geometry.ConstraintSolver.SketchCurve[])" />.
            </summary>
      <param name="dx">The delta x value</param>
      <param name="dy">The delta y value</param>
      <seealso cref="M:devDept.Geometry.ConstraintSolver.Sketch.DragStart(devDept.Geometry.ConstraintSolver.SketchCurve[])" />
      <seealso cref="M:devDept.Geometry.ConstraintSolver.Sketch.DragEnd" />
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.#ctor(devDept.Geometry.Plane)">
      <summary>
            Sketch plane constructor.
            </summary>
      <param name="sketchPlane">The Sketch plane.</param>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.Sketch.Constraints">
      <summary>
            Gets the constraints list.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.RemoveConstraint(devDept.Geometry.ConstraintSolver.Constraint)">
      <summary>
            Removes the specific constraint from the sketch.
            </summary>
      <param name="constraint">The constraint</param>
      <returns>True if the constraint is successfully removed; false otherwise.</returns>
    </member>
    <member name="P:devDept.Geometry.ConstraintSolver.Sketch.Entities">
      <summary>
            Gets the entities list.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddPoint(System.Double,System.Double)">
      <summary>
      </summary>
      <param name="x">
      </param>
      <param name="y">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddPoint(devDept.Geometry.Point2D)">
      <summary>
            Adds a point to the sketch.
            </summary>
      <param name="point">The 2D point position.</param>
      <returns>The resulting sketch point.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddPoint3D(devDept.Geometry.Point3D)">
      <summary>
            Adds a 3D point to the sketch.
            </summary>
      <param name="point">The 3D point position.</param>
      <returns>The resulting sketch point.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddSpline(System.Collections.Generic.IList{devDept.Geometry.Point2D})">
      <summary>
            Adds a spline curve to the sketch. Only cubic BÃ©zier curves are supported,
            withÂ degree equal to 3 and 4 control points. For this reason, the provided
            control points list has to be of length 4.
            </summary>
      <param name="controlPoints">A list of 4 control points. The first and the last
            control points correspond to the start and the end of the curve
            respectively.</param>
      <returns>
            The newly created spline sketch curve.
            </returns>
      <exception cref="T:System.ArgumentException">Thrown when the provided list is not of the
            required size.</exception>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddRoundedRectangle(System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Adds a rounded rectangle to the sketch, with width, height and radius constraints.
            </summary>
      <param name="x">The lower-left corner X position</param>
      <param name="y">The lower-left corner Y position</param>
      <param name="width">The rectangle width</param>
      <param name="height">The rectangle height</param>
      <param name="radius">The corner radius</param>
      <returns>The array of sketch entities representing the rounded rectangle: bottom line, lower-right arc, right line, right-top arc, top line, left-top arc, left line, bottom-left arc.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddSlot(System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Adds a slot to the sketch.
            </summary>
      <param name="x">Left arc center X position</param>
      <param name="y">Left arc center Y position</param>
      <param name="length">The distance between arcs centers</param>
      <param name="radius">The arc radius</param>
      <param name="angle">The slot angle in radians from X axis. When zero, the horizontal constraint is added.</param>
      <returns>The array of sketch entities representing the slot: bottom line, right arc, top line, left arc.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddLine(devDept.Geometry.Point2D,devDept.Geometry.Point2D,System.Boolean,System.Boolean)">
      <summary>
      </summary>
      <param name="statPoint">
      </param>
      <param name="endPoint">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddLine(devDept.Geometry.ConstraintSolver.SketchPoint,devDept.Geometry.ConstraintSolver.SketchPoint,System.Boolean)">
      <summary>
            Adds a line between two sketch points. 
            </summary>
      <param name="startPoint">The line start point</param>
      <param name="endPoint">The line end point</param>
      <param name="construction">When true, the line is added as a construction sketch entity.</param>
      <returns>The resulting sketch line joined to the specified end points.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddLine(System.Double,System.Double,System.Double,System.Double,System.Boolean,System.Boolean)">
      <summary>
            Adds a line between two sketch points. 
            </summary>
      <param name="x1">The start point X coordinate</param>
      <param name="y1">The start point Y coordinate</param>
      <param name="x2">The end point X coordinate</param>
      <param name="y2">The end point Y coordinate</param>
      <param name="lenConstraint">When true, the length constraint is added.</param>
      <param name="construction">When true, the line is added as a construction sketch entity.</param>
      <returns>The resulting sketch line.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddOrigin">
      <summary>
            Adds a point on the plane origin.
            </summary>
      <returns>The resulting sketch point.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddAxisX(devDept.Geometry.ConstraintSolver.SketchPoint,System.Double)">
      <summary>
            Adds a construction line along the positive X axis.
            </summary>
      <param name="origin">The origin sketch point</param>
      <param name="length">The line length</param>
      <returns>The resulting construction line.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddAxisMinusX(devDept.Geometry.ConstraintSolver.SketchPoint,System.Double)">
      <summary>
            Adds a construction line along the negative X axis.
            </summary>
      <param name="origin">The origin sketch point</param>
      <param name="length">The line length</param>
      <returns>The resulting construction line.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddAxisY(devDept.Geometry.ConstraintSolver.SketchPoint,System.Double)">
      <summary>
            Adds a construction line along the positive Y axis.
            </summary>
      <param name="origin">The origin sketch point</param>
      <param name="length">The line length</param>
      <returns>The resulting construction line.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddAxisMinusY(devDept.Geometry.ConstraintSolver.SketchPoint,System.Double)">
      <summary>
            Adds a construction line along the negative Y axis.
            </summary>
      <param name="origin">The origin sketch point</param>
      <param name="length">The line length</param>
      <returns>The resulting construction line.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddArc(System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean,System.Boolean)">
      <summary>
            Adds an arc to the sketch.
            </summary>
      <param name="cx">The arc center point X position</param>
      <param name="cy">The arc center point Y position</param>
      <param name="radius">The arc radius</param>
      <param name="startAngle">The arc start angle in radians</param>
      <param name="endAngle">The arc end angle in radians</param>
      <param name="radConstraint">When true, the radius constraint is added.</param>
      <param name="construction">When true, the arc is added as a construction sketch entity.</param>
      <returns>The resulting sketch arc entity.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddArc(devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D,System.Boolean)">
      <summary>
            Adds an arc to the sketch.
            </summary>
      <param name="center">The arc center point</param>
      <param name="startPoint">The arc start point</param>
      <param name="endPoint">The arc end point</param>
      <returns>The resulting sketch arc</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstructionEllipse(System.Double,System.Double,System.Double,System.Double)">
      <summary>
      </summary>
      <param name="x">
      </param>
      <param name="y">
      </param>
      <param name="rx">
      </param>
      <param name="ry">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddEllipse(System.Double,System.Double,System.Double,System.Double)">
      <summary>
      </summary>
      <param name="x">
      </param>
      <param name="y">
      </param>
      <param name="rx">
      </param>
      <param name="ry">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddEllipse(devDept.Geometry.Point2D,System.Double,System.Double)">
      <summary>
            Adds an ellipse to the sketch.
            </summary>
      <param name="center">The center.</param>
      <param name="rx">The radius X.</param>
      <param name="ry">The radius Y.</param>
      <returns>The resulting SketchEllipse</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddCircle(System.Double,System.Double,System.Double,System.Boolean,System.Boolean)">
      <summary>
            Adds a circle to the sketch.
            </summary>
      <param name="x">The circle center X position</param>
      <param name="y">The circle center Y position</param>
      <param name="diameter">The circle diameter</param>
      <param name="diamConstraint">When true, the diameter constraint is added.</param>
      <param name="construction">When true, the circle is added as a construction sketch entity.</param>
      <returns>The resulting sketch circle.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddCircle(devDept.Geometry.Point2D,System.Double,System.Boolean,System.Boolean)">
      <summary>
            Adds a circle to the sketch.
            </summary>
      <param name="center">The circle center</param>
      <param name="radius">The circle radius</param>
      <param name="diamConstraint">When true, the diameter constraint is added.</param>
      <param name="construction">When true, the circle is added as a construction sketch entity.</param>
      <returns>The resulting SketchCircle.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddPolygon(System.Collections.Generic.IList{devDept.Geometry.Point2D},System.Boolean,System.Boolean)">
      <summary>
            Adds a closed polygon to the sketch.
            </summary>
      <param name="points">The list of 2D points</param>
      <param name="horVerConstraints">When true, horizontal and vertical constraints are added.</param>
      <param name="construction">When true, the polygon is added as construction sketch entities.</param>
      <remarks>Start/end points must not be duplicated.</remarks>
      <returns>The array of polygon segments.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddPolygon(devDept.Geometry.Point2D[])">
      <summary>
            Adds a closed polygon to the sketch.
            </summary>
      <param name="points">The list of 2D points</param>
      <remarks>Start/end points must <b>not</b> be duplicated.</remarks>
      <returns>The array of polygon segments.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddOpenPolygon(devDept.Geometry.Point2D[])">
      <summary>
            Adds an open polygon to the sketch.
            </summary>
      <param name="points">The list of 2D points</param>
      <returns>The array of polygon segments.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddOpenPolygon(System.Collections.Generic.IList{devDept.Geometry.Point2D},System.Boolean)">
      <summary>
            Adds an open polygon to the sketch.
            </summary>
      <param name="points">The linear path points.</param>
      <param name="horVerConstraints">When true, horizontal and vertical constraints are added.</param>
      <returns>The array of polygon segments.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddRectangle(System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Adds a rectangle to the sketch.
            </summary>
      <param name="x">The lower-left corner X position</param>
      <param name="y">The lower-left corner Y position</param>
      <param name="width">The rectangle width</param>
      <param name="height">The rectangle height</param>
      <param name="angle">The rectangle angle in radians. When zero the horizontal constraint is added.</param>
      <param name="construction">When true, the rectangle is added as construction sketch entities.</param>
      <returns>The array of sketch entities representing the rectangle: bottom, right, top, left.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddCircularSlot(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Adds a circular slot to the sketch.
            </summary>
      <param name="x">The inner arc center X position</param>
      <param name="y">The inner arc center Y position</param>
      <param name="startAngle">The slot start angle in radians</param>
      <param name="deltaAngle">The slot delta angle in radians</param>
      <param name="radius">The arc radius</param>
      <param name="slotRadius">The slot radius</param>
      <param name="dimConstraint">When true, three dimension constraints are added:
            one radius constraint for the inner arc, one radius constraint for the bottom
            arc, one length constraint for the outer arc.</param>
      <returns>
            The array of sketch entities representing the circular slot: bottom arc, outer
            arc, top arc, inner arc.
            </returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddHexagon(System.Double,System.Boolean,devDept.Geometry.ConstraintSolver.SketchPoint@,System.Double)">
      <summary>
            Adds an hexagon to the sketch.
            </summary>
      <param name="radius">The circle radius</param>
      <param name="inscribed">When true, the hexagon is inscribed in the construction circle. When false the hexagon side are tangent to the construction circle.</param>
      <param name="center">The construction circle center point</param>
      <param name="angle">The slot angle in radians from X axis. When zero, the horizontal constraint is added.</param>
      <returns>The array of hexagon segments.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddInscribedPolygon(System.Int32,System.Double,System.Boolean,devDept.Geometry.ConstraintSolver.SketchPoint@,System.Double)">
      <summary>
            Adds a regular polygon of n sides to the sketch.
            </summary>
      <param name="sides">The number of sides</param>
      <param name="radius">The circle radius</param>
      <param name="inscribed">When true, the polygon is inscribed in the construction circle. When false the polygon side are tangent to the construction circle.</param>
      <param name="center">The circle center 2D point</param>
      <param name="angle">The slot angle in radians from X axis. When zero, the horizontal constraint is added.</param>
      <returns>The array of polygon segments.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.Solve">
      <summary>
      </summary>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.DOF">
      <summary>
            The degrees of Freedom of the constrained entities of the sketch.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.Write(System.String,System.Xml.Formatting)">
      <summary>
            Writes the sketch to the specified file.
            </summary>
      <param name="fileName">Name of the file to write</param>
      <param name="formatting">The output format</param>
      <seealso cref="M:devDept.Geometry.ConstraintSolver.Sketch.Read(System.Xml.XmlReader)" />
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.Read(System.String)">
      <summary>
            Reads the sketch from the specified file.
            </summary>
      <param name="fileName">Name of the file to read</param>
      <seealso cref="M:devDept.Geometry.ConstraintSolver.Sketch.Write(System.Xml.XmlTextWriter)" />
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.WriteToString">
      <summary>
            Writes the sketch to a string in XML format.
            </summary>
      <returns>
            The string with the sketch content as XML.
            </returns>
      <seealso cref="M:devDept.Geometry.ConstraintSolver.Sketch.ReadFromString(System.String)" />
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.ReadFromString(System.String)">
      <summary>
            Reads the sketch from the specified string.
            </summary>
      <param name="content">The string content as XML</param>
      <seealso cref="M:devDept.Geometry.ConstraintSolver.Sketch.WriteToString" />
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintLength(devDept.Geometry.ConstraintSolver.SketchCurve)">
      <summary>
            Adds a length constraint to the given entity (either arc, line or circle).
            </summary>
      <param name="curve">The sketch curve to be constrained (either arc, line or circle)</param>
      <returns>The newly created length constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintLength(devDept.Geometry.ConstraintSolver.SketchCurve,System.Double)">
      <summary>
            Adds a length constraint to the given entity (either arc, line or circle).
            </summary>
      <param name="curve">The sketch curve to be constrained (either arc, line or circle)</param>
      <param name="length">The desired length</param>
      <returns>The newly created length constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintDiameter(devDept.Geometry.ConstraintSolver.SketchCurve)">
      <summary>
            Adds a diameter constraint of the specified value to the given entity,
            fixing the diameter to its current value.
            </summary>
      <param name="curve">The sketch curve to be constrained (arc or circle)</param>
      <returns>The newly created diameter constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintDiameter(devDept.Geometry.ConstraintSolver.SketchCurve,System.Double)">
      <summary>
            Adds a diameter constraint of the specified value to the given entity.
            </summary>
      <param name="curve">The sketch curve to be constrained (arc or circle)</param>
      <param name="diameter">The value for the diameter constraint</param>
      <returns>The newly created diameter constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintRadius(devDept.Geometry.ConstraintSolver.SketchCurve)">
      <summary>
            Adds a radius constraint of the specified value to the given entity,
            fixing the radius to its current value.
            </summary>
      <param name="curve">The sketch curve to be constrained (arc or circle)</param>
      <returns>The newly created radius constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintRadius(devDept.Geometry.ConstraintSolver.SketchCurve,System.Double)">
      <summary>
            Adds a radius constraint of the specified value to the given entity.
            </summary>
      <param name="curve">The sketch curve to be constrained (arc or circle)</param>
      <param name="radius">The value for the radius constraint</param>
      <returns>The newly created radius constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintEqualLength(devDept.Geometry.ConstraintSolver.SketchCurve,devDept.Geometry.ConstraintSolver.SketchCurve)">
      <summary>
            Adds an equal-length constraint between two entities.
            </summary>
      <param name="entity1">The first entity.</param>
      <param name="entity2">The second entity.</param>
      <returns>The newly crated Equal constraint</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintEqualRadius(devDept.Geometry.ConstraintSolver.SketchCircle,devDept.Geometry.ConstraintSolver.SketchCircle)">
      <summary>
            Adds the equal radius constraint between two arc/circles entities.
            </summary>
      <param name="circle1">The first arc/circle</param>
      <param name="circle2">The second arc/circle</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintVertical(devDept.Geometry.ConstraintSolver.SketchLine)">
      <summary>
            Adds the vertical constraint for a line. 
            </summary>
      <param name="sketchLine">The line.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintHorizontal(devDept.Geometry.ConstraintSolver.SketchLine)">
      <summary>
            Adds the horizontal constraint for a line.
            </summary>
      <param name="sketchLine">The line.</param>
      <returns>The added constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintVertical(devDept.Geometry.ConstraintSolver.SketchPoint,devDept.Geometry.ConstraintSolver.SketchPoint)">
      <summary>
            Adds a same X constraint between two points.
            </summary>
      <param name="a">The first point.</param>
      <param name="b">The second point.</param>
      <returns>The added constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintHorizontal(devDept.Geometry.ConstraintSolver.SketchPoint,devDept.Geometry.ConstraintSolver.SketchPoint)">
      <summary>
            Adds an same Y constraint between two points.
            </summary>
      <param name="a">The first point.</param>
      <param name="b">The second point.</param>
      <returns>The added constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintPointOn(devDept.Geometry.ConstraintSolver.SketchPoint,devDept.Geometry.ConstraintSolver.SketchCurve)">
      <summary>
            Adds a point-on-entity constraint. 
            </summary>
      <param name="point">The point.</param>
      <param name="curve">The sketch curve.</param>
      <returns> The added constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintPointAt(devDept.Geometry.ConstraintSolver.SketchPoint,devDept.Geometry.ConstraintSolver.SketchCurve,System.Double)">
      <summary>
             Adds a point-at-entity constraint. 
            </summary>
      <param name="point">The sketch point.</param>
      <param name="curve">The sketch curve.</param>
      <param name="value">The parametric value.</param>
      <returns>
      </returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintMidPoint(devDept.Geometry.ConstraintSolver.SketchPoint,devDept.Geometry.ConstraintSolver.SketchCurve)">
      <summary>
            Adds a mid point constraint. 
            </summary>
      <param name="point">The point.</param>
      <param name="curve">The sketch curve.</param>
      <returns> The added constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintPointOn(devDept.Geometry.ConstraintSolver.SketchPoint,devDept.Geometry.ConstraintSolver.SketchCurve,System.Double)">
      <summary>
            Adds a point-on-entity constraint and fix the position of the point on the curve
            to a certain position specified by the value parameter.
            </summary>
      <param name="point">The point that will lie on the curve</param>
      <param name="curve">The curve entity where the point will lie</param>
      <param name="value">Value relative to the curve domain identifying the position
            of the point</param>
      <returns>
            The newly created constraint.
            </returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintAngle(devDept.Geometry.ConstraintSolver.SketchArc)">
      <summary>
            Adds an angle constraint for the specified arc, fixing the angle at the current value.
            </summary>
      <param name="sketchArc">The arc to be constrained.</param>
      <returns>The newly created angle constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintAngle(devDept.Geometry.ConstraintSolver.SketchArc,System.Double)">
      <summary>
            Adds an angle constraint of the given value for the specified arc.
            </summary>
      <param name="sketchArc">The arc to be constrained.</param>
      <param name="value">The value for the angle constraint</param>
      <returns>The newly created angle constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintAngle(devDept.Geometry.ConstraintSolver.SketchLine,devDept.Geometry.ConstraintSolver.SketchLine)">
      <summary>
            Adds an angle constraint between the two specified lines.
            </summary>
      <param name="line1">The first line delimiting the angle</param>
      <param name="line2">The second line delimiting the angle</param>
      <returns>The newly created angle constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintAngle(devDept.Geometry.ConstraintSolver.SketchLine,devDept.Geometry.ConstraintSolver.SketchLine,System.Double)">
      <summary>
            Adds an angle constraint of the given value between the two specified lines.
            </summary>
      <param name="sketchLine1">The first line delimiting the angle</param>
      <param name="sketchLine2">The second line delimiting the angle</param>
      <param name="angle">The desired angle between the lines</param>
      <returns>The newly created angle constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintAngle(devDept.Geometry.ConstraintSolver.SketchLine,devDept.Geometry.ConstraintSolver.SketchLine,devDept.Geometry.Point2D)">
      <summary>
            Adds an angle constraint between the two given lines. The specified quadrant point identifies
            the quadrant where the angle constraint is added (a quadrant is one of the four circular sectors
            formed by the infinite extension of the two lines).
            </summary>
      <param name="sketchLine1">The first line delimiting the angle</param>
      <param name="sketchLine2">The second line delimiting the angle</param>
      <param name="quadrantPoint">
            The quadrant point, identifying one of the four circular sectors formed by the infinite
            extensions of the lines
            </param>
      <returns>The newly created angle constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintAngle(devDept.Geometry.ConstraintSolver.SketchLine,devDept.Geometry.ConstraintSolver.SketchLine,devDept.Geometry.Point2D,System.Double)">
      <summary>
            Adds an angle constraint of the specified value between the two given lines. The specified quadrant
            point identifies the quadrant where the angle constraint is added (a quadrant is one of the four
            circular sectors formed by the infinite extension of the two lines).
            </summary>
      <param name="line1">The first line delimiting the angle</param>
      <param name="line2">The second line delimiting the angle</param>
      <param name="quadrantPoint">
            The quadrant point, identifying one of the four circular sectors formed by the infinite
            extensions of the lines
            </param>
      <param name="angle">The desired angle between the lines</param>
      <returns>The newly created angle constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintParallel(devDept.Geometry.ConstraintSolver.SketchCurve,devDept.Geometry.ConstraintSolver.SketchCurve)">
      <summary>
      </summary>
      <param name="entity1">
      </param>
      <param name="entity2">
      </param>
      <returns>The newly </returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintPerpendicular(devDept.Geometry.ConstraintSolver.SketchCurve,devDept.Geometry.ConstraintSolver.SketchCurve)">
      <summary>
      </summary>
      <param name="entity1">
      </param>
      <param name="entity2">
      </param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintCollinear(devDept.Geometry.ConstraintSolver.SketchPoint,devDept.Geometry.ConstraintSolver.SketchPoint,devDept.Geometry.ConstraintSolver.SketchPoint)">
      <summary>
            Adds the collinear constraint among three points.
            </summary>
      <param name="p1">The first point.</param>
      <param name="p2">The second point. </param>
      <param name="p3">The third point.</param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddHorizontalConstraintDistance(devDept.Geometry.ConstraintSolver.SketchPoint,devDept.Geometry.ConstraintSolver.SketchPoint)">
      <summary>
            Adds a distance constraint for the two specified points.
            </summary>
      <param name="point1">The first point</param>
      <param name="point2">The second point</param>
      <returns>The newly created line distance constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddVerticalConstraintDistance(devDept.Geometry.ConstraintSolver.SketchPoint,devDept.Geometry.ConstraintSolver.SketchPoint)">
      <summary>
            Adds a distance constraint for the two specified points.
            </summary>
      <param name="point1">The first point</param>
      <param name="point2">The second point</param>
      <returns>The newly created line distance constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintDistance(devDept.Geometry.ConstraintSolver.SketchPoint,devDept.Geometry.ConstraintSolver.SketchPoint)">
      <summary>
            Adds a distance constraint for the two specified points.
            </summary>
      <param name="point1">The first point</param>
      <param name="point2">The second point</param>
      <returns>The newly created line distance constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintDistance(devDept.Geometry.ConstraintSolver.SketchPoint,devDept.Geometry.ConstraintSolver.SketchPoint,System.Double)">
      <summary>
            Adds a distance constraint for the two specified points.
            </summary>
      <param name="point1">The first point</param>
      <param name="point2">The second point</param>
      <param name="distance">The desired distance between the points</param>
      <returns>The newly created line distance constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddHorizontalConstraintDistance(devDept.Geometry.ConstraintSolver.SketchPoint,devDept.Geometry.ConstraintSolver.SketchPoint,System.Double)">
      <summary>
            Adds a distance constraint for the two specified points.
            </summary>
      <param name="point1">The first point</param>
      <param name="point2">The second point</param>
      <param name="distance">The desired distance between the points</param>
      <returns>The newly created line distance constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddVerticalConstraintDistance(devDept.Geometry.ConstraintSolver.SketchPoint,devDept.Geometry.ConstraintSolver.SketchPoint,System.Double)">
      <summary>
            Adds a distance constraint for the two specified points.
            </summary>
      <param name="point1">The first point</param>
      <param name="point2">The second point</param>
      <param name="distance">The desired distance between the points</param>
      <returns>The newly created line distance constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintDistance(devDept.Geometry.ConstraintSolver.SketchLine,devDept.Geometry.ConstraintSolver.SketchLine)">
      <summary>
            Adds a distance constraint for the two specified lines.
            </summary>
      <param name="line1">The first line</param>
      <param name="line2">The second line</param>
      <returns>The newly created line distance constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintDistance(devDept.Geometry.ConstraintSolver.SketchLine,devDept.Geometry.ConstraintSolver.SketchLine,System.Double)">
      <summary>
            Adds a distance constraint for the two specified lines.
            </summary>
      <param name="entity1">The first line</param>
      <param name="entity2">The second line</param>
      <param name="distance">The desired distance between the lines</param>
      <returns>The newly created line distance constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintDistance(devDept.Geometry.ConstraintSolver.SketchPoint,devDept.Geometry.ConstraintSolver.SketchLine)">
      <summary>
            Adds the distance between a point and a line constraint.
            </summary>
      <param name="point">The point.</param>
      <param name="line">The line.</param>
      <returns>The added constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintDistance(devDept.Geometry.ConstraintSolver.SketchPoint,devDept.Geometry.ConstraintSolver.SketchLine,System.Double)">
      <summary>
            Adds the distance between a point and a line constraint.
            </summary>
      <param name="point">The point</param>
      <param name="line">The line</param>
      <param name="distance">The desired distance</param>
      <returns>The newly created point line distance constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintJoin(devDept.Geometry.ConstraintSolver.SketchPoint,devDept.Geometry.ConstraintSolver.SketchPoint)">
      <summary>
      </summary>
      <param name="point1">
      </param>
      <param name="point2">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintConcentric(devDept.Geometry.ConstraintSolver.SketchCircle,devDept.Geometry.ConstraintSolver.SketchCircle)">
      <summary>
            Adds the concentric constraints between arcs and circles.
            </summary>
      <param name="circle1">The first arc/circle</param>
      <param name="circle2">The second arc/circle</param>
      <returns>The newly created point coincidence constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintConcentricDistance(devDept.Geometry.ConstraintSolver.SketchCircle,devDept.Geometry.ConstraintSolver.SketchCircle)">
      <summary>
            Adds the concentric constraints between arcs and circles.
            </summary>
      <param name="circle1">The first arc/circle</param>
      <param name="circle2">The second arc/circle</param>
      <returns>The newly created point coincidence constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddFixedPointConstraint(devDept.Geometry.ConstraintSolver.SketchCurve)">
      <summary>
      </summary>
      <param name="sketchCurve">
      </param>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintJoin(devDept.Geometry.ConstraintSolver.ISketchCurve[])">
      <summary>
            Joins the given list of sketch curves to create an open contour. Constraints
            are created by trying to minimize the distance between each endpoint and the
            following. Curve directions do not influence the outcome, which is only
            dependent on point distance.Please note that this method does not close
            the contour (the user should add an additional constraint if needed).
            </summary>
      <param name="entities">
            A list of curves to be joined together. The first curve will be the start of the
            path and joined with all the others by starting from one of the endpoints: for
            this reason, passing as the first entity a curve that is in the middle of the path
            would produce unexpected results.
            </param>
      <returns>The newly created constraints.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintJoin(devDept.Geometry.ConstraintSolver.ISketchCurve,devDept.Geometry.ConstraintSolver.ISketchCurve)">
      <summary>
            Joins the two given curves creating a points coincident constraint for
            the couple of closest endpoints.
            </summary>
      <param name="entityA">The first curve</param>
      <param name="entityB">The second curve</param>
      <returns>The newly created constraint.</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddMirrorConstraint(devDept.Geometry.ConstraintSolver.SketchCurve,devDept.Geometry.ConstraintSolver.SketchCurve,devDept.Geometry.ConstraintSolver.SketchLine)">
      <summary>
            Adds a mirror constraint between two entities
            </summary>
      <param name="ent1">The first entity</param>
      <param name="ent2">The second entity</param>
      <param name="axis">The symmetry axis.</param>
      <returns>The newly created constraint</returns>
      <remarks>The two entities must be of the same type.</remarks>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintTangent(devDept.Geometry.ConstraintSolver.SketchCurve,devDept.Geometry.ConstraintSolver.SketchCurve)">
      <summary>
      </summary>
      <param name="ent1">
      </param>
      <param name="ent2">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.AddConstraintCollinear(devDept.Geometry.ConstraintSolver.SketchCurve,devDept.Geometry.ConstraintSolver.SketchCurve)">
      <summary>
            Adds a collinear constraint between two lines.
            </summary>
      <param name="line1">The first line.</param>
      <param name="line2">The second line.</param>
      <returns>The newly created constraint</returns>
    </member>
    <member name="M:devDept.Geometry.ConstraintSolver.Sketch.GetRedundantConstraints">
      <summary>
            Return the redundant constraints, that are causing the 
            sketch to be over-constrained.
            </summary>
      <returns>
            A list of constraints that can be removed in order to
            decrease the number of redundant equations in the system.
            </returns>
    </member>
    <member name="T:devDept.Geometry.ConstraintSolver.solveFailureType">
      <summary>
            The result of the Solve operation on the EquationSystem.
            </summary>
    </member>
    <member name="F:devDept.Geometry.ConstraintSolver.solveFailureType.Success">
      <summary>
            Success
            </summary>
    </member>
    <member name="F:devDept.Geometry.ConstraintSolver.solveFailureType.DidntConverge">
      <summary>
            No solution found
            </summary>
    </member>
    <member name="F:devDept.Geometry.ConstraintSolver.solveFailureType.Redundant">
      <summary>
            Some redundant constraints found
            </summary>
    </member>
    <member name="T:devDept.Geometry.Entities.GArc">
      <summary>
            Arc entity.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GArc.#ctor(devDept.Geometry.Point3D,System.Double,System.Double)">
      <summary>Arc parallel to XY plane constructor.</summary>
      <param name="center">3D center point</param>
      <param name="radius">Radius</param>
      <param name="angleInRadians">Span angle in radians</param>
      <seealso cref="M:devDept.Geometry.Utility.DegToRad(System.Double)" />
      <seealso cref="M:devDept.Geometry.Utility.RadToDeg(System.Double)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GArc.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point3D,System.Double,System.Double)">
      <summary>Arc not parallel to XY plane constructor.</summary>
      <param name="arcPlane">Plane</param>
      <param name="center">3D center point</param>
      <param name="radius">Radius</param>
      <param name="angleInRadians">Span angle in radians</param>
      <seealso cref="M:devDept.Geometry.Utility.DegToRad(System.Double)" />
      <seealso cref="M:devDept.Geometry.Utility.RadToDeg(System.Double)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GArc.#ctor(devDept.Geometry.Point3D,System.Double,System.Double,System.Double)">
      <summary>Arc parallel to XY plane constructor.</summary>
      <param name="center">3D center point</param>
      <param name="radius">Radius</param>
      <param name="startAngleInRadians">Start angle in radians</param>
      <param name="endAngleInRadians">End angle in radians</param>
      <remarks>Angles can be negative. StartAngle must be smaller than EndAngle.</remarks>
      <seealso cref="M:devDept.Geometry.Utility.DegToRad(System.Double)" />
      <seealso cref="M:devDept.Geometry.Utility.RadToDeg(System.Double)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GArc.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>Arc parallel to XY plane constructor.</summary>
      <param name="x">Center's X coordinate</param>
      <param name="y">Center's Y coordinate</param>
      <param name="z">Center's Z coordinate</param>
      <param name="radius">Radius</param>
      <param name="startAngleInRadians">Start angle in radians</param>
      <param name="endAngleInRadians">End angle in radians</param>
      <remarks>Angles can be negative. StartAngle must be smaller than EndAngle.</remarks>
      <seealso cref="M:devDept.Geometry.Utility.DegToRad(System.Double)" />
      <seealso cref="M:devDept.Geometry.Utility.RadToDeg(System.Double)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GArc.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point3D,System.Double,System.Double,System.Double)">
      <summary>Arc not parallel to XY plane constructor.</summary>
      <param name="arcPlane">Plane</param>
      <param name="center">3D center point</param>
      <param name="radius">Radius</param>
      <param name="startAngleInRadians">Start angle in radians</param>
      <param name="endAngleInRadians">End angle in radians</param>
      <remarks>Angles can be negative. StartAngle must be smaller than EndAngle.</remarks>
      <seealso cref="M:devDept.Geometry.Utility.DegToRad(System.Double)" />
      <seealso cref="M:devDept.Geometry.Utility.RadToDeg(System.Double)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GArc.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point2D,System.Double,System.Double,System.Double)">
      <summary>Plane, center, radius and angles constructor.</summary>
      <param name="arcPlane">Plane</param>
      <param name="center">2D center point</param>
      <param name="radius">Radius</param>
      <param name="startAngleInRadians">Start angle in radians</param>
      <param name="endAngleInRadians">End angle in radians</param>
      <remarks>Angles can be negative. StartAngle must be smaller than EndAngle.</remarks>
      <seealso cref="M:devDept.Geometry.Utility.DegToRad(System.Double)" />
      <seealso cref="M:devDept.Geometry.Utility.RadToDeg(System.Double)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GArc.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>Center, start and end point constructor.</summary>
      <param name="center">3D center point</param>
      <param name="start">3D start point</param>
      <param name="end">3D end point</param>
      <remarks>Center, start point and end point must be non collinear.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GArc.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>Plane, center, start and end point constructor.</summary>
      <param name="arcPlane">Plane</param>
      <param name="center">2D center point</param>
      <param name="start">2D start point</param>
      <param name="end">2D end point</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GArc.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point3D,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Boolean)">
      <summary>Plane, center, radius, start and end point constructor.</summary>
      <param name="arcPlane">Plane</param>
      <param name="center">3D center point</param>
      <param name="radius">Radius</param>
      <param name="start">3D start point</param>
      <param name="end">3D end point</param>
      <param name="flip">If true, the complementary arc is created.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GArc.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D,System.Boolean)">
      <summary>
            Arc from three points constructor.
            </summary>
      <param name="arcPlane">Plane</param>
      <param name="first">First 2D point</param>
      <param name="second">Second 2D point</param>
      <param name="third">Third 2D point</param>
      <param name="flip">When true, the complementary arc is created.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GArc.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Boolean)">
      <summary>
            Arc from three 3D points constructor.
            </summary>
      <param name="first">First 3D point</param>
      <param name="second">Second 3D point</param>
      <param name="third">Third 3D point</param>
      <param name="flip">When true, the complementary arc is created.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GArc.Clone">
      <summary>
            Creates a deep copy of this arc.
            </summary>
      <returns>The new arc object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GArc.Reverse">
      <summary>
            Reverses the arc direction.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GArc.Angle">
      <summary>
            Gets arc's angle.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GArc.AngleInRadians">
      <summary>
            Gets arc's angle in radians.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GArc.AngleInDegrees">
      <summary>
            Gets arc's angle in degrees.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GArc.MidPoint">
      <summary>
            Gets the arc's middle point.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GArc.Domain">
      <summary>
            Gets or sets the arc's domains in radians.
            </summary>
      <exception cref="T:devDept.Eyeshot.EyeshotException">Thrown when trying to set a domain smaller than <see cref="F:devDept.Geometry.Utility.ZERO_TOLERANCE" />.</exception>
    </member>
    <member name="M:devDept.Geometry.Entities.GArc.Length">
      <summary>Gets arc length.</summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GArc.IsCircle">
      <summary>Returns true if the Arc is closed.</summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GArc.GetPointsByLength(System.Double)">
      <summary>
            Subdivides the igCurve by the distance provided.
            </summary>
      <param name="length">The distance</param>
      <returns>An array of 3D points.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GArc.TrimBy(devDept.Geometry.Point3D,System.Boolean)">
      <summary>
            Trims the arc at the limit point projection.
            </summary>
      <param name="limit">The limit point</param>
      <param name="flipSide">The flip side flag</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GArc.GetNurbsFormParameterFromRadian(System.Double,System.Double@)">
      <summary>
            Converts an arc radians parameter to a Nurbs igCurve arc parameter.
            </summary>
      <param name="radianParam">Radians parameter (0 to 2PI)</param>
      <param name="nurbsParam">The igCurve arc parameter</param>
      <returns>True if the operation succeeded, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GArc.GetNurbsFormParameterFromRadian(System.Double,System.Double@,devDept.Geometry.Entities.GCurve)">
      <summary>
            Converts an arc radians parameter to a Nurbs igCurve arc parameter.
            </summary>
      <param name="radianParam">Radians parameter(0 to 2PI)</param>
      <param name="nurbsParam">The igCurve arc parameter</param>
      <param name="crv">The arc in Nurbs form</param>
      <returns>True if the operation succeeded, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GArc.GetRadianFromNurbFormParameter(System.Double,System.Double@)">
      <summary>
            Converts a Nurbs igCurve arc parameter to an arc radian parameter.
            </summary>
      <param name="nurbParameter">The Nurbs igCurve arc parameter</param>
      <param name="radianParameter">The arc radian parameter</param>
      <returns>True if the operation succeeded, false otherwise.</returns>
    </member>
    <!-- Badly formed XML comment ignored for member "M:devDept.Geometry.Entities.GArc.GetRadianFromNurbFormParameter(System.Double,System.Double@,devDept.Geometry.Entities.GCurve)" -->
    <member name="M:devDept.Geometry.Entities.GArc.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GArc.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.Entities.GCircle">
      <summary>
            GCircle entity.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GCircle.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>GCircle parallel to XY plane constructor.</summary>
      <param name="x">Center's X coordinate</param>
      <param name="y">Center's Y coordinate</param>
      <param name="z">Center's Z coordinate</param>
      <param name="radius">Radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCircle.#ctor(devDept.Geometry.Point3D,System.Double)">
      <summary>GCircle parallel to XY plane constructor.</summary>
      <param name="center">3D center point</param>
      <param name="radius">Radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCircle.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point3D,System.Double)">
      <summary>GCircle not parallel to XY plane constructor.</summary>
      <param name="plane">Plane</param>
      <param name="center">3D center point</param>
      <param name="radius">Radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCircle.#ctor(devDept.Geometry.Plane,System.Double)">
      <summary>GCircle not parallel to XY plane constructor.</summary>
      <param name="plane">Plane</param>
      <param name="radius">Radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCircle.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point2D,System.Double)">
      <summary>Plane, center and radius constructor.</summary>
      <param name="plane">Plane</param>
      <param name="center">2D center point</param>
      <param name="radius">Radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCircle.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            GCircle from three points constructor.
            </summary>
      <param name="plane">Plane</param>
      <param name="first">First 2D point</param>
      <param name="second">Second 2D point</param>
      <param name="third">Third 2D point</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCircle.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            GCircle from three 3D points constructor.
            </summary>
      <param name="first">First 3D point</param>
      <param name="second">Second 3D point</param>
      <param name="third">Third 3D point</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCircle.Clone">
      <summary>
            Creates a deep copy of this circle.
            </summary>
      <returns>The new circle object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCircle.IsInPlane(devDept.Geometry.Plane,System.Double)">
      <summary>
            Checks if the GCircle lies on a specific plane.
            </summary>
      <param name="testPlane">The plane</param>
      <param name="tolerance">Tolerance</param>
      <returns>True if the test succeeded, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCircle.IsPointInside(devDept.Geometry.Point3D)">
      <summary>
            Checks if a point is inside the GCircle.
            </summary>
      <param name="testPoint">The point to be tested</param>
      <returns>True if the point is inside, false if it is outside or on the circle.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCircle.PointAt(System.Double)">
      <summary>
            Evaluates a point on the circle using trigonometric parameterization.
            </summary>
      <param name="t">Parameter</param>
      <returns>The 3D point.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GCircle.Center">
      <summary>
            Gets or sets circle's center point.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GCircle.Radius">
      <summary>
            Gets or sets circle's radius.
            </summary>
      <exception cref="T:devDept.Eyeshot.EyeshotException">Thrown when trying to set a radius smaller than <see cref="F:devDept.Geometry.Utility.ZERO_TOLERANCE" />.</exception>
    </member>
    <member name="P:devDept.Geometry.Entities.GCircle.Diameter">
      <summary>
            Gets circle's diameter.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GCircle.Length">
      <summary>
            Gets the circle length.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GCircle.Domain">
      <summary>
            Gets the circle's domain. It cannot be set.
            </summary>
      <exception cref="T:devDept.Eyeshot.EyeshotException">Thrown when you try to set the <see cref="P:devDept.Geometry.Entities.GCircle.Domain" /> property. Use Arc instead.</exception>
    </member>
    <member name="M:devDept.Geometry.Entities.GCircle.GetPointsByLength(System.Double)">
      <summary>
            Subdivides the igCurve by the distance provided.
            </summary>
      <param name="length">The distance</param>
      <returns>An array of 3D points.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCircle.TangentAt(System.Double)">
      <summary>
            Evaluates the unit tangent vector at a parameter.
            </summary>
      <param name="t">Evaluation parameter</param>
      <returns>Unit tangent vector of the igCurve at the parameter t.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCircle.DerivativeAt(System.Int32,System.Double)">
      <summary>
            Computes the circle derivative at a parameter. 
            </summary>
      <param name="d">The desired derivative (&gt;=0)</param>
      <param name="t">Evaluation parameter</param>
      <returns>The d<sup>th</sup> circle derivative at the parameter t.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCircle.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCircle.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.Entities.GCompositeCurve">
      <summary>
            Composite igCurve definition.
            </summary>
      <remarks>
            When passing the igCurve list into constructors, igCurves are analyzed, sorted and reversed if necessary. This is not true when using the <see cref="P:devDept.Geometry.Entities.GCompositeCurve.CurveList" /> property, in this case a call to the <see cref="M:devDept.Geometry.Entities.GCompositeCurve.SortAndOrient(System.Double)" /> method is needed. The first igCurve in the list determines the contour orientation.
            </remarks>
    </member>
    <member name="P:devDept.Geometry.Entities.GCompositeCurve.CurveList">
      <summary>
            Gets or sets the composite igCurve igCurve list.
            </summary>
      <remarks>After altering the igCurve list, you should call the <see cref="M:devDept.Geometry.Entities.GCompositeCurve.SortAndOrient(System.Double)" /> method to fix igCurve sorting and orientation.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.#ctor(System.Collections.Generic.IEnumerable{devDept.Geometry.Entities.IGCurve})">
      <summary>
            GCurve list constructor. The first igCurve in the list determines the contour orientation.
            </summary>
      <param name="curveList">The igCurve list</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.#ctor(System.Collections.Generic.IEnumerable{devDept.Geometry.Entities.IGCurve},System.Boolean)">
      <summary>
            GCurve list and sorting flag constructor. The first igCurve in the list determines the contour orientation.
            </summary>
      <param name="curveList">The igCurve list</param>
      <param name="sortAndOrient">When true, the igCurves are properly sorted and oriented.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.#ctor(System.Collections.Generic.IEnumerable{devDept.Geometry.Entities.IGCurve},System.Double)">
      <summary>
            GCurve list constructor. The first igCurve in the list determines the contour orientation.
            </summary>
      <param name="curveList">The igCurve list</param>
      <param name="closureTol">The max distance between the contour start and end points to assume the igCurve as closed.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.#ctor(System.Collections.Generic.IEnumerable{devDept.Geometry.Entities.IGCurve},System.Double,System.Boolean)">
      <summary>
            GCurve list constructor. The first igCurve in the list determines the contour orientation.
            </summary>
      <param name="curveList">The igCurve list</param>
      <param name="closureTol">The max distance between the contour start and end points to assume the igCurve as closed.</param>
      <param name="sortAndOrient">When true, the igCurves are properly sorted and oriented.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.#ctor(devDept.Geometry.Entities.IGCurve[])">
      <summary>
            GCurve list constructor. The first igCurve in the list determines the contour orientation.
            </summary>
      <param name="igCurveList">The igCurve list</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.#ctor(devDept.Geometry.Entities.IGCurve)">
      <summary>
            One igCurve only constructor.
            </summary>
      <param name="igCurve">The igCurve</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.Clone">
      <summary>
            Creates a deep copy of this composite igCurve.
            </summary>
      <returns>The new composite igCurve object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.Explode">
      <summary>
            Returns the list of igCurves as array of entities.
            </summary>
      <param name="propagateAttributes">If true, propagates the attributes of the composite igCurve (<see cref="!:GEntity.ColorMethod" />, <see cref="!:Color" />, <see cref="!:GEntity.MaterialName" />, <see cref="!:GEntity.LineTypeMethod" />, <see cref="!:GEntity.LineTypeName" />, <see cref="!:GEntity.LineWeightMethod" />, <see cref="!:GEntity.LineWeight" />) to the exploded igCurves</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.GetPointsByLength(System.Double)">
      <summary>
            Subdivides the igCurve by the distance provided.
            </summary>
      <param name="length">The distance between points</param>
      <returns>An array of 3D points.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.GetPointsByLengthPerSegment(System.Double)">
      <summary>
            Subdivides each segment of the igCurve by the distance provided.
            </summary>
      <param name="length">The distance between points</param>
      <returns>An array of 3D points.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.SplitAtDiscontinuities(System.Boolean)">
      <summary>
            Splits the composite igCurve at derivative discontinuities (e.g. cusps, kinks) of each segment, returns an array of smooth segments.
            </summary>
      <param name="speedChange">If true, when the tangents have the same direction but different lengths, the igCurve will be split. If false, it won't be split.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.IsPlanar(System.Double,devDept.Geometry.Plane@)">
      <summary>
            Checks if the igCurve is planar.
            </summary>
      <param name="tol">The tolerance</param>
      <param name="plane">The plane where the igCurve lies</param>
      <returns>True if the igCurve is planar within tolerance, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.SortAndOrient">
      <summary>
            Sorts and orients internal curves. Closure tolerance is estimated automatically using composite curve extents.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.SortAndOrient(System.Double)">
      <summary>
            Sorts and orients internal igCurves.
            </summary>
      <param name="closureTol">The max distance between the contour start and end points to assume the igCurve as closed.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.MoreOfTwoSegmentsIncidentOnTheSameEndpoint(System.Double)">
      <summary>
            Check if the igCurve have more of two segments incident on the same endpoint.
            </summary>
      <param name="equalTol">3D points comparison tolerance</param>
      <returns>True when more of two igCurve segments are incident on the same endpoint, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateRectangle(System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a rectangular composite igCurve.
            </summary>
      <param name="width">Width</param>
      <param name="height">Height</param>
      <param name="centered">When true, the rectangle is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateRectangle(System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a rectangular composite igCurve by position.
            </summary>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="width">Width</param>
      <param name="height">Height</param>
      <param name="angle">Rotation angle in radians</param>
      <param name="centered">When true, the rectangle is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateRectangle(devDept.Geometry.Plane,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a rectangular composite igCurve by plane.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="width">Width</param>
      <param name="height">Height</param>
      <param name="centered">When true, the rectangle is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateRectangle(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a rectangular composite igCurve by plane and position.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="width">Width</param>
      <param name="height">Height</param>
      <param name="angle">Rotation angle in radians</param>
      <param name="centered">When true, the rectangle is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateRoundedRectangle(System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a rounded rectangular composite igCurve.
            </summary>
      <param name="width">Width</param>
      <param name="height">Height</param>
      <param name="radius">Corner radius</param>
      <param name="centered">When true, the rectangle is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateRoundedRectangle(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a rounded rectangular composite igCurve by position.
            </summary>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="width">Width</param>
      <param name="height">Height</param>
      <param name="radius">Corner radius</param>
      <param name="angle">Rotation angle in radians</param>
      <param name="centered">When true, the rectangle is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateRoundedRectangle(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a rounded rectangular composite igCurve by plane.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="width">Width</param>
      <param name="height">Height</param>
      <param name="radius">Corner radius</param>
      <param name="centered">When true, the rectangle is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateRoundedRectangle(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a rounded rectangular composite igCurve by plane and position.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="width">Width</param>
      <param name="height">Height</param>
      <param name="radius">Corner radius</param>
      <param name="angle">Rotation angle in radians</param>
      <param name="centered">When true, the rectangle is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateSlot(System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a composite igCurve with the shape of a slot.
            </summary>
      <param name="length">Center to center length</param>
      <param name="radius">Radius</param>
      <param name="centered">When true, the slot is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateSlot(System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a composite igCurve with the shape of a slot by position.
            </summary>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="length">Center to center length</param>
      <param name="radius">Radius</param>
      <param name="angle">Rotation angle in radians</param>
      <param name="centered">When true, the slot is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateSlot(devDept.Geometry.Plane,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a composite igCurve with the shape of a slot by plane.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="length">Center to center length</param>
      <param name="radius">Radius</param>
      <param name="centered">When true, the slot is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateSlot(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a composite igCurve with the shape of a slot by plane and position.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="length">Center to center length</param>
      <param name="radius">Radius</param>
      <param name="angle">Rotation angle in radians</param>
      <param name="centered">When true, the slot is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateCircularSlot(System.Double,System.Double,System.Double)">
      <summary>
            Creates a composite igCurve with the shape of a circular slot.
            </summary>
      <param name="angle">Angle in radians</param>
      <param name="radius">Circle radius</param>
      <param name="slotRadius">Slot radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateCircularSlot(System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Creates a composite igCurve with the shape of a circular slot by position constructor.
            </summary>
      <param name="angle">Angle in radians</param>
      <param name="radius">Circle radius</param>
      <param name="slotRadius">Slot radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateCircularSlot(devDept.Geometry.Plane,System.Double,System.Double,System.Double)">
      <summary>
            Creates a composite igCurve with the shape of a circular slot by plane.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="angle">Angle in radians</param>
      <param name="radius">Circle radius</param>
      <param name="slotRadius">Slot radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateCircularSlot(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Creates a composite igCurve with the shape of a circular slot by plane and position constructor.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="angle">Angle in radians</param>
      <param name="radius">Circle radius</param>
      <param name="slotRadius">Slot radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateCircularSlot(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Creates a composite igCurve with the shape of a circular slot by plane, position and start angle.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="startAngle">Start angle in radians</param>
      <param name="deltaAngle">Delta angle in radians</param>
      <param name="radius">Circle radius</param>
      <param name="slotRadius">Slot radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateCircularSlot(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Creates a composite igCurve with the shape of a circular slot by start angle.
            </summary>
      <param name="startAngle">Start angle in radians</param>
      <param name="deltaAngle">Delta angle in radians</param>
      <param name="radius">Circle radius</param>
      <param name="slotRadius">Slot radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateCircularSlot(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Creates a composite igCurve with the shape of a circular slot by position and start angle.
            </summary>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="startAngle">Start angle in radians</param>
      <param name="deltaAngle">Delta angle in radians</param>
      <param name="radius">Circle radius</param>
      <param name="slotRadius">Slot radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateCircularSlot(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Creates a composite igCurve with the shape of a circular slot by plane, position and start angle.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="startAngle">Start angle in radians</param>
      <param name="deltaAngle">Delta angle in radians</param>
      <param name="radius">Circle radius</param>
      <param name="slotRadius">Slot radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateHexagon(System.Double,System.Boolean)">
      <summary>
            Creates an hexagonal composite igCurve.
            </summary>
      <param name="radius">Radius</param>
      <param name="inscribed">When true, the radius is considered of the inscribed circle</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateHexagon(System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates an hexagonal composite igCurve by position.
            </summary>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="radius">Radius</param>
      <param name="angle">Rotation angle in radians</param>
      <param name="inscribed">When true, the radius is considered of the inscribed circle</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCompositeCurve.CreateHexagon(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates an hexagonal composite igCurve by plane and position.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="radius">Radius</param>
      <param name="angle">Rotation angle in radians</param>
      <param name="inscribed">When true, the radius is considered of the inscribed circle</param>
    </member>
    <member name="T:devDept.Geometry.Entities.GEllipse">
      <summary>
            GEllipse entity.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipse.#ctor(devDept.Geometry.Point3D,System.Double,System.Double)">
      <summary>GEllipse parallel to XY plane constructor.</summary>
      <param name="center">3D center point</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipse.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>GEllipse parallel to XY plane constructor.</summary>
      <param name="x">Center's X coordinate</param>
      <param name="y">Center's Y coordinate</param>
      <param name="z">Center's Z coordinate</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipse.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point2D,System.Double,System.Double)">
      <summary>Plane, center, radius X and radius Y constructor.</summary>
      <param name="ellipsePlane">Plane</param>
      <param name="center">2D center point</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipse.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point3D,System.Double,System.Double)">
      <summary>GEllipse not parallel to XY plane constructor.</summary>
      <param name="ellipsePlane">Plane</param>
      <param name="center">3D center point</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipse.#ctor(devDept.Geometry.Plane,System.Double,System.Double)">
      <summary>GEllipse not parallel to XY plane constructor.</summary>
      <param name="plane">Plane</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipse.Clone">
      <summary>
            Creates a deep copy of this ellipse.
            </summary>
      <returns>The new ellipse object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipse.IsInPlane(devDept.Geometry.Plane,System.Double)">
      <summary>
            Checks if the GEllipse lies on a specific plane.
            </summary>
      <param name="testPlane">The plane</param>
      <param name="tolerance">Tolerance</param>
      <returns>True if the test succeeded, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipse.IsPointInside(devDept.Geometry.Point3D)">
      <summary>
            Checks if a point is inside the GEllipse.
            </summary>
      <param name="testPoint">The point to be tested</param>
      <returns>True if the point is inside, false if it is outside or on the ellipse.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GEllipse.IsCircle">
      <summary>Returns true if GEllipse is a GCircle.</summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GEllipse.RadiusX">
      <summary>
            Gets or sets ellipse's X radius.
            </summary>
      <exception cref="T:devDept.Eyeshot.EyeshotException">Thrown when trying to set a RadiusX smaller than <see cref="F:devDept.Geometry.Utility.ZERO_TOLERANCE" />.</exception>
    </member>
    <member name="P:devDept.Geometry.Entities.GEllipse.RadiusY">
      <summary>
            Gets or sets ellipse's Y radius.
            </summary>
      <exception cref="T:devDept.Eyeshot.EyeshotException">Thrown when trying to set a RadiusY smaller than <see cref="F:devDept.Geometry.Utility.ZERO_TOLERANCE" />.</exception>
    </member>
    <member name="P:devDept.Geometry.Entities.GEllipse.Center">
      <summary>
            Gets ellipse's center.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GEllipse.FocalDistance">
      <summary>
            Distance from the center to a focus, commonly called "c".
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipse.GetFoci(devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">
      <summary>Gets ellipse's foci.</summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipse.PointAt(System.Double)">
      <summary>Evaluates a point on the ellipse using the trigonometric parameterization.</summary>
      <param name="t">The parameter</param>
      <returns>The 3D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipse.TangentAt(System.Double)">
      <summary>
            Evaluates the unit tangent vector at a parameter.
            </summary>
      <param name="t">The parameter</param>
      <returns>The unit tangent.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipse.PointOnEllipseAt(System.Double,devDept.Geometry.Plane,System.Double,System.Double)">
      <summary>
            Evaluates a point on the ellipse using the trigonometric parameterization.
            </summary>
      <param name="t">The parameter.</param>
      <param name="plane">The ellipse plane.</param>
      <param name="r0">The ellipse's X radius.</param>
      <param name="r1">The ellipse's Y radius.</param>
      <returns>The 3D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipse.CurvatureAt(System.Double)">
      <summary>
            Evaluates the curvature 3D vector.
            </summary>
      <param name="t">Evaluation parameter</param>
      <returns>The 3D curvature vector.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipse.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipse.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="P:devDept.Geometry.Entities.GEllipse.Domain">
      <summary>
            Gets or sets the ellipse's domain.
            The parameter t on an ellipse is not the angle of ellipse.PointAt(t) with the X-axis, even if t is in [0, 2*PI].
            </summary>
      <exception cref="T:devDept.Eyeshot.EyeshotException">Thrown when you try to set the <see cref="P:devDept.Geometry.Entities.GEllipse.Domain" /> property. Use GEllipticalArc instead.</exception>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipse.Length">
      <summary>
            Gets the ellipse length.
            </summary>
    </member>
    <member name="T:devDept.Geometry.Entities.GEllipticalArc">
      <summary>
            Elliptical arc entity.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipticalArc.#ctor(devDept.Geometry.Point3D,System.Double,System.Double,System.Double)">
      <summary>GArc parallel to XY plane constructor.</summary>
      <param name="center">3D center point</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
      <param name="endParameter">Span parameter [0, endParameter]</param>
      <remarks>The parameter t on an gEllipse is not the angle of (X(t),Y(t)) with the X-axis, even if also t is in [0, 2*PI].</remarks>
      <seealso cref="M:devDept.Geometry.Utility.DegToRad(System.Double)" />
      <seealso cref="M:devDept.Geometry.Utility.RadToDeg(System.Double)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipticalArc.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>GArc parallel to XY plane constructor.</summary>
      <param name="x">Center's X coordinate</param>
      <param name="y">Center's Y coordinate</param>
      <param name="z">Center's Z coordinate</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
      <param name="endParameter">Span parameter will be [0, endParameter]</param>
      <remarks>The parameter t on an gEllipse is not the angle of (X(t),Y(t)) with the X-axis, even if also t is in [0, 2*PI].</remarks>
      <seealso cref="M:devDept.Geometry.Utility.DegToRad(System.Double)" />
      <seealso cref="M:devDept.Geometry.Utility.RadToDeg(System.Double)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipticalArc.#ctor(devDept.Geometry.Point3D,System.Double,System.Double,System.Double,System.Double)">
      <summary>GArc parallel to XY plane constructor.</summary>
      <param name="center">3D center point</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
      <param name="startParameter">Start parameter</param>
      <param name="endParameter">End parameter</param>
      <remarks>The parameter t on an gEllipse is not the angle of (X(t),Y(t)) with the X-axis, even if also t is in [0, 2*PI].</remarks>
      <seealso cref="M:devDept.Geometry.Utility.DegToRad(System.Double)" />
      <seealso cref="M:devDept.Geometry.Utility.RadToDeg(System.Double)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipticalArc.#ctor(devDept.Geometry.Point3D,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>GArc parallel to XY plane constructor.</summary>
      <param name="center">3D center point</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
      <param name="startAngleInRadians">Start angle in radians</param>
      <param name="endAngleInRadians">End angle in radians</param>
      <param name="polarAngles">When True the two previous parameters represent angles from the X-axis, otherwise they represent parameters on the gEllipse.</param>
      <remarks>The parameter t on an gEllipse is not the angle of (X(t),Y(t)) with the X-axis, even if also t is in [0, 2*PI].</remarks>
      <seealso cref="M:devDept.Geometry.Utility.DegToRad(System.Double)" />
      <seealso cref="M:devDept.Geometry.Utility.RadToDeg(System.Double)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipticalArc.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>GArc parallel to XY plane constructor.</summary>
      <param name="x">Center's X coordinate</param>
      <param name="y">Center's Y coordinate</param>
      <param name="z">Center's Z coordinate</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
      <param name="startParameter">Start parameter</param>
      <param name="endParameter">End parameter</param>
      <remarks>The parameter t on an gEllipse is not the angle of (X(t),Y(t)) with the X-axis, even if also t is in [0, 2*PI].</remarks>
      <seealso cref="M:devDept.Geometry.Utility.DegToRad(System.Double)" />
      <seealso cref="M:devDept.Geometry.Utility.RadToDeg(System.Double)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipticalArc.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>GArc parallel to XY plane constructor.</summary>
      <param name="x">Center's X coordinate</param>
      <param name="y">Center's Y coordinate</param>
      <param name="z">Center's Z coordinate</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
      <param name="startAngleInRadians">Start angle in radians</param>
      <param name="endAngleInRadians">End angle in radians</param>
      <param name="polarAngles">When True the two previous parameters represent angles from the X-axis, otherwise they represent parameters on the gEllipse.</param>
      <remarks>The parameter t on an gEllipse is not the angle of (X(t),Y(t)) with the X-axis, even if also t is in [0, 2*PI].</remarks>
      <seealso cref="M:devDept.Geometry.Utility.DegToRad(System.Double)" />
      <seealso cref="M:devDept.Geometry.Utility.RadToDeg(System.Double)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipticalArc.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point3D,System.Double,System.Double,System.Double)">
      <summary>GArc not parallel to XY plane constructor.</summary>
      <param name="arcPlane">Plane</param>
      <param name="center">3D center point</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
      <param name="endParameter">Span parameter will be [0, endParameter]</param>
      <remarks>The parameter t on an gEllipse is not the angle of (X(t),Y(t)) with the X-axis, even if also t is in [0, 2*PI].</remarks>
      <seealso cref="M:devDept.Geometry.Utility.DegToRad(System.Double)" />
      <seealso cref="M:devDept.Geometry.Utility.RadToDeg(System.Double)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipticalArc.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point3D,System.Double,System.Double,System.Double,System.Double)">
      <summary>GArc not parallel to XY plane constructor with center.</summary>
      <param name="arcPlane">Plane</param>
      <param name="center">3D center point</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
      <param name="startParameter">Start parameter</param>
      <param name="endParameter">End parameter</param>
      <remarks>The parameter t on an gEllipse is not the angle of (X(t),Y(t)) with the X-axis, even if also t is in [0, 2*PI].</remarks>
      <seealso cref="M:devDept.Geometry.Utility.DegToRad(System.Double)" />
      <seealso cref="M:devDept.Geometry.Utility.RadToDeg(System.Double)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipticalArc.#ctor(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Double)">
      <summary>GArc not parallel to XY plane constructor.</summary>
      <param name="arcPlane">Plane</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
      <param name="startParameter">Start parameter</param>
      <param name="endParameter">End parameter</param>
      <remarks>The parameter t on an gEllipse is not the angle of (X(t),Y(t)) with the X-axis, even if also t is in [0, 2*PI].</remarks>
      <seealso cref="M:devDept.Geometry.Utility.DegToRad(System.Double)" />
      <seealso cref="M:devDept.Geometry.Utility.RadToDeg(System.Double)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipticalArc.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point3D,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>GArc not parallel to XY plane constructor.</summary>
      <param name="arcPlane">Plane</param>
      <param name="center">3D center point</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
      <param name="startAngleInRadians">Start angle in radians</param>
      <param name="endAngleInRadians">End angle in radians</param>
      <param name="polarAngles">When True the two previous parameters represent angles from the X-axis, otherwise they represent parameters on the gEllipse.</param>
      <remarks>The parameter t on an gEllipse is not the angle of (X(t),Y(t)) with the X-axis, even if also t is in [0, 2*PI].</remarks>
      <seealso cref="M:devDept.Geometry.Utility.DegToRad(System.Double)" />
      <seealso cref="M:devDept.Geometry.Utility.RadToDeg(System.Double)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipticalArc.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point2D,System.Double,System.Double,System.Double,System.Double)">
      <summary>Sketch plane constructor.</summary>
      <param name="arcPlane">Plane</param>
      <param name="center">2D center point</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
      <param name="startParameter">Start parameter</param>
      <param name="endParameter">End parameter</param>
      <remarks>The parameter t on an gEllipse is not the angle of (X(t),Y(t)) with the X-axis, even if also t is in [0, 2*PI].</remarks>
      <seealso cref="M:devDept.Geometry.Utility.DegToRad(System.Double)" />
      <seealso cref="M:devDept.Geometry.Utility.RadToDeg(System.Double)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipticalArc.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point2D,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>Sketch plane constructor.</summary>
      <param name="arcPlane">Plane</param>
      <param name="center">2D center point</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
      <param name="startAngleInRadians">Start angle in radians</param>
      <param name="endAngleInRadians">End angle in radians</param>
      <param name="polarAngles">When True the two previous parameters represent angles from the X-axis, otherwise they represent parameters on the gEllipse.</param>
      <remarks>The parameter t on an gEllipse is not the angle of (X(t),Y(t)) with the X-axis, even if also t is in [0, 2*PI].</remarks>
      <seealso cref="M:devDept.Geometry.Utility.DegToRad(System.Double)" />
      <seealso cref="M:devDept.Geometry.Utility.RadToDeg(System.Double)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipticalArc.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point3D,System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Boolean)">
      <summary>Plane, center, radius X, radius Y, start and end point constructor.</summary>
      <param name="arcPlane">Plane</param>
      <param name="center">3D center point</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
      <param name="start">3D start point</param>
      <param name="end">3D end point</param>
      <param name="flip">If true, the complementary arc is created.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipticalArc.Clone">
      <summary>
            Creates a deep copy of this elliptical arc.
            </summary>
      <returns>The new elliptical arc object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipticalArc.GetIntervalOfAngles(System.Double,System.Double,System.Double,System.Double,System.Double@,System.Double@)">
      <summary>
            Gets an interval of angles corresponding to and interval of parameters.
            </summary>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
      <param name="startParam">Start parameter</param>
      <param name="endParam">End parameter</param>
      <param name="startAngleInRadians">Start angle in radians</param>
      <param name="endAngleInRadians">End angle in radians</param>
      <returns>True if the interval of parameters is decreasing.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GEllipticalArc.Angle">
      <summary>
            Gets arc's angle.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GEllipticalArc.AngleInRadians">
      <summary>
            Gets arc's angle in radians.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GEllipticalArc.AngleInDegrees">
      <summary>
            Gets arc's angle in degrees.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GEllipticalArc.Domain">
      <summary>
            Gets or sets the elliptical arc's domain.
            The parameter t on an elliptical arc is not the angle of ellipticalArc.PointAt(t) with the X-axis, even if t is in [0, 2*PI].
            </summary>
      <exception cref="T:devDept.Eyeshot.EyeshotException">Thrown when trying to set a domain smaller than <see cref="F:devDept.Geometry.Utility.ZERO_TOLERANCE" />.</exception>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipticalArc.TrimBy(devDept.Geometry.Point3D,System.Boolean)">
      <summary>
            Trims the arc at the limit point projection.
            </summary>
      <param name="limit">The limit point</param>
      <param name="flipSide">The flip side flag</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipticalArc.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEllipticalArc.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.Entities.GEntity">
      <summary>
            Base class for all Eyeshot entities.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GEntity.EntityData">
      <summary>
            Gets or sets the entity custom data.
            </summary>
      <remarks>If the type implements ICloneable it will be cloned when the GEntity is cloned.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.#ctor">
      <summary>
            Color and nature constructor.
            </summary>
      <param name="color">A <see cref="!:Color" /> structure that indicates the color of this entity.</param>
      <param name="nature">The entity nature</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.IsValid(devDept.Geometry.Point3D[])">
      <summary>
            Returns true if all the entity fields contain reasonable information.
            </summary>
      <param name="vertices">
      </param>
      <returns>True if the entity is valid, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.GetCoarseSampling">
      <summary>
            Returns a small set of points that gives a coarse idea of the 3D extent of the primitive.
            </summary>
      <returns>An array of 3D points.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.ResetComputedData">
      <summary>
            Resets needed primitive's geometrical attributes to recompute.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.ComputeApproximatedBoundingBox(devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">
      <summary>
            Computes the primitive's approximated bounding box.
            </summary>
      <param name="min">The minimum 3D extent of the primitive.</param>
      <param name="max">The maximum 3D extent of the primitive.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.ConvertToSurrogate">
      <summary>
            Converts the GEntity to its surrogate, for serialization purpose.
            </summary>
      <returns>The surrogate.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.Clone">
      <summary>
            Creates a deep copy of this entity.
            </summary>
      <returns>The new entity object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.TransformBy(devDept.Geometry.Transformation)">
      <summary>
            Transforms all the entity's vertices by the specified transformation.
            </summary>
      <remarks>
            You need to call <see cref="!:EntityList.Regen" /> to see the effect of this command.
            </remarks>
      <param name="transform">The transformation to be applied</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.Translate(System.Double,System.Double,System.Double)">
      <summary>
            Translates the entity.
            </summary>
      <remarks>
            You need to call <see cref="!:EntityList.Regen" /> to see the effect of this command.
            </remarks>
      <param name="dx">Amount in X</param>
      <param name="dy">Amount in Y</param>
      <param name="dz">Amount in Z</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.Translate(devDept.Geometry.Vector3D)">
      <summary>
            Translates the entity.
            </summary>
      <remarks>
            You need to call <see cref="!:EntityList.Regen" /> to see the effect of this command.
            </remarks>
      <param name="v">Displacement vector</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.Rotate(System.Double,devDept.Geometry.Vector3D)">
      <summary>
            Rotates the entity around an arbitray axis by the specified angle.
            </summary>
      <remarks>
            You need to call <see cref="!:EntityList.Regen" /> to see the effect of this command.
            </remarks>
      <param name="angleInRadians">The angle in radians</param>
      <param name="axis">The rotation axis</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.Rotate(System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D)">
      <summary>
            Rotates the entity around an arbitrary axis by the specified angle.
            </summary>
      <remarks>
            You need to call <see cref="!:EntityList.Regen" /> to see the effect of this command.
            </remarks>
      <param name="angleInRadians">The angle in radians</param>
      <param name="axis">The rotation axis' direction</param>
      <param name="center">The rotation axis' origin</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.Rotate(System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Rotates the entity around an arbitray axis by the specified angle.
            </summary>
      <remarks>
            You need to call <see cref="!:EntityList.Regen" /> to see the effect of this command.
            </remarks>
      <param name="angleInRadians">The angle in radians</param>
      <param name="axisStart">The rotation axis' start point</param>
      <param name="axisEnd">The rotation axis' end point</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.Scale(System.Double)">
      <summary>
            Scales the entity of the specified scale factor.
            </summary>
      <remarks>
            You need to call <see cref="!:EntityList.Regen" /> to see the effect of this command.
            </remarks>
      <param name="factor">Scale factor</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.Scale(devDept.Geometry.Point3D,System.Double)">
      <summary>
            Scales the entity of the specified scale factor.
            </summary>
      <remarks>
            You need to call <see cref="!:EntityList.Regen" /> to see the effect of this command.
            </remarks>
      <param name="fixedPoint">Base point</param>
      <param name="factor">Scale factor</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.Scale(devDept.Geometry.Point3D,System.Double,System.Double,System.Double)">
      <summary>
            Scales the entity of the specified scale factor.
            </summary>
      <remarks>
            You need to call <see cref="!:EntityList.Regen" /> to see the effect of this command.
            </remarks>
      <param name="fixedPoint">Base point</param>
      <param name="sx">Scale factor along X-axis</param>
      <param name="sy">Scale factor along Y-axis</param>
      <param name="sz">Scale factor along Z-axis</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.Scale(System.Double,System.Double,System.Double)">
      <summary>
            Scales the entity of the specified scale factor.
            </summary>
      <remarks>
            You need to call <see cref="!:EntityList.Regen" /> to see the effect of this command.
            </remarks>
      <param name="sx">Scale factor along X-axis</param>
      <param name="sy">Scale factor along Y-axis</param>
      <param name="sz">Scale factor along Z-axis</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.Scale(devDept.Geometry.Vector3D)">
      <summary>
            Scales the entity of the specified scale factor.
            </summary>
      <remarks>
            You need to call <see cref="!:EntityList.Regen" /> to see the effect of this command.
            </remarks>
      <param name="sv">Scale vector</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.Dump">
      <summary>
            Returns a description of this entity.
            </summary>
      <param name="layers">The layers collection.</param>
      <param name="materials">The materials collection.</param>
      <param name="blocks">The blocks collection.</param>
      <returns>A multiline string.</returns>
      <remarks>All of the results about the mass properties are displayed using the units of measurement provided as input.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.GetXElement">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GEntity.AddVerticesToXElement(System.Xml.Linq.XElement,devDept.Geometry.Point3D[])">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="T:devDept.Geometry.Entities.HitTriangle">
      <summary>
            GTriangle hit by a ray definition.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.HitTriangle.IntersectionPoint">
      <summary>
            3D intersection point in the world coordinate system.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.HitTriangle.TriangleIndex">
      <summary>
            GTriangle index.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.HitTriangle.FaceIndex">
      <summary>
        <see cref="T:devDept.Geometry.Entities.GBrep.Face" />, <see cref="T:devDept.Geometry.Entities.GSolid.Portion" /> or <see cref="!:Element.Face" /> index.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.HitTriangle.ShellOrElementIndex">
      <summary>
            Shell or <see cref="!:Element" /> index.
            </summary>
    </member>
    <member name="T:devDept.Geometry.Entities.IEvaluable">
      <summary>
            Common properties of igCurve entities.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.IEvaluable.Evaluate(System.Double,System.Int32)">
      <summary>
            Computes the igCurve derivatives at parametric value u.
            </summary>
      <param name="u">The parametric value</param>
      <param name="d">The degree of the derivative</param>
      <returns>The derivatives array.</returns>
    </member>
    <member name="T:devDept.Geometry.Entities.IGCurve">
      <summary>
            Common properties of igCurve entities.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.IGCurve.Domain">
      <summary>
            Gets igCurve's domain.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.IGCurve.EndPoint">
      <summary>Gets igCurve's end point.</summary>
    </member>
    <member name="P:devDept.Geometry.Entities.IGCurve.StartPoint">
      <summary>Gets igCurve's start point.</summary>
    </member>
    <member name="P:devDept.Geometry.Entities.IGCurve.IsClosed">
      <summary>Returns true if the igCurve is closed.</summary>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.Length">
      <summary>Computes the igCurve's length.</summary>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.Reverse">
      <summary>
            Reverses the igCurve direction.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.IGCurve.IsPoint">
      <summary>
            Returns true if the igCurve is degenerated into a point.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.SubCurve(System.Double,System.Double,devDept.Geometry.Entities.IGCurve@)">
      <summary>
            Extracts a sub igCurve from current one.
            </summary>
      <param name="startParam">Start parameter</param>
      <param name="endParam">End parameter</param>
      <param name="sub">The sub igCurve</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.SubCurve(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Entities.IGCurve@)">
      <summary>
            Extracts a sub igCurve from current one.
            </summary>
      <param name="startPt">Start 3D point</param>
      <param name="endPt">End 3D point</param>
      <param name="sub">The sub igCurve</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.SplitAt(System.Double,devDept.Geometry.Entities.IGCurve@,devDept.Geometry.Entities.IGCurve@)">
      <summary>
            Splits the igCurve at the parameter provided.
            </summary>
      <param name="t">The parameter indicating the split position</param>
      <param name="lower">Lower igCurve segment</param>
      <param name="upper">Upper igCurve segment</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.SplitBy(devDept.Geometry.Point3D,devDept.Geometry.Entities.IGCurve@,devDept.Geometry.Entities.IGCurve@)">
      <summary>
            Splits the igCurve at the 3D point provided.
            </summary>
      <param name="pt">The 3D point indicating the split position</param>
      <param name="lower">Lower igCurve segment</param>
      <param name="upper">Upper igCurve segment</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.SplitBy(System.Collections.Generic.IList{devDept.Geometry.Point3D},devDept.Geometry.Entities.IGCurve[]@)">
      <summary>
            Splits the igCurve at the 3D point array provided.
            </summary>
      <param name="points">The 3D point array</param>
      <param name="segments">The resulting segments</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.TrimAt(System.Double,System.Boolean)">
      <summary>
            Trims the igCurve at the parameter t.
            </summary>
      <param name="flipSide">Reverse flag</param>
      <param name="t">The igCurve parameter</param>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.TrimBy(devDept.Geometry.Point3D,System.Boolean)">
      <summary>
            Trims the igCurve at the specified 3D point.
            </summary>
      <param name="flipSide">Reverse flag</param>
      <param name="pt">The limit point</param>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.GetParamFromLength(System.Double,System.Double@)">
      <summary>
             Given the length along the igCurve, finds the parameter value that corresponds to it.
             </summary>
      <param name="length">Length along the igCurve</param>
      <param name="t">Parameter value</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.GetParamFromLength(System.Double,System.Double,System.Double@)">
      <summary>
             Given the length along the igCurve, finds the parameter value that corresponds to it.
             </summary>
      <param name="length">Length along the igCurve</param>
      <param name="curveLength">Length of the whole igCurve</param>
      <param name="t">Parameter value</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.GetLengthFromParam(System.Double,System.Double@)">
      <summary>
             Given the parameter along the igCurve, finds the the length of the subcurve at that parameter.
             </summary>
      <param name="t">Parameter value</param>
      <param name="length">Length along the igCurve</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.IntersectWith(devDept.Geometry.Entities.IGCurve,System.Boolean)">
      <summary>
            Finds all 3D points where the igCurve intersects another given igCurve.
            </summary>
      <param name="C2">The other curve</param>
      <param name="computeParameters">When true intersection points array is filled with InterPoints. False, for a quick computation without curves' parameters data.</param>
      <seealso cref="!:GCurve.Intersection(IGCurve, IGCurve)">GCurve.Intersection(IGCurve, IGCurve) Method</seealso>
      <seealso cref="!:GCurve.Intersection(IGCurve, IGCurve, double)">GCurve.Intersection(IGCurve, IGCurve, double) Method</seealso>
      <seealso cref="!:GCurve.Intersection2D(IGCurve, IGCurve, Plane)">GCurve.Intersection2D Method</seealso>
      <seealso cref="!:GCompositeCurve.IntersectionLineLine(IGCurve, IGCurve, out Point3D)">GCompositeCurve.IntersectionLineLine Method</seealso>
      <seealso cref="!:GCompositeCurve.IntersectionCircleCircle(GCircle, GCircle, Plane, out Point3D, out Point3D)">GCompositeCurve.IntersectionCircleCircle Method</seealso>
      <seealso cref="!:GCompositeCurve.IntersectionCircleCircle3D(GCircle, GCircle, out Point3D, out Point3D)">GCompositeCurve.IntersectionCircleCircle3D Method</seealso>
      <seealso cref="!:GCompositeCurve.IntersectionLineCircle(GLine, GCircle, Plane, bool, out Point3D, out Point3D)">GCompositeCurve.IntersectionLineCircle Method</seealso>
      <seealso cref="!:GCompositeCurve.IntersectionLineCircle3D(GLine, GCircle, out Point3D, out Point3D)">GCompositeCurve.IntersectionLineCircle3D Method</seealso>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.ClosestPointTo(devDept.Geometry.Point3D,System.Double@)">
      <summary>
            Returns the parameter of the point on igCurve that is closest to given 3D point.
            </summary>
      <param name="point">The 3D test point</param>
      <param name="t">The igCurve parameter</param>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.Project(devDept.Geometry.Point3D,System.Double@)">
      <summary>
            Returns the parameter of the closest perpendicular projection of the given 3D point on the igCurve.
            If there aren't projections inside the igCurve, we look for projections on the extensions of the igCurve.
            If no projections are found, we return the parameter of the StartPoint and false.
            </summary>
      <param name="point">The 3D test point</param>
      <param name="t">The igCurve parameter</param>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.GetIndividualCurves">
      <summary>
            Returns an array of the individual igCurves that form the igCurve.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.IsPlanar(System.Double,devDept.Geometry.Plane@)">
      <summary>
            Checks if the igCurve is planar.
            </summary>
      <param name="tol">The tolerance</param>
      <param name="plane">The plane where the igCurve lays</param>
      <returns>True if the igCurve is planar within tolerance, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.IsInPlane(devDept.Geometry.Plane,System.Double)">
      <summary>
            Checks if the igCurve lays on the specified plane.
            </summary>
      <param name="plane">The plane to test</param>
      <param name="tol">The tolerance</param>
      <returns>True if the igCurve lays on the plane, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.IsLinear(System.Double,devDept.Geometry.Segment3D@)">
      <summary>
            Checks if the igCurve is linear.
            </summary>
      <param name="line">The gLine where the igCurve lays</param>
      <param name="tol">The tolerance</param>
      <returns>True if the igCurve lays on this plane, false otherwise.</returns>
      <remarks> For GLinearPath and GCompositeCurve entities type this method gives as output the longest Segment3D contained inside the curve.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.PointAt(System.Double)">
      <summary>
            Evaluates a point on the igCurve.
            </summary>
      <param name="t">Evaluation parameter</param>
      <returns>The point on igCurve.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.TangentAt(System.Double)">
      <summary>
            Evaluates the unit tangent vector at a parameter.
            </summary>
      <param name="t">The parameter</param>
      <returns>The unit tangent.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.NormalAt(System.Double)">
      <summary>
            Evaluates the unit normal vector at a parameter.
            </summary>
      <param name="t">The parameter</param>
      <returns>The unit normal.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.IGCurve.StartTangent">
      <summary>
            Gets the unit tangent vector at the beginning of the igCurve.
            </summary>
      <value>The unit tangent.</value>
    </member>
    <member name="P:devDept.Geometry.Entities.IGCurve.EndTangent">
      <summary>
            Gets the unit tangent vector at the end of the igCurve.
            </summary>
      <value>The unit tangent.</value>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.Offset(System.Double,devDept.Geometry.Vector3D,System.Double,System.Boolean)">
      <summary>
            Offsets the igCurve of the specified amount.
            </summary>
      <param name="amount">Signed offset amount</param>
      <param name="planeNormal">Normal of the plane where offset occurs (normalized)</param>
      <param name="tolerance">Tolerance used in Nurbs curve offset computation</param>
      <param name="sharp">If false, offset curves are connected with an arc.</param>
      <returns>The offset curve if the operation is successful, null/Nothing otherwise.</returns>
      <remarks>It doesn't work if the number of offset curves is different from the number of curves to be offsetted. For more complex cases use <see cref="M:devDept.Geometry.Entities.GLinearPath.QuickOffset(System.Double,devDept.Geometry.Plane)" /></remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.OffsetToRegion(System.Double,System.Double,System.Boolean)">
      <summary>
            Offsets the planar igCurve of the specified amount and builds a <see cref="T:devDept.Geometry.Entities.GRegion" /> entity from the two igCurves.
            </summary>
      <param name="amount">Signed offset amount</param>
      <param name="tolerance">Tolerance used in Nurbs igCurve offset computation</param>
      <param name="sharp">If false, offset igCurves are connected with an arc.</param>
      <returns>The <see cref="T:devDept.Geometry.Entities.GRegion" /> object if the operation is successful, null/Nothing otherwise.</returns>
      <remarks>It doesn't work if the number of offset igCurves is different from the number of igCurves to be offsetted. For more complex cases use <see cref="M:devDept.Geometry.Entities.GLinearPath.QuickOffset(System.Double,devDept.Geometry.Plane)" /></remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.GetPointsByLength(System.Double)">
      <summary>
            Subdivides the igCurve by the distance provided.
            </summary>
      <param name="length">The distance between points</param>
      <returns>An array of 3D points.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.GetPointsByLengthPerSegment(System.Double)">
      <summary>
            Subdivides the igCurve by the distance provided, for LinearPaths and CompositeCurves it does it segmentwise.
            </summary>
      <param name="length">The distance between points</param>
      <returns>An array of 3D points.</returns>
      <remarks>In LinearPaths and CompositeCurves, this method is applied to each segment.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.GetTightBBox(devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">
      <summary>
            Computes the curve's axis aligned bounding box.
            </summary>
      <param name="boxMin">Min 3D point</param>
      <param name="boxMax">Max 3D point</param>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.ExtrudeAsMesh(devDept.Geometry.Vector3D,System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Extrudes this igCurve along the specified direction.
            </summary>
      <param name="amount">Extrusion direction and length</param>
      <param name="tolerance">If some entities need to be regenerated, this is the regeneration tolerance (chordal error).</param>
      <returns>The resulting mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.ExtrudeAsMesh(System.Double,System.Double,System.Double,System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Extrudes this igCurve along the specified direction.
            </summary>
      <param name="dx">Extrusion amount along the X axis</param>
      <param name="dy">Extrusion amount along the Y axis</param>
      <param name="dz">Extrusion amount along the Z axis</param>
      <param name="tolerance">If some entities need to be regenerated, this is the regeneration tolerance (chordal error).</param>
      <returns>The resulting mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.ExtrudeAsMesh``1(devDept.Geometry.Vector3D,System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Extrudes this igCurve along the specified direction.
            </summary>
      <param name="amount">Extrusion direction and length</param>
      <param name="tolerance">If some entities need to be regenerated, this is the regeneration tolerance (chordal error).</param>
      <returns>The resulting mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.ExtrudeAsMesh``1(System.Double,System.Double,System.Double,System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Extrudes this igCurve along the specified direction.
            </summary>
      <param name="dx">Extrusion amount along the X axis</param>
      <param name="dy">Extrusion amount along the Y axis</param>
      <param name="dz">Extrusion amount along the Z axis</param>
      <param name="tolerance">If some entities need to be regenerated, this is the regeneration tolerance (chordal error).</param>
      <returns>The resulting mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.RevolveAsMesh(System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32,System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Revolves this igCurve around an arbitrary axis.
            </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axisStart">The axis start point</param>
      <param name="axisEnd">The axis end point</param>
      <param name="slices">Number of subdivisions</param>
      <param name="tolerance">If some entities need to be regenerated, this is the regeneration tolerance (chordal error).</param>
      <returns>The mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.RevolveAsMesh(System.Double,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Int32,System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Revolves this igCurve around an arbitrary axis.
            </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axis">Revolution axis</param>
      <param name="center">Revolution center</param>
      <param name="slices">Number of subdivisions</param>
      <param name="tolerance">If some entities need to be regenerated, this is the regeneration tolerance (chordal error).</param>
      <returns>The mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.RevolveAsMesh``1(System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32,System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Revolves this igCurve around an arbitrary axis.
            </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axisStart">The axis start point</param>
      <param name="axisEnd">The axis end point</param>
      <param name="slices">Number of subdivisions</param>
      <param name="tolerance">If some entities need to be regenerated, this is the regeneration tolerance (chordal error).</param>
      <returns>The mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.RevolveAsMesh``1(System.Double,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Int32,System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Revolves this igCurve around an arbitrary axis.
            </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axis">Revolution axis</param>
      <param name="center">Revolution center</param>
      <param name="slices">Number of subdivisions</param>
      <param name="tolerance">If some entities need to be regenerated, this is the regeneration tolerance (chordal error).</param>
      <returns>The mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.SweepAsMesh(devDept.Geometry.Entities.IGCurve,System.Double,devDept.Geometry.Entities.sweepMethodType,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Sweeps this igCurve along the provided trajectory.
            </summary>
      <param name="rail">Sweep trajectory</param>
      <param name="tol">GSurface trim tolerance</param>
      <param name="methodType">The sweep method, affects only GCurve <paramref name="rail" /> segments.</param>
      <returns>The resulting merged gSurface.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.SweepAsMesh``1(devDept.Geometry.Entities.IGCurve,System.Double,devDept.Geometry.Entities.sweepMethodType,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Sweeps this igCurve along the provided trajectory.
            </summary>
      <param name="rail">Sweep trajectory</param>
      <param name="tol">GSurface trim tolerance</param>
      <param name="methodType">The sweep method, affects only GCurve <paramref name="rail" /> segments.</param>
      <returns>The resulting merged gSurface.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.SweepAsMesh(devDept.Geometry.Entities.IGCurve,System.Double,System.Boolean,devDept.Geometry.Entities.sweepMethodType,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Sweeps this igCurve along the provided trajectory.
            </summary>
      <param name="rail">Sweep trajectory</param>
      <param name="tol">GSurface trim tolerance</param>
      <param name="merge">When true, it merges al the trimmed pieces when possible. It Keeps them as separated objects otherwise.</param>
      <param name="methodType">The sweep method, affects only GCurve <paramref name="rail" /> segments.</param>
      <returns>The list of resulting gSurfaces.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.SweepAsMesh``1(devDept.Geometry.Entities.IGCurve,System.Double,System.Boolean,devDept.Geometry.Entities.sweepMethodType,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Sweeps this igCurve along the provided trajectory.
            </summary>
      <param name="rail">Sweep trajectory</param>
      <param name="tol">GSurface trim tolerance</param>
      <param name="merge">When true, it merges al the trimmed pieces when possible. It Keeps them as separated objects otherwise.</param>
      <param name="methodType">The sweep method, affects only GCurve <paramref name="rail" /> segments.</param>
      <returns>The list of resulting gSurfaces.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.GetNurbsForm">
      <summary>
            Gets the Nurbs form of this igCurve.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:devDept.Geometry.Entities.IGCurve.EdgeIndex">
      <summary>
            Gets the associated <see cref="T:devDept.Geometry.Entities.GBrep" /> edge index.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.IGCurve.FromBooleanIntersection">
      <summary>
            For GBrep internal usage only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.ExtrudeAsSurface(devDept.Geometry.Entities.GLine)">
      <summary>
            Extrudes this igCurve along the specified direction.
            </summary>
      <param name="gLine">Extrusion direction and length as <see cref="T:devDept.Geometry.Entities.GLine" /></param>
      <returns>The list of resulting gSurfaces.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.ExtrudeAsSurface(System.Double,System.Double,System.Double)">
      <summary>
            Extrudes this igCurve along the specified direction.
            </summary>
      <param name="dx">Extrusion amount along the X axis</param>
      <param name="dy">Extrusion amount along the Y axis</param>
      <param name="dz">Extrusion amount along the Z axis</param>
      <returns>The list of resulting gSurfaces.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.ExtrudeAsSurface(devDept.Geometry.Vector3D)">
      <summary>
            Extrudes this igCurve along the specified direction.
            </summary>
      <param name="amount">Extrusion direction and lenght</param>
      <returns>The list of resulting gSurfaces.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.ExtrudeAsSurface(devDept.Geometry.Vector3D,System.Double,System.Double)">
      <summary>
            Extrudes this igCurve along the specified direction with a draft angle.
            </summary>
      <param name="amount">Extrusion direction and lenght</param>
      <param name="draftAngleInRadians">Signed draft angle in radians</param>
      <param name="tolerance">Required for non-perpendicular extrusion directions</param>
      <returns>The list of resulting gSurfaces.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.ExtrudeAsBrep(devDept.Geometry.Entities.GLine,System.Double)">
      <summary>
            Extrudes this igCurve along the specified direction.
            </summary>
      <param name="gLine">Extrusion direction and length as <see cref="T:devDept.Geometry.Entities.GLine" /></param>
      <param name="tolerance">The regeneration tolerance. 0 for default value</param>
      <returns>The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.ExtrudeAsBrep(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Extrudes this igCurve along the specified direction.
            </summary>
      <param name="dx">Extrusion amount along the X axis</param>
      <param name="dy">Extrusion amount along the Y axis</param>
      <param name="dz">Extrusion amount along the Z axis</param>
      <param name="tolerance">The regeneration tolerance. 0 for default value</param>
      <returns>The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.ExtrudeAsBrep(devDept.Geometry.Vector3D,System.Double,System.Double)">
      <summary>
            Extrudes this igCurve along the specified direction with a draft angle.
            </summary>
      <param name="amount">Extrusion direction and lenght</param>
      <param name="draftAngleInRadians">Signed draft angle in radians</param>
      <param name="tolerance">The regeneration tolerance. Required for non-perpendicular extrusion directions. 0 for default value</param>
      <returns>The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.RevolveAsSurface(System.Double,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D)">
      <summary>
            Revolves this igCurve around an arbitrary axis.
            </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axis">Revolution axis direction</param>
      <param name="center">Revolution axis origin</param>
      <returns>The list of resulting gSurfaces.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.RevolveAsSurface(System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Revolves this igCurve around the specified axis.
            </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axisStart">Revolution axis start point</param>
      <param name="axisEnd">Revolution axis end point</param>
      <returns>The list of resulting gSurfaces.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.RevolveAsSurface(System.Double,System.Double,devDept.Geometry.Entities.GLine)">
      <summary>
            Revolves this igCurve around the specified axis.
            </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axis">Revolution axis</param>
      <returns>The list of resulting gSurfaces.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.RevolveAsBrep(System.Double,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Double)">
      <summary>
            Revolves this igCurve around an arbitrary axis.
            </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axis">Revolution axis direction</param>
      <param name="center">Revolution axis origin</param>
      <param name="tolerance">The regeneration tolerance. 0 for default value</param>
      <returns>The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.RevolveAsBrep(System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Double)">
      <summary>
            Revolves this igCurve around the specified axis.
            </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axisStart">Revolution axis start point</param>
      <param name="axisEnd">Revolution axis end point</param>
      <param name="tolerance">The regeneration tolerance. 0 for default value</param>
      <returns>The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.RevolveAsBrep(System.Double,System.Double,devDept.Geometry.Entities.GLine,System.Double)">
      <summary>
            Revolves this igCurve around the specified axis.
            </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axis">Revolution axis</param>
      <param name="tolerance">The regeneration tolerance. 0 for default value</param>
      <returns>The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.SweepAsSurface(devDept.Geometry.Entities.IGCurve,System.Double,devDept.Geometry.Entities.sweepMethodType)">
      <summary>
            Sweeps this igCurve along the provided trajectory.
            </summary>
      <param name="rail">The rail igCurve</param>
      <param name="tol">GSurface trim tolerance</param>
      <param name="methodType">The sweep method, affects only GCurve <paramref name="rail" /> segments.</param>
      <returns>The array of resulting gSurfaces.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.SweepAsBrep(devDept.Geometry.Entities.IGCurve,System.Double,devDept.Geometry.Entities.sweepMethodType)">
      <summary>Creates a GBrep sweeping the contour on the rail.</summary>
      <param name="rail">Sweep trajectory</param>
      <param name="tolerance">The trim tolerance</param>
      <param name="methodType">The sweep method, affects only GCurve <paramref name="rail" /> segments.</param>
      <returns>The resulting merged GBrep if the operation succeeded, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.SweepAsBrep(devDept.Geometry.Entities.IGCurve,System.Double,System.Boolean,devDept.Geometry.Entities.sweepMethodType)">
      <summary>Creates a GBrep sweeping the contour on the rail.</summary>
      <param name="rail">Sweep trajectory</param>
      <param name="tolerance">The trim tolerance</param>
      <param name="merge">When true, it merges al the trimmed pieces when possible. It Keeps them as separated objects otherwise.</param>
      <param name="methodType">The sweep method, affects only GCurve <paramref name="rail" /> segments.</param>
      <returns>The resulting GBrep array if the operation succeeded, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.ExtrudeAsSolid(devDept.Geometry.Vector3D,System.Double)">
      <summary>
            Extrudes this igCurve along the specified direction.
            </summary>
      <param name="amount">Extrusion direction and length</param>
      <param name="tolerance">If some entities need to be regenerated, this is the regeneration tolerance (chordal error).</param>
      <returns>The resulting solid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.ExtrudeAsSolid(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Extrudes this igCurve along the specified direction.
            </summary>
      <param name="dx">Extrusion amount along the X axis</param>
      <param name="dy">Extrusion amount along the Y axis</param>
      <param name="dz">Extrusion amount along the Z axis</param>
      <param name="tolerance">If some entities need to be regenerated, this is the regeneration tolerance (chordal error).</param>
      <returns>The resulting solid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.RevolveAsSolid(System.Double,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Int32,System.Double)">
      <summary>
            Revolves this igCurve around an arbitrary axis.
            </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axis">Revolution axis direction</param>
      <param name="center">Revolution axis origin</param>
      <param name="slices">Number of slices generated. This value can be also found using <see cref="!:Utility.NumberOfSegments(double, double, double)" /></param>
      <param name="tolerance">If some entities need to be regenerated, this is the regeneration tolerance (chordal error).</param>
      <returns>The resulting solid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.RevolveAsSolid(System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32,System.Double)">
      <summary>
            Revolves this igCurve around an arbitrary axis.
            </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axisStart">The axis start point</param>
      <param name="axisEnd">The axis end point</param>
      <param name="slices">Number of slices generated. This value can be also found using <see cref="!:Utility.NumberOfSegments(double, double, double)" /></param>
      <param name="tolerance">If some entities need to be regenerated, this is the regeneration tolerance (chordal error).</param>
      <returns>The resulting solid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.SweepAsSolid(devDept.Geometry.Entities.IGCurve,System.Double,devDept.Geometry.Entities.sweepMethodType)">
      <summary>
            Sweeps this entity along the provided trajectory.
            </summary>
      <param name="rail">The rail igCurve</param>
      <param name="tol">The regeneration tolerance</param>
      <param name="sweepMethod">The sweep method, affects only <paramref name="rail" /> segments.</param>
      <returns>The resulting merged GSolid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.SweepAsSolid(devDept.Geometry.Entities.IGCurve,System.Double,System.Boolean,devDept.Geometry.Entities.sweepMethodType)">
      <summary>
            Sweeps this entity along the provided trajectory.
            </summary>
      <param name="rail">The rail igCurve</param>
      <param name="tol">The regeneration tolerance</param>
      <param name="merge">When true, it merges al the trimmed pieces when possible. It Keeps them as separated objects otherwise.</param>
      <param name="sweepMethod">The sweep method, affects only <paramref name="rail" /> segments.</param>
      <returns>The resulting GSolid array objects.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.ComputeTessellation(devDept.Geometry.IRegenParams,devDept.Geometry.Point3D[]@)">
      <summary>
            Computes the igCurve tessellation.
            </summary>
      <param name="data">The data for tessellation</param>
      <param name="vertices">The resulting tessellated vertices</param>
    </member>
    <member name="M:devDept.Geometry.Entities.IGCurve.ComputeTessellation(System.Double,devDept.Geometry.Point3D[]@)">
      <summary>
            Computes the surface tessellation.
            </summary>
      <param name="deviation">The maximum deviation</param>
      <param name="vertices">The resulting tessellated vertices</param>
    </member>
    <member name="T:devDept.Geometry.Entities.IGFace">
      <summary>
            Common properties of face entities.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.IGFace.FlipNormal">
      <summary>
            Flips face normals.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.IGFace.Section(devDept.Geometry.Plane,System.Double)">
      <summary>
             Computes the contours resulting from the intersection of the face and the given plane.
            </summary>
      <param name="pln">The plane</param>
      <param name="tol">The tolerance</param>
      <returns>An array of igCurves representing each section contour.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGFace.ConvertToMesh(System.Double,System.Double,devDept.Geometry.Entities.GMesh.natureType,System.Boolean)">
      <summary>
             Converts this object to a single mesh.
            </summary>
      <param name="deviation">The maximum deviation, zero for current tessellation.</param>
      <param name="angleInRadians">The maximum angular deflection, ignored when zero.</param>
      <param name="nature">The desired Mesh <see cref="T:devDept.Geometry.Entities.GMesh.natureType">nature</see></param>
      <param name="weld">If true, the resulting meshes are welded (no duplicated points).</param>
      <returns>The resulting mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.IGFace.ComputeTessellation(System.Double,devDept.Geometry.TessellationData@)">
      <summary>
            Computes the surface tessellation.
            </summary>
      <param name="deviation">The maximum deviation</param>
      <param name="tessData">The resulting tessellation data</param>
    </member>
    <member name="M:devDept.Geometry.Entities.IGFace.ComputeTessellation(devDept.Geometry.IRegenParams,devDept.Geometry.TessellationData@)">
      <summary>
            Computes the surface tessellation.
            </summary>
      <param name="data">The data for tessellation</param>
      <param name="tessData">The resulting tessellation data</param>
    </member>
    <member name="T:devDept.Geometry.Entities.IGraphicsReferenceData">
      <summary>
            Data to preserve graphics attributes. For internal use only. 
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.IGraphicsReferenceData.GfxData">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="T:devDept.Geometry.Entities.GLine">
      <summary>
            GLine entity.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GLine.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            GLine on XY plane constructor.
            </summary>
      <param name="x1">Start point's X coordinate</param>
      <param name="y1">Start point's Y coordinate</param>
      <param name="x2">End point's X coordinate</param>
      <param name="y2">End point's Y coordinate</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GLine.#ctor(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Double)">
      <summary>Sketch plane constructor.</summary>
      <param name="sketchPlane">The sketch plane</param>
      <param name="x1">Start point's X coordinate</param>
      <param name="y1">Start point's Y coordinate</param>
      <param name="x2">End point's X coordinate</param>
      <param name="y2">End point's Y coordinate</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GLine.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>Sketch plane constructor.</summary>
      <param name="sketchPlane">The sketch plane</param>
      <param name="startPoint">Start point</param>
      <param name="endPoint">End point</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GLine.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Individual coordinates constructor.
            </summary>
      <param name="x1">Start point's X coordinate</param>
      <param name="y1">Start point's Y coordinate</param>
      <param name="z1">Start point's Z coordinate</param>
      <param name="x2">End point's X coordinate</param>
      <param name="y2">End point's Y coordinate</param>
      <param name="z2">End point's Z coordinate</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GLine.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Two 3D points constructor.
            </summary>
      <param name="start">Start point</param>
      <param name="end">End point</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GLine.#ctor(devDept.Geometry.Segment2D)">
      <summary>
            2D segment constructor.
            </summary>
      <param name="seg">The 2D segment</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GLine.#ctor(devDept.Geometry.Segment3D)">
      <summary>
            3D segment constructor.
            </summary>
      <param name="seg">The 3D segment</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GLine.Clone">
      <summary>
            Creates a deep copy of this gline.
            </summary>
      <returns>The new gline object.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GLine.MidPoint">
      <summary>
            Gets the gline's middle point.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GLine.Length">
      <summary>
            Gets the gline length.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GLine.GetPointsByLength(System.Double)">
      <summary>
            Subdivides the igCurve by the distance provided.
            </summary>
      <param name="length">The distance</param>
      <returns>An array of 3D points.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GLine.PointAt(System.Double)">
      <summary>
            Evaluates a point on (infinite) gline.
            </summary>
      <param name="t">Evaluation parameter</param>
      <returns>(1 - t/Domain.Length) * start + t/Domain.Length * end</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GLine.Tangent">
      <summary>
            Evaluates the unit tangent vector, it is the same at all the points of the gline.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GLine.TrimBy(devDept.Geometry.Point3D,System.Boolean)">
      <summary>
            Trims the gline at the limit point projection.
            </summary>
      <param name="limit">The limit point</param>
      <param name="flipSide">The flip side flag</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GLine.Direction">
      <summary>
            Gets the gline direction as a 3D vector.
            </summary>
      <seealso cref="P:devDept.Geometry.Entities.GLine.Tangent" />
    </member>
    <member name="M:devDept.Geometry.Entities.GLine.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GLine.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GLine.InPlane(devDept.Geometry.Plane@,System.Double)">
      <summary>
            Gets a plane that contains the gline.
            </summary>
      <param name="plane">A plane that contains the gline.  The origin
            of the plane is at the start of the gline.  The distance
            from the end of the gline to the plane is &lt;= tolerance.
            If possible a plane parallel to the world xy, yz or zx
            plane is returned.</param>
      <param name="tolerance">The tolerance</param>
      <returns>true if a coordinate of the gline's direction vector is larger than tolerance</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GLine.AreCollinear(devDept.Geometry.Entities.GLine,devDept.Geometry.Entities.GLine)">
      <summary>
            Returns true if the two glines are collinear.
            </summary>
      <param name="l1">The first gline</param>
      <param name="l2">The second gline</param>
    </member>
    <member name="T:devDept.Geometry.Entities.cornerType">
      <summary>
            Quick offset corner type.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.cornerType.Miter">
      <summary>
            Angled corners
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.cornerType.Round">
      <summary>
            Rounded corners
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.cornerType.Flat">
      <summary>
            Flat corners
            </summary>
    </member>
    <member name="T:devDept.Geometry.Entities.GLinearPath">
      <summary>
            Linear path entity (piecewise linear igCurve).
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.#ctor(System.Int32)">
      <summary>
            Standard constructor.
            </summary>
      <param name="numVertices">Number of points</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.#ctor(System.Collections.Generic.ICollection{devDept.Geometry.Point3D})">
      <summary>
            3D point array constructor.
            </summary>
      <param name="points">The point array</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.#ctor(devDept.Geometry.Point3D[])">
      <summary>
            Point list constructor.
            </summary>
      <param name="points">The point list</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point2D[])">
      <summary>
            Sketch pln constructor.
            </summary>
      <param name="sketchPlane">The sketch plane</param>
      <param name="points">The 2D point array</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.#ctor(System.Double,System.Double)">
      <summary>
            2D rectangle on the origin constructor.
            </summary>
      <param name="width">Rectangle's width</param>
      <param name="height">Rectangle's height</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.#ctor(devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            2D rectangle min/max constructor.
            </summary>
      <param name="min">Rectangle's 2D min corner</param>
      <param name="max">Rectangle's 2D max corner</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            2D rectangle on the origin constructor.
            </summary>
      <param name="plane">Sketch plane</param>
      <param name="min">Rectangle's 2D min corner</param>
      <param name="max">Rectangle's 2D max corner</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            2D rectangle constructor.
            </summary>
      <param name="x">Lower-left corner position along X-axis</param>
      <param name="y">Lower-left corner position along y-axis</param>
      <param name="width">Rectangle's width</param>
      <param name="height">Rectangle's height</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.#ctor(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Sketch plane rectangle constructor.
            </summary>
      <param name="plane">Sketch plane</param>
      <param name="x">Lower-left corner position along X-axis</param>
      <param name="y">Lower-left corner position along y-axis</param>
      <param name="width">Rectangle's width</param>
      <param name="height">Rectangle's height</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.Clone">
      <summary>
            Creates a deep copy of this linear path.
            </summary>
      <returns>The new linear path object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.Length">
      <summary>
            Gets the linear path length.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.ConvertToLines">
      <summary>
            Returns the linear path individual <see cref="T:devDept.Geometry.Entities.GLine">gLines</see> array.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.GetPointsByLength(System.Double)">
      <summary>
            Subdivides the igCurve by the distance provided.
            </summary>
      <param name="length">The distance</param>
      <returns>An array of 3D points.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.GetPointsByLengthPerSegment(System.Double)">
      <summary>
            Subdivides each segment of the igCurve by the distance provided.
            </summary>
      <param name="length">The distance</param>
      <returns>An array of 3D points.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.MergeWith(devDept.Geometry.Entities.GLinearPath)">
      <summary>
            Merges this linear path with a consecutive linear path.
            </summary>
      <param name="other">The second Linear Path.</param>
      <returns>True if the linear paths were merged, false otherwise.</returns>
      <remarks>The EndPoint of the first linear path must be equal to the StartPoint of the second.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.PointAt(System.Double)">
      <summary>
            Evaluates a point on the linear path.
            </summary>
      <param name="t">Evaluation parameter</param>
      <returns>Returns the point at length t</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.Inflate(System.Double,System.Double)">
      <summary>
            Inflates this linear path of the desired amount.
            </summary>
      <param name="amount">The inflate amount</param>
      <param name="tol">The tessellation tolerance</param>
      <returns>The resulting array of closed contours.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.Inflate(System.Double,devDept.Geometry.Vector3D,System.Double)">
      <summary>
            Inflates this linear path of the desired amount.
            </summary>
      <param name="amount">The inflate amount</param>
      <param name="planeNormal">Normal of the plane where inflate occurs (normalized), it is useful for gLines.</param>
      <param name="tol">The tessellation tolerance</param>
      <returns>The resulting array of closed contours. Use planeNormal only for lines.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.Inflate(System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Inflates a LinearPath in 3D given an elliptical section.
            </summary>
      <param name="rX">X radius of the elliptical section</param>
      <param name="rY">Y radius of the elliptical section</param>
      <param name="angleLimit">Limit that controls the stretching of the section while it follows curves along the path. Under this tolerance no stretch is applied.</param>
      <param name="smoothingAngle">Smoothing angles using in the process  of mesh creation</param>
      <param name="fillCaps">True if ends of opened linear paths must be filled with triangles fan</param>
      <returns>A mesh representing the inflation of the LinearPath</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.Offset(System.Double)">
      <summary>
            Offsets the curve of the specified amount.
            </summary>
      <param name="amount">Signed offset amount</param>
      <returns>The offset igCurve if the operation is successful, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.QuickOffset(System.Double,devDept.Geometry.Plane)">
      <summary>
            Quick offset function for NC toolpaths.
            </summary>
      <param name="amount">Signed offset amount</param>
      <param name="pln">Toolpath pln</param>
      <returns>An array of igCurves.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.QuickOffset(System.Double,devDept.Geometry.Plane,devDept.Geometry.Entities.cornerType)">
      <summary>
            Quick offset function for NC toolpaths.
            </summary>
      <param name="amount">Signed offset amount</param>
      <param name="pln">Toolpath pln</param>
      <param name="ct">Corner type</param>
      <returns>An array of igCurves.</returns>
      <remarks>For open linear paths, different corner types are not supported.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.QuickOffset(System.Double,devDept.Geometry.Plane,devDept.Geometry.Entities.cornerType,System.Double,System.Double)">
      <summary>
            Quick offset function for NC toolpaths.
            </summary>
      <param name="amount">Signed offset amount</param>
      <param name="pln">Toolpath pln</param>
      <param name="ct">Corner type</param>
      <param name="tol">Tolerance, used only with Round corners.</param>
      <param name="miterLimit">The higher the miter limit setting, the sharper the corner can be while retaining its miter.</param>
      <returns>An array of igCurves.</returns>
      <remarks>For open linear paths, different corner types are not supported.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.Pocket(System.Double,devDept.Geometry.Plane)">
      <summary>
            Pocket function for NC toolpaths.
            </summary>
      <param name="amount">Offset amount (positive)</param>
      <param name="pln">Toolpath pln</param>
      <returns>An array of igCurves.</returns>
      <remarks>The linear path must be closed and must have counterclockwise orientation with respect to the Z axis of the plane.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.Pocket(System.Double,devDept.Geometry.Plane,devDept.Geometry.Entities.cornerType)">
      <summary>
            Pocket function for NC toolpaths.
            </summary>
      <param name="amount">Offset amount (positive)</param>
      <param name="pln">Toolpath pln</param>
      <param name="ct">Corner type</param>
      <returns>An array of igCurves.</returns>
      <remarks>The linear path must be closed and must have counterclockwise orientation with respect to the Z axis of the plane.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.Pocket(System.Double,devDept.Geometry.Plane,devDept.Geometry.Entities.cornerType,System.Double,System.Double)">
      <summary>
            Pocket function for NC toolpaths.
            </summary>
      <param name="amount">Offset amount (positive)</param>
      <param name="pln">Toolpath pln</param>
      <param name="ct">Corner type</param>
      <param name="tol">Tolerance, used only with Round corners.</param>
      <param name="miterLimit">The higher the miter limit setting, the sharper the corner can be while retaining its miter.</param>
      <returns>An array of igCurves.</returns>
      <remarks>The linear path must be closed and must have counterclockwise orientation with respect to the Z axis of the plane.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.SplitAtDiscontinuities">
      <summary>
            Splits the igCurve at derivative discontinuities (e.g. kinks), returns an array of the smooth segments that form the igCurve.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.CreateHelix(System.Double,System.Double,System.Double,System.Boolean,System.Double)">
      <summary>Creates a linear path in the form of an helix.
            </summary>
      <param name="radius">Radius of the helix</param>
      <param name="pitch">Height of each full turn of the helix</param>
      <param name="turns">Number of turns</param>
      <param name="reverseTwist">Reverse direction of the Helix</param>
      <param name="deviation">The maximum deviation</param>
      <returns>The helicoidal linear path</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.CreateHelix(System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>Creates a linear path in the form of an helix.</summary>
      <param name="radius">Radius of the helix</param>
      <param name="angle">Angle between the helix and an axial line on its cylinder</param>
      <param name="height">Total height of the helix</param>
      <param name="deviation">The maximum deviation</param>
      <param name="reverseTwist">Reverse the helix direction</param>
      <returns>The helicoidal linear path</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.ExtrudeAsBrep(devDept.Geometry.Interval,System.Double,System.Double,System.Boolean,System.Double)">
      <summary>
            Create a base flange by offsetting and Extruding the igCurve after fillet the corners.
            </summary>
      <param name="amount">The extrusion amount</param>
      <param name="bendRadius">The bend radius replacing the corners</param>
      <param name="thickness">The sheet metal thickness</param>
      <param name="reverse">When true, it thickens the linear path in the opposite direction</param>
      <param name="tolerance">The tolerance</param>
      <returns>A GBrep object representing the resulting sheet metal. Null/Nothing if an error occured.</returns>
      <remarks>The linear path must be planar.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.IsOrientedClockwise(devDept.Geometry.Plane)">
      <summary>
            Checks if the closed igCurve orientation is clockwise.
            </summary>
      <param name="plane">The igCurve plane, can be obtained using the <see cref="M:devDept.Geometry.Entities.GLinearPath.IsPlanar(System.Double,devDept.Geometry.Plane@)" /> method.</param>
      <returns>True if the igCurve is oriented clockwise, false otherwise.</returns>
      <remarks>If the igCurve is not planar, the points are projected on the plane.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GLinearPath.IsOrientedClockwise(devDept.Geometry.Transformation)">
      <summary>
            Checks if the closed igCurve orientation is clockwise.
            </summary>
      <param name="t">The transformation needed to project all points on the igCurve plane.</param>
      <returns>True if the igCurve is oriented clockwise, false otherwise.</returns>
    </member>
    <member name="T:devDept.Geometry.Entities.GPlanarEntity">
      <summary>
            Base class for all planar entities.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GPlanarEntity.#ctor">
      <summary>
            Empty constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GPlanarEntity.#ctor(devDept.Geometry.Plane)">
      <summary>
            Plane constructor.
            </summary>
      <param name="pln">The plane</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GPlanarEntity.#ctor(devDept.Geometry.Plane,System.Single)">
      <summary>
            Plane and symbol size constructor.
            </summary>
      <param name="pln">The plane</param>
      <param name="symbolSize">The plane symbol size</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GPlanarEntity.Update(devDept.Geometry.Entities.GPlanarEntity)">
      <summary>
            Updates the contents of this entity with the contents of another entity.
            </summary>
      <param name="another">The other entity.</param>
    </member>
    <member name="P:devDept.Geometry.Entities.GPlanarEntity.Plane">
      <summary>Gets or sets the planar entity supporting plane.</summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GPlanarEntity.ExtrudeAsMesh(System.Double,System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Extrudes this entity along plane's Z-axis.
            </summary>
      <param name="amount">Extrusion amount, direction is along plane's Z-axis.</param>
      <param name="tol">Some entities need to be regenerated, this is the regeneration tolerance (chordal error).</param>
      <param name="meshNature">Nature of the resulting mesh entity</param>
      <returns>The mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GPlanarEntity.ExtrudeAsMesh``1(System.Double,System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Extrudes this entity along plane's Z-axis.
            </summary>
      <param name="amount">Extrusion amount, direction is along plane's Z-axis.</param>
      <param name="tol">Some entities need to be regenerated, this is the regeneration tolerance (chordal error).</param>
      <param name="meshNature">Nature of the resulting mesh entity</param>
      <returns>The mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GPlanarEntity.ExtrudeAsSurface(System.Double)">
      <summary>
            Extrude this planar entity along plane's Z-axis.
            </summary>
      <param name="amount">Extrusion amount</param>
      <returns>The resulting surface.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GPlanarEntity.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GPlanarEntity.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.Entities.GPoint">
      <summary>
            GPoint entity.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GPoint.#ctor(System.Double,System.Double,System.Double)">
      <summary>
            Position constructor.
            </summary>
      <param name="x">GPoint's X coordinate</param>
      <param name="y">GPoint's Y coordinate</param>
      <param name="z">GPoint's Z coordinate</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GPoint.#ctor(System.Double,System.Double)">
      <summary>
            2D point constructor.
            </summary>
      <param name="x">GPoint's X coordinate</param>
      <param name="y">GPoint's Y coordinate</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GPoint.#ctor(devDept.Geometry.Point2D)">
      <summary>
            2D point constructor.
            </summary>
      <param name="p">GPoint position</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GPoint.#ctor(devDept.Geometry.Point3D)">
      <summary>
            3D point constructor.
            </summary>
      <param name="p">GPoint position</param>
      <param name="size">On screen size</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GPoint.#ctor(devDept.Geometry.Plane,System.Double,System.Double)">
      <summary>
            Sketch plane constructor.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="x">GPoint's X coordinate</param>
      <param name="y">GPoint's Y coordinate</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GPoint.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point2D)">
      <summary>
            Sketch plane constructor.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="p">GPoint's position</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GPoint.Clone">
      <summary>
            Creates a deep copy of this point.
            </summary>
      <returns>The new point object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GPoint.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GPoint.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.Entities.GPointCloud">
      <summary>
        <para>GPoint cloud entity. Depending on the types of vertices can assume
                different configurations, see table below:</para>
        <para>
          <list type="table">
            <item>
              <term>
                <see cref="T:devDept.Geometry.Point3D" />
              </term>
              <description>
                <see cref="T:devDept.Geometry.PointRGB" />
              </description>
            </item>
            <item>
              <term>Plain</term>
              <description>Multicolor</description>
            </item>
          </list>
        </para>
      </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GPointCloud.#ctor(System.Collections.Generic.IList{devDept.Geometry.Point3D})">
      <summary>Standard constructor.</summary>
      <param name="points">The collection of 3D points</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GPointCloud.#ctor(System.Int32,devDept.Geometry.Entities.GPointCloud.natureType)">
      <summary>Point list, point size and point cloud nature constructor.</summary>
      <param name="numPoints">Number of point the point cloud will hold</param>
      <param name="nature">The point cloud nature</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GPointCloud.Clone">
      <summary>
            Creates a deep copy of this point cloud.
            </summary>
      <returns>The new point cloud object.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GPointCloud.Vertices">
      <summary>
            Gets or sets point cloud's 3D vertices.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GPointCloud.Nature">
      <summary>
            Gets point cloud nature.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GPointCloud.ComputeNature">
      <summary>
            Computes the nature of the point cloud according to its vertices.
            </summary>
      <seealso cref="P:devDept.Geometry.Entities.GPointCloud.Nature" />
    </member>
    <member name="M:devDept.Geometry.Entities.GPointCloud.FitLine(devDept.Geometry.Point3D@,devDept.Geometry.Vector3D@)">
      <summary>
            Fits a line to the point cloud vertices.
            </summary>
      <param name="p">The line start point</param>
      <param name="v">The line direction</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GPointCloud.FitCircle(devDept.Geometry.Plane@,System.Double@)">
      <summary>
            Fits a circle to the point cloud vertices.
            </summary>
      <param name="pln">The plane of the circle, whose origin is the center of the circle</param>
      <param name="radius">The radius of the circle</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GPointCloud.FitPlane">
      <summary>
            Fits a plane to the point cloud vertices.
            </summary>
      <returns>The plane.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GPointCloud.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GPointCloud.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.Entities.GPointCloud.natureType">
      <summary>
            Point cloud nature type.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GPointCloud.natureType.Undefined">
      <summary>
            Not yet defined
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GPointCloud.natureType.Plain">
      <summary>
            Plain, all the points of the same color.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GPointCloud.natureType.Multicolor">
      <summary>
            Multicolor, one color for each point.
            </summary>
    </member>
    <member name="T:devDept.Geometry.Entities.GQuad">
      <summary>
            Quadrangular face entity.
            </summary>
      <remarks>Does not support material's texture.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GQuad.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Standard constructor
            </summary>
      <param name="v1x">First vertex's X-coordinate</param>
      <param name="v1y">First vertex's y-coordinate</param>
      <param name="v1z">First vertex's Z-coordinate</param>
      <param name="v2x">Second vertex's X-coordinate</param>
      <param name="v2y">Second vertex's y-coordinate</param>
      <param name="v2z">Second vertex's Z-coordinate</param>
      <param name="v3x">Third vertex's X-coordinate</param>
      <param name="v3y">Third vertex's y-coordinate</param>
      <param name="v3z">Third vertex's Z-coordinate</param>
      <param name="v4x">Fourth vertex's X-coordinate</param>
      <param name="v4y">Fourth vertex's y-coordinate</param>
      <param name="v4z">Fourth vertex's Z-coordinate</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GQuad.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Standard constructor.
            </summary>
      <param name="v1">First vertex</param>
      <param name="v2">Second vertex</param>
      <param name="v3">Third vertex</param>
      <param name="v4">Fourth vertex</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GQuad.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            Sketch plane constructor.
            </summary>
      <param name="plane">Sketch plane</param>
      <param name="v1">First 2D point</param>
      <param name="v2">Second 2D point</param>
      <param name="v3">Third 2D point</param>
      <param name="v4">Fourth 2D point</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GQuad.#ctor(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Sketch plane rectangle constructor.
            </summary>
      <param name="plane">Sketch plane</param>
      <param name="v1">First 2D point</param>
      <param name="v2">Second 2D point</param>
      <param name="v3">Third 2D point</param>
      <param name="v4">Fourth 2D point</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GQuad.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Rectangle constructor.
            </summary>
      <param name="v1">First 2D point</param>
      <param name="v2">Second 2D point</param>
      <param name="v3">Third 2D point</param>
      <param name="v4">Fourth 2D point</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GQuad.Clone">
      <summary>
            Creates a deep copy of this triangle.
            </summary>
      <returns>The new triangle object.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GQuad.Normal">
      <summary>
            Gets or sets the quad's normal.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GQuad.V1">
      <summary>
            Gets or sets the first vertex.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GQuad.V2">
      <summary>
            Gets or sets the second vertex.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GQuad.V3">
      <summary>
            Gets or sets the third vertex.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GQuad.V4">
      <summary>
            Gets or sets the fourth vertex.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GQuad.FindClosestTriangle(devDept.Geometry.Transformation,devDept.Geometry.Segment3D)">
      <summary>
            Returns a list of triangles hit by the provided segment.
            </summary>
      <param name="transf">The transformation applied to the entity (necessary if the entity is inside a Block to propagate the BlockReference transformation)</param>
      <param name="seg">The 3D segment representing the viewing direction</param>
      <returns>The sorted list of triangles intersecting the provided segment.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GQuad.GetPerimeter">
      <summary>
            Computes the perimeter of the GQuad entity.
            </summary>
      <returns>The perimeter amount.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GQuad.GetArea(devDept.Geometry.Point3D@)">
      <summary>
            Computes the area of the quad entity.
            </summary>
      <param name="centroid">The centroid.</param>
      <returns>The area amount.</returns>
    </member>
    <member name="T:devDept.Geometry.Entities.GRegion">
      <summary>
            GRegion entity definition. By convention the first contour in the list is the outer and has counterclockwise orientation. Inners are oriented clockwise.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GRegion.ContourList">
      <summary>
            Gets o sets the list of contours inside the region.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.#ctor(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Plane)">
      <summary>
            Single contour and plane constructor.
            </summary>
      <param name="outer">The outer contour</param>
      <param name="pln">The contour plane</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.#ctor">
      <summary>
            Empty Constructor. For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.#ctor(devDept.Geometry.Entities.IGCurve)">
      <summary>
            Single contour constructor.
            </summary>
      <param name="outer">The outer contour</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.#ctor(devDept.Geometry.Entities.GRegion)">
      <summary>
            Copy constructor.
            </summary>
      <param name="another">The other region</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.#ctor(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Plane,System.Boolean)">
      <summary>
            Single contour, plane and sorting flag constructor.
            </summary>
      <param name="outer">The outer contour</param>
      <param name="pln">The contour plane</param>
      <param name="sortAndOrient">When true, the contour is properly oriented.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.#ctor(devDept.Geometry.Entities.IGCurve[])">
      <summary>
            List of contours constructor.
            </summary>
      <param name="contours">The list of contours</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.#ctor(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve})">
      <summary>
            List of contours constructor.
            </summary>
      <param name="contours">The list of contours</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.#ctor(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},devDept.Geometry.Plane)">
      <summary>
            List of contours and plane constructor.
            </summary>
      <param name="contours">The list of planar contours</param>
      <param name="pln">The contours plane</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.#ctor(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},devDept.Geometry.Plane,System.Boolean)">
      <summary>
            List of contours, plane and sorting flag constructor.
            </summary>
      <param name="contours">The list of planar contours</param>
      <param name="pln">The contours plane</param>
      <param name="sortAndOrient">When true, the contours are properly sorted and oriented.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.SortAndOrient">
      <summary>
            Sorts and orients internal contours.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.EstimatePlane(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Double)">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.Offset(System.Double,System.Double)">
      <summary>
            Offsets the region of the specified amount.
            </summary>
      <param name="amount">Signed offset amount</param>
      <param name="tolerance">Tolereance</param>
      <returns>The offset igCurves of the region contours.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.Offset(System.Double,System.Double,System.Boolean)">
      <summary>
            Offsets the region of the specified amount.
            </summary>
      <param name="amount">Signed offset amount</param>
      <param name="tolerance">Tolerance</param>
      <param name="sharp">If false, offset igCurves are connected with an arc.</param>
      <returns>The offset igCurves of the region contours.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.Clone">
      <summary>
            Creates a deep copy of this region.
            </summary>
      <returns>The new region object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.ConvertToMesh(System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Converts this region to a <see cref="T:TriangleNet.Mesh" /> object.
            </summary>
      <param name="deviation">The maximum deviation, zero for current tessellation.</param>
      <param name="meshNature">The desired Mesh nature.</param>
      <returns>The resulting Mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.ConvertToMesh``1(System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Converts this region to a <see cref="T:devDept.Geometry.Entities.GMesh" /> object.
            </summary>
      <param name="deviation">The maximum deviation</param>
      <param name="meshNature">The desired GMesh nature.</param>
      <returns>The resulting GMesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.ConvertToSolid(System.Double)">
      <summary>
            Converts this region to a <see cref="T:devDept.Geometry.Entities.GSolid" /> object.
            </summary>
      <param name="tolerance">Tessellation tolerance</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.ConvertToSolid``1(System.Double)">
      <summary>
            Converts this region to a <see cref="T:devDept.Geometry.Entities.GSolid" /> object.
            </summary>
      <param name="tolerance">Tessellation tolerance</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.ConvertToSurface">
      <summary>
            Converts this region to a <see cref="T:devDept.Geometry.Entities.GSurface" /> object.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.SweepAsSurface(devDept.Geometry.Entities.IGCurve,System.Double,devDept.Geometry.Entities.sweepMethodType)">
      <summary>
            Creates a gSurface by sweeping the region along a rail.
            </summary>
      <param name="rail">The rail igCurve</param>
      <param name="tol">The trim tolerance</param>
      <param name="methodType">The Sweep method</param>
      <returns>The resulting gSurface array.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.SweepAsBrep(devDept.Geometry.Entities.IGCurve,System.Double,devDept.Geometry.Entities.sweepMethodType)">
      <summary>
            Creates a GBrep by sweeping the region along a rail.
            </summary>
      <param name="rail">The rail igCurve</param>
      <param name="tol">The trim tolerance</param>
      <param name="methodType">The Sweep method</param>
      <returns>The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.SweepAsBrep(devDept.Geometry.Entities.IGCurve,System.Double,System.Boolean,devDept.Geometry.Entities.sweepMethodType)">
      <summary>
            Creates a GBrep by sweeping the region along a rail.
            </summary>
      <param name="rail">The rail igCurve</param>
      <param name="tol">The trim tolerance</param>
      <param name="methodType">The Sweep method</param>
      <param name="merge">When true, it merges al the trimmed pieces. It Keeps them as separated objects otherwise.</param>
      <returns>The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.SweepAsMesh(devDept.Geometry.Entities.IGCurve,System.Double,devDept.Geometry.Entities.sweepMethodType,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Creates a mesh by sweeping the region along a rail.
            </summary>
      <param name="rail">The rail igCurve</param>
      <param name="tol">The trim tolerance</param>
      <param name="methodType">The Sweep method</param>
      <param name="natureType">The desired mesh nature</param>
      <returns>The resulting mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.SweepAsMesh``1(devDept.Geometry.Entities.IGCurve,System.Double,devDept.Geometry.Entities.sweepMethodType,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Creates a mesh by sweeping the region along a rail.
            </summary>
      <param name="rail">The rail curve</param>
      <param name="tol">The trim tolerance</param>
      <param name="methodType">The Sweep method</param>
      <param name="natureType">The desired mesh nature</param>
      <returns>The resulting mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.SweepAsMesh(devDept.Geometry.Entities.IGCurve,System.Double,System.Boolean,devDept.Geometry.Entities.sweepMethodType,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Creates a mesh by sweeping the region along a rail.
            </summary>
      <param name="rail">The rail curve</param>
      <param name="tol">The trim tolerance</param>
      <param name="merge">When true, it merges al the trimmed pieces. It Keeps them as separated objects otherwise.</param>
      <param name="methodType">The Sweep method</param>
      <param name="natureType">The desired mesh nature</param>
      <returns>The resulting mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.SweepAsMesh``1(devDept.Geometry.Entities.IGCurve,System.Double,System.Boolean,devDept.Geometry.Entities.sweepMethodType,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Creates a mesh by sweeping the region along a rail.
            </summary>
      <param name="rail">The rail curve</param>
      <param name="tol">The trim tolerance</param>
      <param name="merge">When true, it merges al the trimmed pieces. It Keeps them as separated objects otherwise.</param>
      <param name="methodType">The Sweep method</param>
      <param name="natureType">The desired mesh nature</param>
      <returns>The resulting mesh object.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GRegion.HasHoles">
      <summary>
            Returns true when the number of contours is bigger than one.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.Triangulate(System.Double,System.Int32)">
      <summary>
            Triangulates this GRegion.
            </summary>
      <param name="elementSize">The desired element size</param>
      <param name="smoothingPasses">The number of smoothing passes</param>
      <returns>The resulting Mesh object, null/Nothing in case of failure.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.IsPointOnContour(devDept.Geometry.Point3D,System.Double)">
      <summary>
            Tests if a 3D point is on one of the region's contours.
            </summary>
      <param name="testPoint">The test 3D point</param>
      <param name="tol">Maximum distance under which the point is considered on a contour.</param>
      <returns>True if the 3D point is on a contour, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.IsPointInside(devDept.Geometry.Point2D)">
      <summary>
            Tests if a 2D point is inside the region.
            </summary>
      <param name="testPoint">The test 2D point, given in the plane's coordinate system</param>
      <returns>True if the 2D point is inside, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.IsPointInside(devDept.Geometry.Point3D)">
      <summary>
            Tests if a 3D point is inside the region.
            </summary>
      <param name="testPoint">The test 3D point</param>
      <returns>True if the 3D point is inside, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.QuickOffset(System.Double,System.Double)">
      <summary>
            Quick offset function for NC toolpaths.
            </summary>
      <param name="amount">Signed offset amount</param>
      <param name="tol">Regeneration tolerance</param>
      <returns>An array of curves, offset of the region contour list.</returns>
      <remarks>Despite the type of the ICurves creating the contours of the region, it will return only Arc and Lines, occasionally organized into CompositeCurves. Sharp corners are not preserved.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.QuickOffset(System.Double,devDept.Geometry.Entities.cornerType,System.Double)">
      <summary>
            Quick offset function for NC toolpaths.
            </summary>
      <param name="amount">Signed offset amount</param>
      <param name="ct">Corner type</param>
      <param name="tol">Regeneration tolerance</param>
      <returns>An array of curves.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.QuickOffset(System.Double,devDept.Geometry.Entities.cornerType,System.Double,System.Double)">
      <summary>
            Quick offset function for NC toolpaths.
            </summary>
      <param name="amount">Signed offset amount</param>
      <param name="ct">Corner type</param>
      <param name="miterLimit">The higher the miter limit setting, the sharper the corner can be while retaining its miter.</param>
      <param name="tol">Regeneration tolerance</param>
      <returns>An array of curves.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.QuickOffsetInternal(System.Double,System.Double,devDept.Geometry.IntegerGrid@)">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.Pocket(System.Double,System.Double)">
      <summary>
            Pocket function for NC toolpaths.
            </summary>
      <param name="amount">Signed offset amount</param>
      <param name="tol">Regeneration tolerance</param>
      <returns>An array of curves, pocket of the region.</returns>
      <remarks>Despite the type of the ICurves creating the contours of the region, it will return only Arc and Lines for every path, occasionally organized into CompositeCurves. Sharp corners are not preserved.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.Pocket(System.Double,devDept.Geometry.Entities.cornerType,System.Double)">
      <summary>
            Pocket function for NC toolpaths.
            </summary>
      <param name="amount">Signed offset amount</param>
      <param name="ct">Corner type</param>
      <param name="tol">Regeneration tolerance</param>
      <returns>An array of curves.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.Pocket(System.Double,devDept.Geometry.Entities.cornerType,System.Double,System.Double)">
      <summary>
            Pocket function for NC toolpaths.
            </summary>
      <param name="amount">Signed offset amount</param>
      <param name="ct">Corner type</param>
      <param name="miterLimit">The higher the miter limit setting, the sharper the corner can be while retaining its miter.</param>
      <param name="tol">Regeneration tolerance</param>
      <returns>An array of curves.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.Union``1(``0,``0)">
      <summary>Boolean union between two regions.</summary>
      <param name="a">First operand</param>
      <param name="b">Second operand</param>
      <returns>An array of regions if the operation is successful, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.Difference``1(``0,``0)">
      <summary>Boolean difference between two regions.</summary>
      <param name="a">First operand</param>
      <param name="b">Second operand</param>
      <returns>An array of regions if the operation is successful, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.Difference``1(``0,``0[])">
      <summary>Boolean difference between one region and a list of regions.</summary>
      <param name="a">First operand</param>
      <param name="b">An array of second operands</param>
      <returns>The resulting region if the operation is successful, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.Intersection``1(``0,``0)">
      <summary>Boolean intersection between two regions.</summary>
      <param name="a">First operand</param>
      <param name="b">Second operand</param>
      <returns>An array of regions if the operation is successful, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.GetPerimeter">
      <summary>
            Computes the perimeter of the region.
            </summary>
      <returns>The perimeter amount.</returns>
      <remarks>The perimeter amount includes also the inner loops length.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.Trim(devDept.Geometry.Entities.GRegion,System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},devDept.Geometry.Entities.GRegion[]@)">
      <summary>
            Trims the region using the given - open - igCurves.
            </summary>
      <param name="original">The region to be trim</param>
      <param name="curves">The igCurves intersecting the region profiles</param>
      <param name="result">The resulting list of regions</param>
      <returns>True if the operation was successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.Trim(devDept.Geometry.Entities.GRegion,System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Double,devDept.Geometry.Entities.GRegion[]@)">
      <summary>
            Trims the region using the given - open - curves.
            </summary>
      <param name="original">The region to be trim</param>
      <param name="curves">The curves intersecting the region profiles</param>
      <param name="tolerance">The tolerance used if regeneration is needed</param>
      <param name="result">The resulting list of regions</param>
      <returns>True if the operation was successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.ExtrudeAsMesh(System.Double,System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Extrudes a region creating a new <see cref="T:devDept.Geometry.Entities.GMesh" /> along plane's Z-axis.
            </summary>
      <param name="amount">Extrusion amount</param>
      <param name="tolerance">The regeneration tolerance</param>
      <param name="meshNature">Entity region needs to be converted to <see cref="T:devDept.Geometry.Entities.GMesh" />, this is the <see cref="T:devDept.Geometry.Entities.GMesh.natureType" /> of the new <see cref="T:devDept.Geometry.Entities.GMesh" /> object</param>
      <returns>The resulting Mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.ExtrudeAsMesh``1(System.Double,System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Extrudes a region creating a new <see cref="T:devDept.Geometry.Entities.GMesh" /> along plane's Z-axis.
            </summary>
      <param name="amount">Extrusion amount</param>
      <param name="tolerance">The regeneration tolerance</param>
      <param name="meshNature">Entity region needs to be converted to <see cref="T:devDept.Geometry.Entities.GMesh" />, this is the <see cref="T:devDept.Geometry.Entities.GMesh.natureType" /> of the new <see cref="T:devDept.Geometry.Entities.GMesh" /> object</param>
      <returns>The resulting Mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.ExtrudeAsMesh(devDept.Geometry.Vector3D,System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
             Extrudes a region creating a new <see cref="T:devDept.Geometry.Entities.GMesh" />.
            </summary>
      <param name="amount">Extrusion amount</param>
      <param name="tolerance">The regeneration tolerance</param>
      <param name="meshNature">Entity region needs to be converted to <see cref="T:devDept.Geometry.Entities.GMesh" />, this is the <see cref="T:devDept.Geometry.Entities.GMesh.natureType" /> of the new <see cref="T:devDept.Geometry.Entities.GMesh" /> object</param>
      <returns>The resulting Mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.ExtrudeAsMesh``1(devDept.Geometry.Vector3D,System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
             Extrudes a region creating a new <see cref="T:devDept.Geometry.Entities.GMesh" />.
            </summary>
      <param name="amount">Extrusion amount</param>
      <param name="tolerance">The regeneration tolerance</param>
      <param name="meshNature">Entity region needs to be converted to <see cref="T:devDept.Geometry.Entities.GMesh" />, this is the <see cref="T:devDept.Geometry.Entities.GMesh.natureType" /> of the new <see cref="T:devDept.Geometry.Entities.GMesh" /> object</param>
      <returns>The resulting Mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.ExtrudeAsSurface(devDept.Geometry.Vector3D)">
      <summary>
            Extrudes a region creating a new <see cref="T:devDept.Geometry.Entities.GSurface" />.
            </summary>
      <param name="amount">Extrusion amount</param>
      <returns>&gt;The resulting GSurface array.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.ExtrudeAsSurface(System.Double)">
      <summary>
            Extrudes a region creating a new <see cref="T:devDept.Geometry.Entities.GSurface" />.
            </summary>
      <param name="amount">Extrusion amount</param>
      <returns>&gt;The resulting GSurface array.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.ExtrudeAsBrep(System.Double,System.Double,System.Double)">
      <summary>
            Extrudes a region creating a new <see cref="T:devDept.Geometry.Entities.GBrep" />.
            </summary>
      <param name="amount">The extrusion amount</param>
      <param name="angleInRadians">The draft angle in radians</param>
      <param name="tolerance">The regeneration tolerance. 0 for default value</param>
      <returns>&gt;The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.ExtrudeAsBrep(devDept.Geometry.Interval,System.Double,System.Double)">
      <summary>
            Extrudes the region to create a new GBrep.
            </summary>
      <param name="amount">The extrusion amount</param>
      <param name="angleInRadians">The draft angle in radians</param>
      <param name="tolerance">The regeneration tolerance. 0 for default value</param>
      <returns>&gt;The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.ExtrudeAsBrep(devDept.Geometry.Vector3D,System.Double,System.Double)">
      <summary>
            Extrudes the region to create a new GBrep.
            </summary>
      <param name="amount">The extrusion amount</param>
      <param name="angleInRadians">The draft angle in radians</param>
      <param name="tolerance">The regeneration tolerance. 0 for default value</param>
      <returns>&gt;The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.ExtrudeAsSolid(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Extrudes this region.
            </summary>
      <param name="x">Extrusion amount along the axis X</param>
      <param name="y">Extrusion amount along the axis Y</param>
      <param name="z">Extrusion amount along the axis Z</param>
      <param name="tolerance">The regeneration tolerance</param>
      <returns>The resulting GSolid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.ExtrudeAsSolid``1(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Extrudes this region.
            </summary>
      <param name="x">Extrusion amount along the axis X</param>
      <param name="y">Extrusion amount along the axis Y</param>
      <param name="z">Extrusion amount along the axis Z</param>
      <param name="tolerance">The regeneration tolerance</param>
      <returns>The resulting GSolid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.ExtrudeAsSolid(System.Double,System.Double)">
      <summary>
            Extrudes this region.
            </summary>
      <param name="amount">Extrusion amount</param>
      <param name="tolerance">The regeneration tolerance</param>
      <returns>The resulting GSolid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.ExtrudeAsSolid``1(System.Double,System.Double)">
      <summary>
            Extrudes this region.
            </summary>
      <param name="amount">Extrusion amount</param>
      <param name="tolerance">The regeneration tolerance</param>
      <returns>The resulting GSolid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.ExtrudeAsSolid(devDept.Geometry.Vector3D,System.Double)">
      <summary>
            Extrudes this region.
            </summary>
      <param name="amount">Extrusion amount</param>
      <param name="tolerance">The regeneration tolerance</param>
      <returns>The resulting GSolid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.ExtrudeAsSolid``1(devDept.Geometry.Vector3D,System.Double)">
      <summary>
            Extrudes this region.
            </summary>
      <param name="amount">Extrusion amount</param>
      <param name="tolerance">The regeneration tolerance</param>
      <returns>The resulting GSolid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.SweepAsSolid(devDept.Geometry.Entities.IGCurve,System.Double,devDept.Geometry.Entities.sweepMethodType)">
      <summary>
            Sweeps this region along the provided trajectory.
            </summary>
      <param name="rail">The rail igCurve</param>
      <param name="tolerance">The regeneration tolerance</param>
      <returns>The resulting GSolid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.SweepAsSolid``1(devDept.Geometry.Entities.IGCurve,System.Double,devDept.Geometry.Entities.sweepMethodType)">
      <summary>
            Sweeps this region along the provided trajectory.
            </summary>
      <param name="rail">The rail igCurve</param>
      <param name="tolerance">The regeneration tolerance</param>
      <returns>The resulting GSolid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.SweepAsSolid(devDept.Geometry.Entities.IGCurve,System.Double,System.Boolean,devDept.Geometry.Entities.sweepMethodType)">
      <summary>
            Sweeps this region along the provided trajectory.
            </summary>
      <param name="rail">The rail igCurve</param>
      <param name="tolerance">The regeneration tolerance</param>
      <param name="merge">
      </param>
      <param name="sweepMethod">
      </param>
      <returns>The resulting GSolid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.SweepAsSolid``1(devDept.Geometry.Entities.IGCurve,System.Double,System.Boolean,devDept.Geometry.Entities.sweepMethodType)">
      <summary>
            Sweeps this region along the provided trajectory.
            </summary>
      <param name="rail">The rail igCurve</param>
      <param name="tolerance">The regeneration tolerance</param>
      <param name="merge">
      </param>
      <param name="sweepMethod">
      </param>
      <returns>The resulting GSolid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.RevolveAsMesh(System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32,System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Revolves this region around an axis.
            </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axisStart">The axis start point</param>
      <param name="axisEnd">The axis end point</param>
      <param name="slices">Number of slices generated. This value can be also found using <see cref="M:devDept.Geometry.Utility.NumberOfSegments(System.Double,System.Double,System.Double,System.Double)" /></param>
      <param name="tolerance">The regeneration tolerance</param>
      <param name="meshNature">Entity region needs to be converted to <see cref="T:devDept.Geometry.Entities.GMesh" />, this is the <see cref="T:devDept.Geometry.Entities.GMesh.natureType" /> of the new <see cref="T:devDept.Geometry.Entities.GMesh" /> object</param>
      <returns>The resulting GMesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.RevolveAsMesh``1(System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32,System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
             Revolves this region around an axis.
             </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axisStart">The axis start point</param>
      <param name="axisEnd">The axis end point</param>
      <param name="slices">Number of slices generated. This value can be also found using <see cref="M:devDept.Geometry.Utility.NumberOfSegments(System.Double,System.Double,System.Double,System.Double)" /></param>
      <param name="tolerance">The regeneration tolerance</param>
      <param name="meshNature">Entity region needs to be converted to <see cref="T:devDept.Geometry.Entities.GMesh" />, this is the <see cref="T:devDept.Geometry.Entities.GMesh.natureType" /> of the new <see cref="T:devDept.Geometry.Entities.GMesh" /> object</param>
      <returns>The resulting GMesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.RevolveAsMesh(System.Double,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Int32,System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
             Revolves this region around an axis.
             </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axis">Axis direction</param>
      <param name="center">Axis start point</param>
      <param name="slices">Number of slices generated. This value can be also found using <see cref="M:devDept.Geometry.Utility.NumberOfSegments(System.Double,System.Double,System.Double,System.Double)" /></param>
      <param name="tolerance">The regeneration tolerance</param>
      <param name="meshNature">Entity region needs to be converted to <see cref="T:devDept.Geometry.Entities.GMesh" />, this is the <see cref="T:devDept.Geometry.Entities.GMesh.natureType" /> of the new <see cref="T:devDept.Geometry.Entities.GMesh" /> object</param>
      <returns>The resulting GMesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.RevolveAsMesh``1(System.Double,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Int32,System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
             Revolves this region around an axis.
             </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axis">Axis direction</param>
      <param name="center">Axis start point</param>
      <param name="slices">Number of slices generated. This value can be also found using <see cref="M:devDept.Geometry.Utility.NumberOfSegments(System.Double,System.Double,System.Double,System.Double)" /></param>
      <param name="tolerance">The regeneration tolerance</param>
      <param name="meshNature">Entity region needs to be converted to <see cref="T:devDept.Geometry.Entities.GMesh" />, this is the <see cref="T:devDept.Geometry.Entities.GMesh.natureType" /> of the new <see cref="T:devDept.Geometry.Entities.GMesh" /> object</param>
      <returns>The resulting GMesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.RevolveAsSurface(System.Double,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D)">
      <summary>
            Revolves this region around an axis.
            </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axis">Axis direction</param>
      <param name="center">Axis start point</param>
      <returns>The resulting GSurface array object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.RevolveAsSurface(System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Revolves this region around an axis.
            </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axisStart">The axis start point</param>
      <param name="axisEnd">The axis end point</param>
      <returns>The resulting GSurface array object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.RevolveAsBrep(System.Double,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Double)">
      <summary>
            Revolves this region around an axis.
            </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axis">Axis direction</param>
      <param name="center">Axis start point</param>
      <param name="tolerance">the regeneration tolerance</param>
      <returns>The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.RevolveAsBrep(System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Double)">
      <summary>
            Revolves this region around an axis.
            </summary>
      <param name="deltaAngle">Revolution angle in radians</param>
      <param name="axis">Axis direction</param>
      <param name="center">Axis start point</param>
      <param name="tolerance">the regeneration tolerance. 0 for default value</param>
      <returns>The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.RevolveAsBrep(System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Double)">
      <summary>
            Revolves this region around an axis.
            </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axisStart">The axis start point</param>
      <param name="axisEnd">The axis end point</param>
      <param name="tolerance">the regeneration tolerance</param>
      <returns>The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.RevolveAsSolid(System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32,System.Double)">
      <summary>
             Revolves this region around an axis.
             </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axisStart">The axis start point</param>
      <param name="axisEnd">The axis end point</param>
      <param name="slices">Number of slices generated. This value can be also found using <see cref="!:Utility.NumberOfSegments(double, double, double)" /></param>
      <param name="tolerance">The regeneration tolerance</param>
      <returns>The resulting GSolid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.RevolveAsSolid``1(System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32,System.Double)">
      <summary>
             Revolves this region around an axis.
             </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axisStart">The axis start point</param>
      <param name="axisEnd">The axis end point</param>
      <param name="slices">Number of slices generated. This value can be also found using <see cref="!:Utility.NumberOfSegments(double, double, double)" /></param>
      <param name="tolerance">The regeneration tolerance</param>
      <returns>The resulting GSolid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.RevolveAsSolid(System.Double,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Int32,System.Double)">
      <summary>
             Revolves this region around an axis.
             </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axis">Axis direction</param>
      <param name="center">Axis start point</param>
      <param name="slices">Number of slices generated. This value can be also found using <see cref="!:Utility.NumberOfSegments(double, double, double)" /></param>
      <param name="tolerance">The regeneration tolerance</param>
      <returns>The resulting GSolid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.RevolveAsSolid``1(System.Double,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Int32,System.Double)">
      <summary>
             Revolves this region around an axis.
             </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axis">Axis direction</param>
      <param name="center">Axis start point</param>
      <param name="slices">Number of slices generated. This value can be also found using <see cref="!:Utility.NumberOfSegments(double, double, double)" /></param>
      <param name="tolerance">The regeneration tolerance</param>
      <returns>The resulting GSolid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateRectangle(System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a rectangular region.
            </summary>
      <param name="width">Width</param>
      <param name="height">Height</param>
      <param name="centered">When true, the rectangle is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateRectangle(devDept.Geometry.Plane,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a rectangular region by plane.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="width">Width</param>
      <param name="height">Height</param>
      <param name="centered">When true, the rectangle is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateRectangle(System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a rectangular region by position.
            </summary>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="width">Width</param>
      <param name="height">Height</param>
      <param name="angle">Rotation angle in radians</param>
      <param name="centered">When true, the rectangle is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateRectangle(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a rectangular region by plane and position.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="width">Width</param>
      <param name="height">Height</param>
      <param name="angle">Rotation angle in radians</param>
      <param name="centered">When true, the rectangle is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateRoundedRectangle(System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a rounded rectangular region.
            </summary>
      <param name="width">Width</param>
      <param name="height">Height</param>
      <param name="radius">Corner radius</param>
      <param name="centered">When true, the rectangle is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateRoundedRectangle(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a rounded rectangular region by plane.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="width">Width</param>
      <param name="height">Height</param>
      <param name="radius">Corner radius</param>
      <param name="centered">When true, the rectangle is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateRoundedRectangle(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a rounded rectangular region by position.
            </summary>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="width">Width</param>
      <param name="height">Height</param>
      <param name="radius">Corner radius</param>
      <param name="angle">Rotation angle in radians</param>
      <param name="centered">When true, the rectangle is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateRoundedRectangle(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a rounded rectangular region by plane and position.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="width">Width</param>
      <param name="height">Height</param>
      <param name="radius">Corner radius</param>
      <param name="angle">Rotation angle in radians</param>
      <param name="centered">When true, the rectangle is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateCircle(System.Double)">
      <summary>
            Creates a circular region.
            </summary>
      <param name="radius">Radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateCircle(System.Double,System.Double,System.Double)">
      <summary>
            Creates a circular region by position.
            </summary>
      <param name="x">Center's X coordinate</param>
      <param name="y">Center's Y coordinate</param>
      <param name="radius">Radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateCircle(devDept.Geometry.Plane,System.Double)">
      <summary>
            Creates a circular region by plane.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="radius">Radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateCircle(devDept.Geometry.Plane,System.Double,System.Double,System.Double)">
      <summary>
            Creates a circular region by plane and position.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="x">Center's X coordinate</param>
      <param name="y">Center's Y coordinate</param>
      <param name="radius">Radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateCircle(devDept.Geometry.Plane,devDept.Geometry.Point2D,System.Double)">
      <summary>
            Creates a circular region by plane and position.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="center">2D center point</param>
      <param name="radius">Radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateEllipse(System.Double,System.Double)">
      <summary>
            Creates an elliptical region.
            </summary>
      <param name="x">Center's X coordinate</param>
      <param name="y">Center's Y coordinate</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateEllipse(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Creates an elliptical region by position.
            </summary>
      <param name="x">Center's X coordinate</param>
      <param name="y">Center's Y coordinate</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateEllipse(devDept.Geometry.Plane,System.Double,System.Double)">
      <summary>
            Creates an elliptical region by plane.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateEllipse(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Creates an elliptical region by plane and position.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="x">Center's X coordinate</param>
      <param name="y">Center's Y coordinate</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateEllipse(devDept.Geometry.Plane,devDept.Geometry.Point2D,System.Double,System.Double)">
      <summary>
            Creates an elliptical region by plane and position.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="center">2D center point</param>
      <param name="rx">Radius X</param>
      <param name="ry">Radius Y</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreatePolygon(devDept.Geometry.Point2D[])">
      <summary>
            Creates a polygonal region. 
            </summary>
      <param name="points">A list of 2D points</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreatePolygon(devDept.Geometry.Point3D[])">
      <summary>
            Creates a polygonal region.
            </summary>
      <param name="points">A list of 3D points laying on an arbitrary plane</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreatePolygon(devDept.Geometry.Plane,System.Collections.Generic.IList{devDept.Geometry.Point2D})">
      <summary>
            Creates a polygonal region by plane.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="points">A list of 2D points laying on the plane</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateSlot(System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a region with the shape of a slot.
            </summary>
      <param name="length">Center to center length</param>
      <param name="radius">Radius</param>
      <param name="centered">When true, the slot is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateSlot(System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a region with the shape of a slot by position.
            </summary>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="length">Center to center length</param>
      <param name="radius">Radius</param>
      <param name="angle">Rotation angle in radians</param>
      <param name="centered">When true, the slot is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateSlot(devDept.Geometry.Plane,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a region with the shape of a slot by plane.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="length">Center to center length</param>
      <param name="radius">Radius</param>
      <param name="centered">When true, the slot is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateSlot(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a region with the shape of a slot by plane and position.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="length">Center to center length</param>
      <param name="radius">Radius</param>
      <param name="angle">Rotation angle in radians</param>
      <param name="centered">When true, the slot is built centered on the origin.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateCircularSlot(System.Double,System.Double,System.Double)">
      <summary>
            Creates a region with the shape of a circular slot.
            </summary>
      <param name="angle">Angle in radians</param>
      <param name="radius">Circle radius</param>
      <param name="slotRadius">Slot radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateCircularSlot(System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Creates a region with the shape of a circular slot by position.
            </summary>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="angle">Angle in radians</param>
      <param name="radius">Circle radius</param>
      <param name="slotRadius">Slot radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateCircularSlot(devDept.Geometry.Plane,System.Double,System.Double,System.Double)">
      <summary>
            Creates a region with the shape of a circular slot by plane.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="angle">Angle in radians</param>
      <param name="radius">Circle radius</param>
      <param name="slotRadius">Slot radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateCircularSlot(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Creates a region with the shape of a circular slot by plane and position.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="angle">Angle in radians</param>
      <param name="radius">Circle radius</param>
      <param name="slotRadius">Slot radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateCircularSlot(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Creates a region with the shape of a circular slot by start angle.
            </summary>
      <param name="startAngle">Start angle in radians</param>
      <param name="deltaAngle">Delta angle in radians</param>
      <param name="radius">Circle radius</param>
      <param name="slotRadius">Slot radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateCircularSlot(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Creates a region with the shape of a circular slot by position and start angle.
            </summary>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="startAngle">Start angle in radians</param>
      <param name="deltaAngle">Delta angle in radians</param>
      <param name="radius">Circle radius</param>
      <param name="slotRadius">Slot radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateCircularSlot(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Creates a region with the shape of a circular slot by plane and start angle.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="startAngle">Start angle in radians</param>
      <param name="deltaAngle">Delta angle in radians</param>
      <param name="radius">Circle radius</param>
      <param name="slotRadius">Slot radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateCircularSlot(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Creates a region with the shape of a circular slot by plane, position and start angle.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="startAngle">Start angle in radians</param>
      <param name="deltaAngle">Delta angle in radians</param>
      <param name="radius">Circle radius</param>
      <param name="slotRadius">Slot radius</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateHexagon(System.Double,System.Boolean)">
      <summary>
            Creates an hexagonal region.
            </summary>
      <param name="radius">The hexagon radius</param>
      <param name="inscribed">When true, the radius is considered of the inscribed circle</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateHexagon(System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates an hexagonal region by position.
            </summary>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="radius">The hexagon radius</param>
      <param name="angle">Rotation angle in radians</param>
      <param name="inscribed">When true, the radius is considered of the inscribed circle</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateHexagon(devDept.Geometry.Plane,System.Double,System.Boolean)">
      <summary>
            Creates an hexagonal region by plane.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="radius">The hexagon radius</param>
      <param name="inscribed">When true, the radius is considered of the inscribed circle</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRegion.CreateHexagon(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates an hexagonal region by plane and position.
            </summary>
      <param name="sketchPlane">Sketch plane</param>
      <param name="x">Position along the plane X axis</param>
      <param name="y">Position along the plane Y axis</param>
      <param name="radius">The hexagon radius</param>
      <param name="angle">Rotation angle in radians</param>
      <param name="inscribed">When true, the radius is considered of the inscribed circle</param>
    </member>
    <member name="T:devDept.Geometry.Entities.GTriangle">
      <summary>
            Triangular face entity.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GTriangle.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Standard constructor.
            </summary>
      <param name="v1x">First vertex's X-coordinate</param>
      <param name="v1y">First vertex's Y-coordinate</param>
      <param name="v1z">First vertex's Z-coordinate</param>
      <param name="v2x">Second vertex's X-coordinate</param>
      <param name="v2y">Second vertex's Y-coordinate</param>
      <param name="v2z">Second vertex's Z-coordinate</param>
      <param name="v3x">Third vertex's X-coordinate</param>
      <param name="v3y">Third vertex's Y-coordinate</param>
      <param name="v3z">Third vertex's Z-coordinate</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GTriangle.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            3D point constructor.
            </summary>
      <param name="v1">First vertex</param>
      <param name="v2">Second vertex</param>
      <param name="v3">Third vertex</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GTriangle.Clone">
      <summary>
            Creates a deep copy of this triangle.
            </summary>
      <returns>The new triangle object.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GTriangle.Normal">
      <summary>
            Gets or sets the triangle's normal.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GTriangle.V1">
      <summary>
            Gets or sets the first vertex.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GTriangle.V2">
      <summary>
            Gets or sets the second vertex.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GTriangle.V3">
      <summary>
            Gets or sets the third vertex.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GTriangle.FindClosestTriangle(devDept.Geometry.Transformation,devDept.Geometry.Segment3D)">
      <summary>
            Returns a list of triangles hit by the provided segment.
            </summary>
      <param name="transf">The transformation applied to the entity (necessary if the entity is inside a Block to propagate the BlockReference transformation)</param>
      <param name="seg">The 3D segment representing the viewing direction</param>
      <returns>The sorted list of triangles intersecting the provided segment.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GTriangle.Area(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Computes the area of a triangle.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GTriangle.Area2D(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Computes the projected area (on plane XY) of a triangle.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GTriangle.Centroid(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Computes the centroid of a triangle.
            </summary>
      <param name="p1">First vertex</param>
      <param name="p2">Second vertex</param>
      <param name="p3">Third vertex</param>
      <returns>The 3D centroid position.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GTriangle.GetPerimeter">
      <summary>
            Computes the perimeter of the triangle entity.
            </summary>
      <returns>The perimeter amount.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GTriangle.GetArea(devDept.Geometry.Point3D@)">
      <summary>
            Computes the area of the triangle entity.
            </summary>
      <param name="centroid">The centroid.</param>
      <returns>The area amount.</returns>
    </member>
    <member name="T:devDept.Geometry.Entities.GMesh">
      <summary>
        <para>A triangle mesh is a type of polygon mesh in computer graphics. It
            comprises a set of triangles (typically in three dimensions) that are connected
            by their common edges or corners. </para>
        <para>Depending on the types of vertices and triangles, itÂ can assume different
            configurations, see table below.</para>
        <list type="table">
          <item>
            <term>Triangles type / Vertices type</term>
            <description>
              <see cref="T:devDept.Geometry.Point3D" />
            </description>
            <description>
              <see cref="T:devDept.Geometry.PointRGB" />
            </description>
          </item>
          <item>
            <term>
              <see cref="T:devDept.Geometry.IndexTriangle" />
            </term>
            <description>Plain<sup>1</sup></description>
            <description>MulticolorPlain</description>
          </item>
          <item>
            <term>
              <see cref="T:devDept.Geometry.SmoothTriangle" />
            </term>
            <description>Smooth<sup>1</sup></description>
            <description>MulticolorSmooth</description>
          </item>
          <item>
            <term>
              <see cref="T:devDept.Geometry.ColorTriangle" />
            </term>
            <description>ColorPlain</description>
            <description>
            </description>
          </item>
          <item>
            <term>
              <see cref="T:devDept.Geometry.ColorSmoothTriangle" />
            </term>
            <description>ColorSmooth</description>
            <description>
            </description>
          </item>
          <item>
            <term>
              <see cref="T:devDept.Geometry.RichTriangle" />
            </term>
            <description>RichPlain</description>
            <description>
            </description>
          </item>
          <item>
            <term>
              <see cref="T:devDept.Geometry.RichSmoothTriangle" />
            </term>
            <description>RichSmooth</description>
            <description>
            </description>
          </item>
        </list>
        <para>
          <sup>1</sup> Allows transparency to be used</para>
      </summary>
      <example>
            The following code samples demonstrate how to use the different mesh natures. 
            <code lang="C#"><![CDATA[
             using System;
             using System.Collections.Generic;
             
             using devDept.Eyeshot;
             using devDept.Geometry.Entities;
             using devDept.Geometry;
             
             namespace MeshSamples
             {
                 internal class GMesh
                 {
                     private static int rows = 8;
                     private static int cols = 8;
                     private static double scale = 4;
             
                     public static void Plain(Design design)
                     {
                         List<Point3D> vertices = new List<Point3D>(rows * cols);
                         GMesh surface = new GMesh();
                         surface.NormalAveragingMode = GMesh.normalAveragingType.Averaged;
                         for (int j = 0; j < rows; j++)
                             for (int i = 0; i < cols; i++)
                             {
                                 double x = -i / 5.0 - 2;
                                 double y = -j / 5.0 - 2;
                                 double f = 0;
                                 double den = Math.Sqrt(x * x + y * y);
                                 if (den != 0)
                                     f = scale * Math.Sin(Math.Sqrt(x * x + y * y)) / den;
                                 vertices.Add(new Point3D(x, y, f));
                             }
                         List<IndexTriangle> triangles = new List<IndexTriangle>((rows - 1) * (cols - 1) * 2);
                         for (int j = 0; j < (rows - 1); j++)
                             for (int i = 0; i < (cols - 1); i++)
                             {
                                 triangles.Add(new IndexTriangle(i + j * cols,
                                                                 i + j * cols + 1,
                                                                 i + (j + 1) * cols + 1));
                                 triangles.Add(new IndexTriangle(i + j * cols,
                                                                 i + (j + 1) * cols + 1,
                                                                 i + (j + 1) * cols));
                             }
                         surface.Vertices = vertices.ToArray();
                         surface.Triangles = triangles.ToArray();
                         design.Entities.Add(surface, 0, Color.Green);
                     }
             
                     public static void ColoredPlain(Design design)
                     {
                         List<Point3D> vertices = new List<Point3D>(rows*cols);
                         GMesh surface = new GMesh();
                         for (int j = 0; j < rows; j++)
                             for (int i = 0; i < cols; i++)
                             {
                                 double x = -i/5.0 - 2;
                                 double y = -j/5.0 - 2;
                                 double f = 0;
                                 double den = Math.Sqrt(x*x + y*y);
                                 if (den != 0)
                                     f = scale*Math.Sin(Math.Sqrt(x*x + y*y))/den;
                                 vertices.Add(new Point3D(x, y, f));
                             }
                         List<ColorTriangle> triangles = new List<ColorTriangle>((rows - 1)*(cols - 1)*2);
                         for (int j = 0; j < (rows - 1); j++)
                             for (int i = 0; i < (cols - 1); i++)
                             {
                                 // generates a random color
                                 int red = (int) (255 - i*100);
                                 int green = (int) (255 - j*50);
                                 int blue = 127;
                                 // clamps color values lat 0-255
                                 Utility.LimitRange<int>(0, ref red, 255);
                                 Utility.LimitRange<int>(0, ref green, 255);
                                 Utility.LimitRange<int>(0, ref blue, 255);
                                 triangles.Add(new ColorTriangle(i + j*cols,
                                                                 i + j*cols + 1,
                                                                 i + (j + 1)*cols + 1, (byte) red, (byte) green, (byte) blue));
                                 triangles.Add(new ColorTriangle(i + j*cols,
                                                                 i + (j + 1)*cols + 1,
                                                                 i + (j + 1)*cols, (byte) red, (byte) green, (byte) blue));
                             }
                         surface.Vertices = vertices.ToArray();
                         surface.Triangles = triangles.ToArray();
                         design.Entities.Add(surface, 0);
                     }
             
                     public static void MulticolorPlain(Design design)
                     {
                         List<PointRGB> vertices = new List<PointRGB>(rows * cols);
                         GMesh surface = new GMesh();
                         for (int j = 0; j < rows; j++)
                             for (int i = 0; i < cols; i++)
                             {
                                 double x = -i / 5.0 - 2;
                                 double y = -j / 5.0 - 2;
                                 double f = 0;
                                 double den = Math.Sqrt(x * x + y * y);
                                 if (den != 0)
                                     f = scale * Math.Sin(Math.Sqrt(x * x + y * y)) / den;
                                 // generates a random color
                                 int red = (int)(y * y * 30);
                                 int green = (int)(x * x * 30);
                                 int blue = (int)(255 - f * f * 1000);
                                 // clamps color values lat 0-255
                                 Utility.LimitRange<int>(0, ref red, 255);
                                 Utility.LimitRange<int>(0, ref green, 255);
                                 Utility.LimitRange<int>(0, ref blue, 255);
                                 vertices.Add(new PointRGB(x, y, f, (byte)red, (byte)green, (byte)blue));
                             }
                         List<IndexTriangle> triangles = new List<IndexTriangle>((rows - 1) * (cols - 1) * 2);
                         for (int j = 0; j < (rows - 1); j++)
                             for (int i = 0; i < (cols - 1); i++)
                             {
                                 triangles.Add(new IndexTriangle(i + j * cols,
                                                                 i + j * cols + 1,
                                                                 i + (j + 1) * cols + 1));
                                 triangles.Add(new IndexTriangle(i + j * cols,
                                                                 i + (j + 1) * cols + 1,
                                                                 i + (j + 1) * cols));
                             }
                         surface.Vertices = vertices.ToArray();
                         surface.Triangles = triangles.ToArray();
                         design.Entities.Add(surface);
                     }
             
                     public static void TexturedPlain(Design design)
                     {
                         List<Point3D> vertices = new List<Point3D>(rows * cols);
                         List<Point2D> texCoords = new List<Point2D>(rows * cols);
                         GMesh surface = new GMesh();
                         for (int j = 0; j < rows; j++)
                             for (int i = 0; i < cols; i++)
                             {
                                 double x = -i / 5.0 - 2;
                                 double y = -j / 5.0 - 2;
                                 double f = 0;
                                 double den = Math.Sqrt(x * x + y * y);
                                 if (den != 0)
                                     f = scale * Math.Sin(Math.Sqrt(x * x + y * y)) / den;
                                 vertices.Add(new Point3D(x, y, f));
                                 texCoords.Add(new Point2D((-x * 5) / (rows - 1), (-y * 5) / (cols - 1)));
                             }
                         Bitmap bmp = new Bitmap(Properties.Resources.Smiley);
                         Material mat = new Material(bmp);
                         design.Materials.Add("test", mat);
                         List<RichTriangle> triangles = new List<RichTriangle>((rows - 1) * (cols - 1) * 2);
                         for (int j = 0; j < (rows - 1); j++)
                             for (int i = 0; i < (cols - 1); i++)
                             {
                                 RichTriangle tri = new RichTriangle(i + j * cols,
                                                                     i + j * cols + 1,
                                                                     i + (j + 1) * cols + 1);
                                 tri.T1 = tri.V1;
                                 tri.T2 = tri.V2;
                                 tri.T3 = tri.V3;
                                 triangles.Add(tri);
                                 tri = new RichTriangle(i + j * cols,
                                                        i + (j + 1) * cols + 1,
                                                        i + (j + 1) * cols);
                                 tri.T1 = tri.V1;
                                 tri.T2 = tri.V2;
                                 tri.T3 = tri.V3;
                                 triangles.Add(tri);
                             }
                         surface.Vertices = vertices.ToArray();
                         surface.Triangles = triangles.ToArray();
                         surface.TextureCoords = texCoords.ToArray();
             
                         surface.ColorMethod = colorMethodType.byEntity;
                         surface.MaterialName = "test";
             
                         design.Entities.Add(surface);
                     }
             
                     public static void Smooth(Design design)
                     {
                         List<Point3D> vertices = new List<Point3D>(rows * cols);
                         GMesh surface = new GMesh();
                         surface.NormalAveragingMode = GMesh.normalAveragingType.Averaged;
                         for (int j = 0; j < rows; j++)
                             for (int i = 0; i < cols; i++)
                             {
                                 double x = -i / 5.0 - 2;
                                 double y = -j / 5.0 - 2;
                                 double f = 0;
                                 double den = Math.Sqrt(x * x + y * y);
                                 if (den != 0)
                                     f = scale * Math.Sin(Math.Sqrt(x * x + y * y)) / den;
                                 vertices.Add(new Point3D(x, y, f));
                             }
                         List<SmoothTriangle> triangles = new List<SmoothTriangle>((rows - 1) * (cols - 1) * 2);
                         for (int j = 0; j < (rows - 1); j++)
                             for (int i = 0; i < (cols - 1); i++)
                             {
                                 triangles.Add(new SmoothTriangle(i + j * cols,
                                                                  i + j * cols + 1,
                                                                  i + (j + 1) * cols + 1));
                                 triangles.Add(new SmoothTriangle(i + j * cols,
                                                                  i + (j + 1) * cols + 1,
                                                                  i + (j + 1) * cols));
                             }
                         surface.Vertices = vertices.ToArray();
                         surface.Triangles = triangles.ToArray();
                         design.Entities.Add(surface, 0, Color.Green);
                     }
             
                     public static void ColoredSmooth(Design design)
                     {
                         List<Point3D> vertices = new List<Point3D>(rows * cols);
                         GMesh surface = new GMesh();
                         for (int j = 0; j < rows; j++)
                             for (int i = 0; i < cols; i++)
                             {
                                 double x = -i / 5.0 - 2;
                                 double y = -j / 5.0 - 2;
                                 double f = 0;
                                 double den = Math.Sqrt(x * x + y * y);
                                 if (den != 0)
                                     f = scale * Math.Sin(Math.Sqrt(x * x + y * y)) / den;
                                 vertices.Add(new Point3D(x, y, f));
                             }
                         List<ColorSmoothTriangle> triangles = new List<ColorSmoothTriangle>((rows - 1) * (cols - 1) * 2);
                         for (int j = 0; j < (rows - 1); j++)
                             for (int i = 0; i < (cols - 1); i++)
                             {
                                 // generates a random color
                                 int red = (255 - i * 100);
                                 int green = (255 - j * 50);
                                 int blue = 127;
                                 // clamps color values lat 0-255
                                 Utility.LimitRange<int>(0, ref red, 255);
                                 Utility.LimitRange<int>(0, ref green, 255);
                                 Utility.LimitRange<int>(0, ref blue, 255);
                                 triangles.Add(new ColorSmoothTriangle(i + j * cols,
                                                                       i + j * cols + 1,
                                                                       i + (j + 1) * cols + 1, (byte)red, (byte)green, (byte)blue));
                                 triangles.Add(new ColorSmoothTriangle(i + j * cols,
                                                                       i + (j + 1) * cols + 1,
                                                                       i + (j + 1) * cols, (byte)red, (byte)green, (byte)blue));
                             }
                         surface.Vertices = vertices.ToArray();
                         surface.Triangles = triangles.ToArray();
                         design.Entities.Add(surface, 0);
                     }
             
                     public static void MulticolorSmooth(Design design)
                     {
                         List<PointRGB> vertices = new List<PointRGB>(rows * cols);
                         GMesh surface = new GMesh();
                         surface.NormalAveragingMode = GMesh.normalAveragingType.Averaged;
                         for (int j = 0; j < rows; j++)
                             for (int i = 0; i < cols; i++)
                             {
                                 double x = -i / 5.0 - 2;
                                 double y = -j / 5.0 - 2;
                                 double f = 0;
                                 double den = Math.Sqrt(x * x + y * y);
                                 if (den != 0)
                                     f = scale * Math.Sin(Math.Sqrt(x * x + y * y)) / den;
                                 // generates a random color
                                 int red = (int)(y * y * 30);
                                 int green = (int)(x * x * 30);
                                 int blue = (int)(255 - f * f * 1000);
                                 // clamps color values lat 0-255
                                 Utility.LimitRange<int>(0, ref red, 255);
                                 Utility.LimitRange<int>(0, ref green, 255);
                                 Utility.LimitRange<int>(0, ref blue, 255);
                                 vertices.Add(new PointRGB(x, y, f, (byte)red, (byte)green, (byte)blue));
                             }
                         List<SmoothTriangle> triangles = new List<SmoothTriangle>((rows - 1) * (cols - 1) * 2);
                         for (int j = 0; j < (rows - 1); j++)
                             for (int i = 0; i < (cols - 1); i++)
                             {
                                 triangles.Add(new SmoothTriangle(i + j * cols,
                                                                  i + j * cols + 1,
                                                                  i + (j + 1) * cols + 1));
                                 triangles.Add(new SmoothTriangle(i + j * cols,
                                                                  i + (j + 1) * cols + 1,
                                                                  i + (j + 1) * cols));
                             }
                         surface.Vertices = vertices.ToArray();
                         surface.Triangles = triangles.ToArray();
                         design.Entities.Add(surface, 0);
                     }
             
                     public static void TexturedSmooth(Design design)
                     {
                         List<Point3D> vertices = new List<Point3D>(rows * cols);
                         List<Point2D> texCoords = new List<Point2D>(rows * cols);
                         GMesh surface = new GMesh();
                         for (int j = 0; j < rows; j++)
                             for (int i = 0; i < cols; i++)
                             {
                                 double x = -i / 5.0 - 2;
                                 double y = -j / 5.0 - 2;
                                 double f = 0;
                                 double den = Math.Sqrt(x * x + y * y);
                                 if (den != 0)
                                     f = scale * Math.Sin(Math.Sqrt(x * x + y * y)) / den;
                                 vertices.Add(new Point3D(x, y, f));
                                 texCoords.Add(new Point2D((-x * 5) / (rows - 1), (-y * 5) / (cols - 1)));
                             }
                         Bitmap bmp = new Bitmap(Properties.Resources.Smiley);
                         Material mat = new Material(bmp);
                         design.Materials.Add("test", mat);
                         List<RichSmoothTriangle> triangles = new List<RichSmoothTriangle>((rows - 1) * (cols - 1) * 2);
                         for (int j = 0; j < (rows - 1); j++)
                             for (int i = 0; i < (cols - 1); i++)
                             {
                                 RichSmoothTriangle tri = new RichSmoothTriangle(i + j * cols,
                                                                                 i + j * cols + 1,
                                                                                 i + (j + 1) * cols + 1);
                                 tri.T1 = tri.V1;
                                 tri.T2 = tri.V2;
                                 tri.T3 = tri.V3;
                                 triangles.Add(tri);
                                 tri = new RichSmoothTriangle(i + j * cols,
                                                              i + (j + 1) * cols + 1,
                                                              i + (j + 1) * cols);
                                 tri.T1 = tri.V1;
                                 tri.T2 = tri.V2;
                                 tri.T3 = tri.V3;
                                 triangles.Add(tri);
                             }
                         surface.Vertices = vertices.ToArray();
                         surface.Triangles = triangles.ToArray();
                         surface.TextureCoords = texCoords.ToArray();
             
                         surface.MaterialName = "test";
                         surface.ColorMethod = colorMethodType.byEntity;
             
                         design.Entities.Add(surface, 0);
                     }
             
                 }
            ]]></code><code lang="VB"><![CDATA[
             Imports System
             Imports System.Collections.Generic
             Imports devDept.Eyeshot
             Imports devDept.Geometry.Entities
             Imports devDept.Geometry
             Namespace MeshSamples
                 Friend Class GMesh
                 	Private Shared rows As Integer = 8
                 	Private Shared cols As Integer = 8
                 	Private Shared scale As Double = 4
             
                 	Public Shared Sub Plain(design As Design)
                 		Dim vertices As New List(Of Point3D)(rows * cols)
                 		Dim surface As New GMesh()
                 		surface.NormalAveragingMode = GMesh.normalAveragingType.Averaged
                 		For j As Integer = 0 To rows - 1
                 			For i As Integer = 0 To cols - 1
                 				Dim x As Double = -i / 5.0 - 2
                 				Dim y As Double = -j / 5.0 - 2
                 				Dim f As Double = 0
                 				Dim den As Double = Math.Sqrt(x * x + y * y)
                 				If den <> 0 Then
                 					f = scale * Math.Sin(Math.Sqrt(x * x + y * y)) / den
                 				End If
                 				vertices.Add(New Point3D(x, y, f))
                 			Next
                 		Next
                 		Dim triangles As New List(Of IndexTriangle)((rows - 1) * (cols - 1) * 2)
                 		For j As Integer = 0 To (rows - 1) - 1
                 			For i As Integer = 0 To (cols - 1) - 1
                 				triangles.Add(New IndexTriangle(i + j * cols, i + j * cols + 1, i + (j + 1) * cols + 1))
                 				triangles.Add(New IndexTriangle(i + j * cols, i + (j + 1) * cols + 1, i + (j + 1) * cols))
                 			Next
                 		Next
                 		surface.Vertices = vertices.ToArray()
                 		surface.Triangles = triangles.ToArray()
                 		design.Entities.Add(surface, 0, Color.Green)
                 	End Sub
             
                 	Public Shared Sub ColoredPlain(design As Design)
                 		Dim vertices As New List(Of Point3D)(rows * cols)
                 		Dim surface As New GMesh()
                 		For j As Integer = 0 To rows - 1
                 			For i As Integer = 0 To cols - 1
                 				Dim x As Double = -i / 5.0 - 2
                 				Dim y As Double = -j / 5.0 - 2
                 				Dim f As Double = 0
                 				Dim den As Double = Math.Sqrt(x * x + y * y)
                 				If den <> 0 Then
                 					f = scale * Math.Sin(Math.Sqrt(x * x + y * y)) / den
                 				End If
                 				vertices.Add(New Point3D(x, y, f))
                 			Next
                 		Next
                 		Dim triangles As New List(Of ColorTriangle)((rows - 1) * (cols - 1) * 2)
                 		For j As Integer = 0 To (rows - 1) - 1
                 			For i As Integer = 0 To (cols - 1) - 1
                 				' generates a random color
                 				Dim red As Integer = CInt(255 - i * 100)
                 				Dim green As Integer = CInt(255 - j * 50)
                 				Dim blue As Integer = 127
                 				' clamps color values lat 0-255
                 				Utility.LimitRange(Of Integer)(0, red, 255)
                 				Utility.LimitRange(Of Integer)(0, green, 255)
                 				Utility.LimitRange(Of Integer)(0, blue, 255)
                 				triangles.Add(New ColorTriangle(i + j * cols, i + j * cols + 1, i + (j + 1) * cols + 1, CByte(red), CByte(green), CByte(blue)))
                 				triangles.Add(New ColorTriangle(i + j * cols, i + (j + 1) * cols + 1, i + (j + 1) * cols, CByte(red), CByte(green), CByte(blue)))
                 			Next
                 		Next
                 		surface.Vertices = vertices.ToArray()
                 		surface.Triangles = triangles.ToArray()
                 		design.Entities.Add(surface, 0)
                 	End Sub
             
                 	Public Shared Sub MulticolorPlain(design As Design)
                 		Dim vertices As New List(Of PointRGB)(rows * cols)
                 		Dim surface As New GMesh()
                 		For j As Integer = 0 To rows - 1
                 			For i As Integer = 0 To cols - 1
                 				Dim x As Double = -i / 5.0 - 2
                 				Dim y As Double = -j / 5.0 - 2
                 				Dim f As Double = 0
                 				Dim den As Double = Math.Sqrt(x * x + y * y)
                 				If den <> 0 Then
                 					f = scale * Math.Sin(Math.Sqrt(x * x + y * y)) / den
                 				End If
                 				' generates a random color
                 				Dim red As Integer = CInt(y * y * 30)
                 				Dim green As Integer = CInt(x * x * 30)
                 				Dim blue As Integer = CInt(255 - f * f * 1000)
                 				' clamps color values lat 0-255
                 				Utility.LimitRange(Of Integer)(0, red, 255)
                 				Utility.LimitRange(Of Integer)(0, green, 255)
                 				Utility.LimitRange(Of Integer)(0, blue, 255)
                 				vertices.Add(New PointRGB(x, y, f, CByte(red), CByte(green), CByte(blue)))
                 			Next
                 		Next
                 		Dim triangles As New List(Of IndexTriangle)((rows - 1) * (cols - 1) * 2)
                 		For j As Integer = 0 To (rows - 1) - 1
                 			For i As Integer = 0 To (cols - 1) - 1
                 				triangles.Add(New IndexTriangle(i + j * cols, i + j * cols + 1, i + (j + 1) * cols + 1))
                 				triangles.Add(New IndexTriangle(i + j * cols, i + (j + 1) * cols + 1, i + (j + 1) * cols))
                 			Next
                 		Next
                 		surface.Vertices = vertices.ToArray()
                 		surface.Triangles = triangles.ToArray()
                 		design.Entities.Add(surface)
                 	End Sub
             
                 	Public Shared Sub TexturedPlain(design As Design)
                 		Dim vertices As New List(Of Point3D)(rows * cols)
                 		Dim texCoords As New List(Of Point2D)(rows * cols)
                 		Dim surface As New GMesh()
                 		For j As Integer = 0 To rows - 1
                 			For i As Integer = 0 To cols - 1
                 				Dim x As Double = -i / 5.0 - 2
                 				Dim y As Double = -j / 5.0 - 2
                 				Dim f As Double = 0
                 				Dim den As Double = Math.Sqrt(x * x + y * y)
                 				If den <> 0 Then
                 					f = scale * Math.Sin(Math.Sqrt(x * x + y * y)) / den
                 				End If
                 				vertices.Add(New Point3D(x, y, f))
                 				texCoords.Add(New Point2D((-x * 5) / (rows - 1), (-y * 5) / (cols - 1)))
                 			Next
                 		Next
                 		Dim bmp As New Bitmap(Properties.Resources.Smiley)
                 		Dim mat As New Material(bmp)
                 		design.Materials.Add("test", mat)
                 		Dim triangles As New List(Of RichTriangle)((rows - 1) * (cols - 1) * 2)
                 		For j As Integer = 0 To (rows - 1) - 1
                 			For i As Integer = 0 To (cols - 1) - 1
                 				Dim tri As New RichTriangle(i + j * cols, i + j * cols + 1, i + (j + 1) * cols + 1)
                 				tri.T1 = tri.V1
                 				tri.T2 = tri.V2
                 				tri.T3 = tri.V3
                 				triangles.Add(tri)
                 				tri = New RichTriangle(i + j * cols, i + (j + 1) * cols + 1, i + (j + 1) * cols)
                 				tri.T1 = tri.V1
                 				tri.T2 = tri.V2
                 				tri.T3 = tri.V3
                 				triangles.Add(tri)
                 			Next
                 		Next
                 		surface.Vertices = vertices.ToArray()
                 		surface.Triangles = triangles.ToArray()
                 		surface.TextureCoords = texCoords.ToArray()
             
                 		surface.ColorMethod = colorMethodType.byEntity
                 		surface.MaterialName = "test"
             
                 		design.Entities.Add(surface)
                 	End Sub
             
                 	Public Shared Sub Smooth(design As Design)
                 		Dim vertices As New List(Of Point3D)(rows * cols)
                 		Dim surface As New GMesh()
                 		surface.NormalAveragingMode = GMesh.normalAveragingType.Averaged
                 		For j As Integer = 0 To rows - 1
                 			For i As Integer = 0 To cols - 1
                 				Dim x As Double = -i / 5.0 - 2
                 				Dim y As Double = -j / 5.0 - 2
                 				Dim f As Double = 0
                 				Dim den As Double = Math.Sqrt(x * x + y * y)
                 				If den <> 0 Then
                 					f = scale * Math.Sin(Math.Sqrt(x * x + y * y)) / den
                 				End If
                 				vertices.Add(New Point3D(x, y, f))
                 			Next
                 		Next
                 		Dim triangles As New List(Of SmoothTriangle)((rows - 1) * (cols - 1) * 2)
                 		For j As Integer = 0 To (rows - 1) - 1
                 			For i As Integer = 0 To (cols - 1) - 1
                 				triangles.Add(New SmoothTriangle(i + j * cols, i + j * cols + 1, i + (j + 1) * cols + 1))
                 				triangles.Add(New SmoothTriangle(i + j * cols, i + (j + 1) * cols + 1, i + (j + 1) * cols))
                 			Next
                 		Next
                 		surface.Vertices = vertices.ToArray()
                 		surface.Triangles = triangles.ToArray()
                 		design.Entities.Add(surface, 0, Color.Green)
                 	End Sub
             
                 	Public Shared Sub ColoredSmooth(design As Design)
                 		Dim vertices As New List(Of Point3D)(rows * cols)
                 		Dim surface As New GMesh()
                 		For j As Integer = 0 To rows - 1
                 			For i As Integer = 0 To cols - 1
                 				Dim x As Double = -i / 5.0 - 2
                 				Dim y As Double = -j / 5.0 - 2
                 				Dim f As Double = 0
                 				Dim den As Double = Math.Sqrt(x * x + y * y)
                 				If den <> 0 Then
                 					f = scale * Math.Sin(Math.Sqrt(x * x + y * y)) / den
                 				End If
                 				vertices.Add(New Point3D(x, y, f))
                 			Next
                 		Next
                 		Dim triangles As New List(Of ColorSmoothTriangle)((rows - 1) * (cols - 1) * 2)
                 		For j As Integer = 0 To (rows - 1) - 1
                 			For i As Integer = 0 To (cols - 1) - 1
                 				' generates a random color
                 				Dim red As Integer = (255 - i * 100)
                 				Dim green As Integer = (255 - j * 50)
                 				Dim blue As Integer = 127
                 				' clamps color values lat 0-255
                 				Utility.LimitRange(Of Integer)(0, red, 255)
                 				Utility.LimitRange(Of Integer)(0, green, 255)
                 				Utility.LimitRange(Of Integer)(0, blue, 255)
                 				triangles.Add(New ColorSmoothTriangle(i + j * cols, i + j * cols + 1, i + (j + 1) * cols + 1, CByte(red), CByte(green), CByte(blue)))
                 				triangles.Add(New ColorSmoothTriangle(i + j * cols, i + (j + 1) * cols + 1, i + (j + 1) * cols, CByte(red), CByte(green), CByte(blue)))
                 			Next
                 		Next
                 		surface.Vertices = vertices.ToArray()
                 		surface.Triangles = triangles.ToArray()
                 		design.Entities.Add(surface, 0)
                 	End Sub
             
                 	Public Shared Sub MulticolorSmooth(design As Design)
                 		Dim vertices As New List(Of PointRGB)(rows * cols)
                 		Dim surface As New GMesh()
                 		surface.NormalAveragingMode = GMesh.normalAveragingType.Averaged
                 		For j As Integer = 0 To rows - 1
                 			For i As Integer = 0 To cols - 1
                 				Dim x As Double = -i / 5.0 - 2
                 				Dim y As Double = -j / 5.0 - 2
                 				Dim f As Double = 0
                 				Dim den As Double = Math.Sqrt(x * x + y * y)
                 				If den <> 0 Then
                 					f = scale * Math.Sin(Math.Sqrt(x * x + y * y)) / den
                 				End If
                 				' generates a random color
                 				Dim red As Integer = CInt(y * y * 30)
                 				Dim green As Integer = CInt(x * x * 30)
                 				Dim blue As Integer = CInt(255 - f * f * 1000)
                 				' clamps color values lat 0-255
                 				Utility.LimitRange(Of Integer)(0, red, 255)
                 				Utility.LimitRange(Of Integer)(0, green, 255)
                 				Utility.LimitRange(Of Integer)(0, blue, 255)
                 				vertices.Add(New PointRGB(x, y, f, CByte(red), CByte(green), CByte(blue)))
                 			Next
                 		Next
                 		Dim triangles As New List(Of SmoothTriangle)((rows - 1) * (cols - 1) * 2)
                 		For j As Integer = 0 To (rows - 1) - 1
                 			For i As Integer = 0 To (cols - 1) - 1
                 				triangles.Add(New SmoothTriangle(i + j * cols, i + j * cols + 1, i + (j + 1) * cols + 1))
                 				triangles.Add(New SmoothTriangle(i + j * cols, i + (j + 1) * cols + 1, i + (j + 1) * cols))
                 			Next
                 		Next
                 		surface.Vertices = vertices.ToArray()
                 		surface.Triangles = triangles.ToArray()
                 		design.Entities.Add(surface, 0)
                 	End Sub
             
                 	Public Shared Sub TexturedSmooth(design As Design)
                 		Dim vertices As New List(Of Point3D)(rows * cols)
                 		Dim texCoords As New List(Of Point2D)(rows * cols)
                 		Dim surface As New GMesh()
                 		For j As Integer = 0 To rows - 1
                 			For i As Integer = 0 To cols - 1
                 				Dim x As Double = -i / 5.0 - 2
                 				Dim y As Double = -j / 5.0 - 2
                 				Dim f As Double = 0
                 				Dim den As Double = Math.Sqrt(x * x + y * y)
                 				If den <> 0 Then
                 					f = scale * Math.Sin(Math.Sqrt(x * x + y * y)) / den
                 				End If
                 				vertices.Add(New Point3D(x, y, f))
                 				texCoords.Add(New Point2D((-x * 5) / (rows - 1), (-y * 5) / (cols - 1)))
                 			Next
                 		Next
                 		Dim bmp As New Bitmap(Properties.Resources.Smiley)
                 		Dim mat As New Material(bmp)
                 		design.Materials.Add("test", mat)
                 		Dim triangles As New List(Of RichSmoothTriangle)((rows - 1) * (cols - 1) * 2)
                 		For j As Integer = 0 To (rows - 1) - 1
                 			For i As Integer = 0 To (cols - 1) - 1
                 				Dim tri As New RichSmoothTriangle(i + j * cols, i + j * cols + 1, i + (j + 1) * cols + 1)
                 				tri.T1 = tri.V1
                 				tri.T2 = tri.V2
                 				tri.T3 = tri.V3
                 				triangles.Add(tri)
                 				tri = New RichSmoothTriangle(i + j * cols, i + (j + 1) * cols + 1, i + (j + 1) * cols)
                 				tri.T1 = tri.V1
                 				tri.T2 = tri.V2
                 				tri.T3 = tri.V3
                 				triangles.Add(tri)
                 			Next
                 		Next
                 		surface.Vertices = vertices.ToArray()
                 		surface.Triangles = triangles.ToArray()
                 		surface.TextureCoords = texCoords.ToArray()
             
                 		surface.MaterialName = "test"
                 		surface.ColorMethod = colorMethodType.byEntity
             
                 		design.Entities.Add(surface, 0)
                 	End Sub
             
                 End Class
             End Namespace]]></code></example>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateBox(System.Double,System.Double,System.Double)">
      <summary>Creates a Box primitive.</summary>
      <param name="width">Box's width</param>
      <param name="depth">Box's depth</param>
      <param name="height">Box's height</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateBox``1(System.Double,System.Double,System.Double)">
      <summary>Creates a Box primitive.</summary>
      <param name="width">Box's width</param>
      <param name="depth">Box's depth</param>
      <param name="height">Box's height</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateBox(System.Double,System.Double,System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>Creates a Box primitive.</summary>v
            <param name="width">Box's width</param><param name="depth">Box's depth</param><param name="height">Box's height</param><param name="meshNature">Nature of the mesh</param><returns>The created mesh.</returns></member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateBox``1(System.Double,System.Double,System.Double,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>Creates a Box primitive.</summary>v
            <param name="width">Box's width</param><param name="depth">Box's depth</param><param name="height">Box's height</param><param name="meshNature">Nature of the mesh</param><returns>The created mesh.</returns></member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateBox(System.Double,System.Double,System.Double,devDept.Geometry.Entities.GMesh.natureType,devDept.Geometry.Entities.GMesh.edgeStyleType)">
      <summary>Creates a Box primitive.</summary>
      <param name="width">Box's width</param>
      <param name="depth">Box's depth</param>
      <param name="height">Box's height</param>
      <param name="meshNature">Nature of the mesh</param>
      <param name="edgeStyle">Style of the edges</param>
      <exception cref="T:System.Exception">
      </exception>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateBox``1(System.Double,System.Double,System.Double,devDept.Geometry.Entities.GMesh.natureType,devDept.Geometry.Entities.GMesh.edgeStyleType)">
      <summary>Creates a Box primitive.</summary>
      <param name="width">Box's width</param>
      <param name="depth">Box's depth</param>
      <param name="height">Box's height</param>
      <param name="meshNature">Nature of the mesh</param>
      <param name="edgeStyle">Style of the edges</param>
      <exception cref="T:System.Exception">
      </exception>
      <returns>The resulting GMesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCone(System.Double,System.Double,System.Double,System.Int32)">
      <summary>Creates a Cone primitive.</summary>
      <param name="baseRadius">Cone's base radius</param>
      <param name="topRadius">Cone's top radius</param>
      <param name="height">The cone's height</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
             /// <returns>The created mesh.</returns></member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCone``1(System.Double,System.Double,System.Double,System.Int32)">
      <summary>Creates a Cone primitive.</summary>
      <param name="baseRadius">Cone's base radius</param>
      <param name="topRadius">Cone's top radius</param>
      <param name="height">The cone's height</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
             /// <returns>The created mesh.</returns></member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCone(System.Double,System.Double,System.Double,System.Int32,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>Creates a Cone primitive.</summary>
      <param name="baseRadius">Cone's base radius</param>
      <param name="topRadius">Cone's top radius</param>
      <param name="height">The cone's height</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <param name="meshNature">Nature of the mesh</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCone``1(System.Double,System.Double,System.Double,System.Int32,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>Creates a Cone primitive.</summary>
      <param name="baseRadius">Cone's base radius</param>
      <param name="topRadius">Cone's top radius</param>
      <param name="height">The cone's height</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <param name="meshNature">Nature of the mesh</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCone(System.Double,System.Double,System.Double,System.Int32,devDept.Geometry.Entities.GMesh.natureType,devDept.Geometry.Entities.GMesh.edgeStyleType)">
      <summary>Creates a Cone primitive.</summary>
      <param name="baseRadius">Cone's base radius</param>
      <param name="topRadius">Cone's top radius</param>
      <param name="height">The cone's height</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <param name="meshNature">Nature of the mesh</param>
      <param name="edgeStyle">Style of the edges</param>
      <exception cref="T:System.Exception">
      </exception>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCone``1(System.Double,System.Double,System.Double,System.Int32,devDept.Geometry.Entities.GMesh.natureType,devDept.Geometry.Entities.GMesh.edgeStyleType)">
      <summary>Creates a Cone primitive.</summary>
      <param name="baseRadius">Cone's base radius</param>
      <param name="topRadius">Cone's top radius</param>
      <param name="height">The cone's height</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <param name="meshNature">Nature of the mesh</param>
      <param name="edgeStyle">Style of the edges</param>
      <exception cref="T:System.Exception">
      </exception>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCone(System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32)">
      <summary>Creates a Cone primitive.</summary>
      <param name="baseRadius">Cone's base radius</param>
      <param name="topRadius">Cone's top radius</param>
      <param name="point1">Cone''s first point</param>
      <param name="point2">Cone''s second point</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCone``1(System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32)">
      <summary>Creates a Cone primitive.</summary>
      <param name="baseRadius">Cone's base radius</param>
      <param name="topRadius">Cone's top radius</param>
      <param name="point1">Cone''s first point</param>
      <param name="point2">Cone''s second point</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCone(System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>Creates a Cone primitive.</summary>
      <param name="baseRadius">Cone's base radius</param>
      <param name="topRadius">Cone's top radius</param>
      <param name="point1">Cone''s first point</param>
      <param name="point2">Cone''s second point</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <param name="meshNature">Nature of the mesh</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCone``1(System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>Creates a Cone primitive.</summary>
      <param name="baseRadius">Cone's base radius</param>
      <param name="topRadius">Cone's top radius</param>
      <param name="point1">Cone''s first point</param>
      <param name="point2">Cone''s second point</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <param name="meshNature">Nature of the mesh</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCone(System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32,devDept.Geometry.Entities.GMesh.natureType,devDept.Geometry.Entities.GMesh.edgeStyleType)">
      <summary>Creates a Cone primitive.</summary>
      <param name="baseRadius">Cone's base radius</param>
      <param name="topRadius">Cone's top radius</param>
      <param name="point1">Cone''s first point</param>
      <param name="point2">Cone''s second point</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <param name="meshNature">Nature of the mesh</param>
      <param name="edgeStyle">Style of the edges</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCone``1(System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32,devDept.Geometry.Entities.GMesh.natureType,devDept.Geometry.Entities.GMesh.edgeStyleType)">
      <summary>Creates a Cone primitive.</summary>
      <param name="baseRadius">Cone's base radius</param>
      <param name="topRadius">Cone's top radius</param>
      <param name="point1">Cone''s first point</param>
      <param name="point2">Cone''s second point</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <param name="meshNature">Nature of the mesh</param>
      <param name="edgeStyle">Style of the edges</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreatePlanar(devDept.Geometry.Plane,System.Collections.Generic.IList{devDept.Geometry.Point2D},devDept.Geometry.Entities.GMesh.natureType)">
      <summary>Triangulates the specified 2D region.</summary>
      <param name="sketchPlane">Plane on which the points lay</param>
      <param name="outer">Outer contour of the region oriented counter-clockwise</param>
      <param name="meshNature">Nature of the GMesh</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreatePlanar``1(devDept.Geometry.Plane,System.Collections.Generic.IList{devDept.Geometry.Point2D},devDept.Geometry.Entities.GMesh.natureType)">
      <summary>Triangulates the specified 2D region.</summary>
      <param name="sketchPlane">Plane on which the points lay</param>
      <param name="outer">Outer contour of the region oriented counter-clockwise</param>
      <param name="meshNature">Nature of the GMesh</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreatePlanar(devDept.Geometry.Plane,System.Collections.Generic.IList{devDept.Geometry.Point2D},System.Collections.Generic.IList{System.Collections.Generic.IList{devDept.Geometry.Point2D}},devDept.Geometry.Entities.GMesh.natureType)">
      <summary>Triangulates the specified 2D region.</summary>
      <param name="sketchPlane">Plane on which the points lay</param>
      <param name="outer">Outer contour of the region oriented counter-clockwise</param>
      <param name="inners">The inner contour list oriented clockwise</param>
      <param name="meshNature">Nature of the GMesh</param>
      <returns>The created mesh.</returns>
      <exception cref="!:EyeshotException">Countours must be closed</exception>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreatePlanar``1(devDept.Geometry.Plane,System.Collections.Generic.IList{devDept.Geometry.Point2D},System.Collections.Generic.IList{System.Collections.Generic.IList{devDept.Geometry.Point2D}},devDept.Geometry.Entities.GMesh.natureType)">
      <summary>Triangulates the specified 2D region.</summary>
      <param name="sketchPlane">Plane on which the points lay</param>
      <param name="outer">Outer contour of the region oriented counter-clockwise</param>
      <param name="inners">The inner contour list oriented clockwise</param>
      <param name="meshNature">Nature of the GMesh</param>
      <returns>The created mesh.</returns>
      <exception cref="!:EyeshotException">Countours must be closed</exception>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreatePlanar(System.Collections.Generic.IList{devDept.Geometry.Point3D},devDept.Geometry.Entities.GMesh.natureType)">
      <summary>Triangulates the specified 3D region.</summary>
      <example>
            The following example demonstrate how to draw a face on the ZX plane.
            <code lang="CS" title="C#">
            List&lt;Point3D&gt; outer = new List&lt;Point3D&gt;();
            
            outer.Add(new Point3D(0, 0, 0));
            outer.Add(new Point3D(10, 0, 0));
            outer.Add(new Point3D(20, 0, -5));
            outer.Add(new Point3D(10, 0, 20));
            outer.Add(new Point3D(0, 0, 20));
            outer.Add(new Point3D(-10, 0, -5));
            outer.Add(new Point3D(0, 0, 0));
            GMesh m = GMesh.CreatePlanar(outer, GMesh.natureType.Plain);
            m.Color = Color.Firebrick;
            m.ColorMethod = colorMethodType.byEntity;
            
            viewportProfessional1.Entities.Add(m);
            </code><code lang="VB" title="Visual Basic">
            Dim outer As List(of Point3D) = New List(of Point3D);
            
            outer.Add(New Point3D(0, 0, 0))
            outer.Add(New Point3D(10, 0, 0))
            outer.Add(New Point3D(20, 0, -5))
            outer.Add(New Point3D(10, 0, 20))
            outer.Add(New Point3D(0, 0, 20))
            outer.Add(New Point3D(-10, 0, -5))
            outer.Add(New Point3D(0, 0, 0))
            
            Dim m As GMesh = GMesh.CreatePlanar(outer, GMesh.natureType.Plain)
            m.Color = Color.Firebrick
            m.ColorMethod = colorMethodType.byEntity
            
            viewportProfessional1.Entities.Add(m)
            </code></example>
      <param name="outer">Outer contour of the region oriented counter-clockwise</param>
      <param name="meshNature">Nature of the GMesh</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreatePlanar``1(System.Collections.Generic.IList{devDept.Geometry.Point3D},devDept.Geometry.Entities.GMesh.natureType)">
      <summary>Triangulates the specified 3D region.</summary>
      <example>
            The following example demonstrate how to draw a face on the ZX plane.
            <code lang="CS" title="C#">
            List&lt;Point3D&gt; outer = new List&lt;Point3D&gt;();
            
            outer.Add(new Point3D(0, 0, 0));
            outer.Add(new Point3D(10, 0, 0));
            outer.Add(new Point3D(20, 0, -5));
            outer.Add(new Point3D(10, 0, 20));
            outer.Add(new Point3D(0, 0, 20));
            outer.Add(new Point3D(-10, 0, -5));
            outer.Add(new Point3D(0, 0, 0));
            GMesh m = GMesh.CreatePlanar(outer, GMesh.natureType.Plain);
            m.Color = Color.Firebrick;
            m.ColorMethod = colorMethodType.byEntity;
            
            viewportProfessional1.Entities.Add(m);
            </code><code lang="VB" title="Visual Basic">
            Dim outer As List(of Point3D) = New List(of Point3D);
            
            outer.Add(New Point3D(0, 0, 0))
            outer.Add(New Point3D(10, 0, 0))
            outer.Add(New Point3D(20, 0, -5))
            outer.Add(New Point3D(10, 0, 20))
            outer.Add(New Point3D(0, 0, 20))
            outer.Add(New Point3D(-10, 0, -5))
            outer.Add(New Point3D(0, 0, 0))
            
            Dim m As GMesh = GMesh.CreatePlanar(outer, GMesh.natureType.Plain)
            m.Color = Color.Firebrick
            m.ColorMethod = colorMethodType.byEntity
            
            viewportProfessional1.Entities.Add(m)
            </code></example>
      <param name="outer">Outer contour of the region oriented counter-clockwise</param>
      <param name="meshNature">Nature of the GMesh</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreatePlanar(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{System.Collections.Generic.IList{devDept.Geometry.Point3D}},devDept.Geometry.Entities.GMesh.natureType)">
      <summary>Triangulates the specified 3D region.</summary>
      <param name="outer">Outer contour of the region oriented counter-clockwise</param>
      <param name="inners">The inner contour list oriented clockwise</param>
      <param name="meshNature">Nature of the GMesh</param>
      <returns>The created mesh.</returns>
      <exception cref="!:EyeshotException">Countours must be closed</exception>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreatePlanar``1(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{System.Collections.Generic.IList{devDept.Geometry.Point3D}},devDept.Geometry.Entities.GMesh.natureType)">
      <summary>Triangulates the specified 3D region.</summary>
      <param name="outer">Outer contour of the region oriented counter-clockwise</param>
      <param name="inners">The inner contour list oriented clockwise</param>
      <param name="meshNature">Nature of the GMesh</param>
      <returns>The created mesh.</returns>
      <exception cref="!:EyeshotException">Countours must be closed</exception>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.#ctor">
      <summary>
            Empty constructor. For internal use only. <see cref="T:devDept.Geometry.Entities.GMesh.natureType">GMesh nature</see> is set to Plain.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.#ctor(System.Int32,System.Int32,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Vertices and triangles sizes constructor.
            </summary>
      <param name="numVertices">Number of vertices the mesh will hold</param>
      <param name="numTriangles">Number of triangles the mesh will hold</param>
      <param name="meshNature">The mesh nature</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.#ctor(devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            GMesh nature constructor.
            </summary>
      <param name="meshNature">The mesh nature</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.#ctor(devDept.Geometry.Entities.GMesh.natureType,devDept.Geometry.Entities.GMesh.edgeStyleType)">
      <summary>
            GMesh nature and edge style constructor.
            </summary>
      <param name="meshNature">The mesh nature</param>
      <param name="edgeStyle">The edge style</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.#ctor(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{devDept.Geometry.IndexTriangle})">
      <summary>
            Vertices and triangles constructor.
            </summary>
      <param name="vertices">The vertices list</param>
      <param name="triangles">The triangles list</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.Clone">
      <summary>
            Creates a deep copy of this mesh entity.
            </summary>
      <returns>The new mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.IsPointInside(devDept.Geometry.Point3D)">
      <summary>
            Checks if the specified point is inside the 3D mesh.
            </summary>
      <param name="point">The 3D point</param>
      <returns>True if the 3D point is inside the mesh, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CutBy(devDept.Geometry.Plane)">
      <summary>Cuts the part of the mesh on the positive side of a plane.
             </summary>
      <param name="plane">The plane</param>
      <returns>The intersection failure type.</returns>
      <remarks>If the operation is <see cref="F:devDept.Geometry.booleanFailureType.Success" /> the object is modified, otherwise the original object is unmutated.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CutBy(devDept.Geometry.Plane,System.Boolean)">
      <summary>Cuts the part of the mesh on the positive side of a plane.
             </summary>
      <param name="plane">The plane</param>
      <param name="close">If false, the resulting mesh will not be closed</param>
      <returns>The intersection failure type.</returns>
      <remarks>If the operation is <see cref="F:devDept.Geometry.booleanFailureType.Success" /> the object is modified, otherwise the original object is unmutated.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.UpdateNormals">
      <summary>
            Refreshes triangles normals.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.ComputeEdges">
      <summary>
            Forces mesh edges computation according to the <see cref="P:devDept.Geometry.Entities.GMesh.EdgeStyle" /> settings.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.FlipOutward">
      <summary>
            Flips the mesh normals outward.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.TransformBy(devDept.Geometry.Transformation)">
      <summary>
            Transforms all the entity's vertices by the specified transformation. 
            </summary>
      <remarks>In case of Mirror transformation you may need to flip triangles and call <see cref="M:devDept.Geometry.Entities.GMesh.UpdateNormals" />.</remarks>
      <param name="transform">The transformation to be applied</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.ConvertToSolid">
      <summary>
             Converts this mesh to a <see cref="T:devDept.Geometry.Entities.GSolid" /> object.
            </summary>
      <returns>The resulting solid if the operation is successful, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.ConvertToSolid``1">
      <summary>
             Converts this mesh to a <see cref="T:devDept.Geometry.Entities.GSolid" /> object.
            </summary>
      <returns>The resulting solid if the operation is successful, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.Weld">
      <summary>
            Removes duplicated vertices and degenerated triangles in the GMesh.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.Weld(System.Double,System.Boolean)">
      <summary>
            Removes duplicated vertices and degenerated triangles in the GMesh with a given tolerance.
            </summary>
      <param name="maxGap">The maximum distance for considering two vertices equal.</param>
      <param name="updateEdges">When true, also the edges are updated with the new vertices indices, otherwise <see cref="P:devDept.Geometry.Entities.GMesh.Edges" /> is cleared. Used for internal purpose.</param>
      <seealso cref="M:devDept.Geometry.Entities.GMesh.WeldFreeEdges(System.Double)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.WeldFreeEdges(System.Double)">
      <summary>
            Removes duplicated vertices and degenerated triangles in the GMesh skipping internal vertices.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GMesh.Weld(System.Double,System.Boolean)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.WeldFreeEdges">
      <summary>
            Removes duplicated vertices and degenerated triangles in the GMesh skipping internal vertices.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GMesh.Weld(System.Double,System.Boolean)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.WeldVectors(devDept.Geometry.Point3D[],System.Int32@,System.Double,System.Int32[]@)">
      <summary>
            Welds the array of Point3ds.
            </summary>
      <param name="numVectors">
      </param>
      <param name="maxGap">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.FindClosestTriangle(devDept.Geometry.Transformation,devDept.Geometry.Segment3D)">
      <summary>
            Returns a list of triangles hit by the provided segment.
            </summary>
      <param name="transf">The transformation applied to the entity (necessary if the entity is inside a Block to propagate the BlockReference transformation)</param>
      <param name="seg">The 3D segment representing the viewing direction</param>
      <returns>The sorted list of triangles intersecting the provided segment.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.FromTriangles(devDept.Geometry.Point3D[])">
      <summary>
             Generates a smooth GMesh from a list of triangles.
            </summary>
      <param name="v">A list of triangle vertices</param>
    </member>
    <member name="P:devDept.Geometry.Entities.GMesh.IsClosed">
      <summary>Tells if a mesh is closed.
            </summary>
      <returns>True if the mesh is closed.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GMesh.LightWeight">
      <summary>
            When true, mesh edges are not computed. To be used with huge meshes.
            </summary>
    </member>
    <member name="T:devDept.Geometry.Entities.GMesh.natureType">
      <summary>GMesh nature type.</summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GMesh.natureType.Undefined">
      <summary>
            Not yet defined
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GMesh.natureType.Plain">
      <summary>
            Plain mesh (one normal per triangle), one color shared by all triangles 
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GMesh.natureType.ColorPlain">
      <summary>
            Plain mesh (one normal per triangle), one different color for each triangle
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GMesh.natureType.MulticolorPlain">
      <summary>
            Plain mesh (one normal per triangle), one color for each vertex
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GMesh.natureType.RichPlain">
      <summary>
            Plain mesh (one normal per triangle), one material for each triangle
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GMesh.natureType.Smooth">
      <summary>
            Smooth mesh (one normal per vertex), one color shared by all triangles
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GMesh.natureType.ColorSmooth">
      <summary>
            Smooth mesh (one normal per vertex), one different color for each triangle
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GMesh.natureType.MulticolorSmooth">
      <summary>
            Smooth mesh (one normal per vertex), one color for each vertex
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GMesh.natureType.RichSmooth">
      <summary>
            Smooth mesh (one normal per vertex), one material for each triangle
            </summary>
    </member>
    <member name="T:devDept.Geometry.Entities.GMesh.normalAveragingType">
      <summary>GMesh normal averaging type.</summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GMesh.normalAveragingType.Averaged">
      <summary>
            Averaged normal
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GMesh.normalAveragingType.AveragedByAngle">
      <summary>
            Averaged normal with preservation of edges
            </summary>
    </member>
    <member name="T:devDept.Geometry.Entities.GMesh.edgeStyleType">
      <summary>GMesh edge style type.</summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GMesh.edgeStyleType.None">
      <summary>
            No edges are computed
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GMesh.edgeStyleType.Free">
      <summary>
            Only free edges are computed
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GMesh.edgeStyleType.Sharp">
      <summary>
            Only sharp edges are computed
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.GetFaceTriangles(System.Int32,System.Double)">
      <summary>
            Gets the triangles adjacent to the given triangle.
            </summary>
      <param name="triangleIndex">The triangle index</param>
      <param name="adjacentNormalAngle">The angle (in radians) used to compare two adjacent triangles normals. If the angle between them is below this value, the triangles are considered belonging to the same face.</param>
      <returns>The list of adjacent triangles.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.ConvertToMesh(devDept.Geometry.Entities.GMesh.natureType,System.Int32)">
      <summary>
             Converts the mesh with the specified GMesh <see cref="T:devDept.Geometry.Entities.GMesh.natureType">nature</see>.
            </summary>
      <param name="nature">The desired GMesh <see cref="T:devDept.Geometry.Entities.GMesh.natureType">nature</see></param>
      <param name="argbColor"> The color assigned to vertices or triangles depending on the GMesh <see cref="T:devDept.Geometry.Entities.GMesh.natureType">nature</see>.</param>
      <returns>The resulting converted gMesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCylinder(System.Double,System.Double,System.Int32)">
      <summary>
            Creates a Cylinder primitive.
            </summary>
      <param name="radius">Cylinder's radius</param>
      <param name="height">Cylinder's height</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCylinder``1(System.Double,System.Double,System.Int32)">
      <summary>
            Creates a Cylinder primitive.
            </summary>
      <param name="radius">Cylinder's radius</param>
      <param name="height">Cylinder's height</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCylinder(System.Double,System.Double,System.Int32,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
             Creates a Cylinder primitive.
             </summary>
      <param name="radius">Cylinder's radius</param>
      <param name="height">Cylinder's height</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <param name="meshNature">Nature of the mesh</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCylinder``1(System.Double,System.Double,System.Int32,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
             Creates a Cylinder primitive.
             </summary>
      <param name="radius">Cylinder's radius</param>
      <param name="height">Cylinder's height</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <param name="meshNature">Nature of the mesh</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCylinder(System.Double,System.Double,System.Int32,devDept.Geometry.Entities.GMesh.natureType,devDept.Geometry.Entities.GMesh.edgeStyleType)">
      <summary>
             Creates a Cylinder primitive.
             </summary>
      <param name="radius">Cylinder's radius</param>
      <param name="height">Cylinder's height</param>
      <param name="meshNature">Nature of the mesh</param>
      <param name="edgeStyle">Style of the edges</param>
      <exception cref="T:System.Exception">
      </exception>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCylinder``1(System.Double,System.Double,System.Int32,devDept.Geometry.Entities.GMesh.natureType,devDept.Geometry.Entities.GMesh.edgeStyleType)">
      <summary>
             Creates a Cylinder primitive.
             </summary>
      <param name="radius">Cylinder's radius</param>
      <param name="height">Cylinder's height</param>
      <param name="meshNature">Nature of the mesh</param>
      <param name="edgeStyle">Style of the edges</param>
      <exception cref="T:System.Exception">
      </exception>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCylinder(System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32)">
      <summary>Creates a Cylinder primitive.
            </summary>
      <param name="radius">Cylinder's radius</param>
      <param name="point1">Cylinder's first point</param>
      <param name="point2">Cylinder's second point</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCylinder``1(System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32)">
      <summary>Creates a Cylinder primitive.
            </summary>
      <param name="radius">Cylinder's radius</param>
      <param name="point1">Cylinder's first point</param>
      <param name="point2">Cylinder's second point</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCylinder(System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>Creates a Cylinder primitive.
            </summary>
      <param name="radius">Cylinder's radius</param>
      <param name="point1">Cylinder's first point</param>
      <param name="point2">Cylinder's second point</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <param name="meshNature">Nature of the mesh</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCylinder``1(System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>Creates a Cylinder primitive.
            </summary>
      <param name="radius">Cylinder's radius</param>
      <param name="point1">Cylinder's first point</param>
      <param name="point2">Cylinder's second point</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <param name="meshNature">Nature of the mesh</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCylinder(System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32,devDept.Geometry.Entities.GMesh.natureType,devDept.Geometry.Entities.GMesh.edgeStyleType)">
      <summary>Creates a Cylinder primitive.
            </summary>
      <param name="radius">Cylinder's radius</param>
      <param name="point1">Cylinder's first point</param>
      <param name="point2">Cylinder's second point</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <param name="meshNature">Nature of the mesh</param>
      <param name="edgeStyle">Style of the edges</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateCylinder``1(System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32,devDept.Geometry.Entities.GMesh.natureType,devDept.Geometry.Entities.GMesh.edgeStyleType)">
      <summary>Creates a Cylinder primitive.
            </summary>
      <param name="radius">Cylinder's radius</param>
      <param name="point1">Cylinder's first point</param>
      <param name="point2">Cylinder's second point</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <param name="meshNature">Nature of the mesh</param>
      <param name="edgeStyle">Style of the edges</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.MergeWith(devDept.Geometry.Entities.GMesh,System.Boolean,System.Boolean)">
      <summary>
            Merges two compatible GMesh objects.
            </summary>
      <param name="mesh">The other GMesh object</param>
      <param name="weldNow">If true, the two meshes are welded immediately.</param>
      <param name="recomputeEdges">If true, recomputes the edges else it preserves the edges of both meshes</param>
      <remarks>If you need to merge several meshes it's far more efficient to weld them only at the last MergeWith call.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.MergeWith(devDept.Geometry.Entities.GQuad,System.Boolean)">
      <summary>
            Merges the mesh with a <see cref="T:devDept.Geometry.Entities.GQuad" /> entity that shares an edge with the mesh.
            </summary>
      <param name="quad">The <see cref="T:devDept.Geometry.Entities.GQuad" /> entity</param>
      <param name="weldNow">If true, the two meshes are welded immediately.</param>
      <remarks>If you need to merge several entities it is far more efficient to weld them only at the last MergeWith.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.MergeWith(devDept.Geometry.Entities.GQuad)">
      <summary>
            Merges the mesh with a <see cref="T:devDept.Geometry.Entities.GQuad" /> entity that shares an edge with the mesh.
            </summary>
      <param name="quad">The <see cref="T:devDept.Geometry.Entities.GQuad" /> entity to merge</param>
      <remarks>If you need to merge several entities it is far more efficient to weld them only at the last MergeWith.</remarks>
      <seealso cref="M:devDept.Geometry.Entities.GMesh.MergeWith(devDept.Geometry.Entities.GQuad,System.Boolean)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.MergeWith(devDept.Geometry.Entities.GTriangle,System.Boolean)">
      <summary>
            Merges the mesh with a <see cref="T:devDept.Geometry.Entities.GTriangle" /> entity that shares an edge with the mesh.
            </summary>
      <param name="triangle">The <see cref="T:devDept.Geometry.Entities.GTriangle" /> entity to merge</param>
      <param name="weldNow">If true, the two meshes are welded immediately.</param>
      <remarks>If you need to merge several entities it is far more efficient to weld them only at the last MergeWith.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.MergeWith(devDept.Geometry.Entities.GTriangle)">
      <summary>
            Merges the mesh with a <see cref="T:devDept.Geometry.Entities.GQuad" /> entity that shares an edge with the mesh.
            </summary>
      <param name="triangle">The <see cref="T:devDept.Geometry.Entities.GTriangle" /> entity</param>
      <remarks>If you need to merge several entities it is far more efficient to weld them only at the last MergeWith.</remarks>
      <seealso cref="M:devDept.Geometry.Entities.GMesh.MergeWith(devDept.Geometry.Entities.GTriangle,System.Boolean)" />
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.ExtrudePlanar(devDept.Geometry.Vector3D)">
      <summary>
            Extrudes a quasi-planar mesh.
            </summary>
      <param name="amount">Extrusion amount</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.ExtrudePlanar(System.Double,System.Double,System.Double)">
      <summary>
            Extrudes a quasi-planar mesh.
            </summary>
      <param name="dx">Extrusion amount along the X axis</param>
      <param name="dy">Extrusion amount along the Y axis</param>
      <param name="dz">Extrusion amount along the Z axis</param>
    </member>
    <member name="P:devDept.Geometry.Entities.GMesh.Vertices">
      <summary>
            Gets or sets mesh' 3D vertices.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GMesh.Triangles">
      <summary>
            Gets or sets the mesh triangles.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GMesh.Edges">
      <summary>
            Direct access to <see cref="T:devDept.Geometry.Entities.GMesh" /> edges.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GMesh.NormalAveragingMode">
      <summary>
            Gets or sets the normal averaging prevMode.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GMesh.SmoothingAngle">
      <summary>
            Gets or sets the angular value (in radians) used by normal averaging and sharp edges calculation.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GMesh.EdgeStyle">
      <summary>
            Gets or sets the edge style. This setting comes into play during GMesh regeneration only.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GMesh.Normals">
      <summary>
            Gets or sets the mesh normals.
            </summary>
      <remarks>The number of normals depends on the <see cref="P:devDept.Geometry.Entities.GMesh.MeshNature" />.</remarks>
    </member>
    <member name="P:devDept.Geometry.Entities.GMesh.MeshNature">
      <summary>
            Gets mesh nature.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GMesh.TextureCoords">
      <summary>
            Gets or sets mesh texture coordinates.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.RevolvePlanar(System.Double,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Int32,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
             Revolves a quasi-planar mesh. 
             </summary>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axis">Axis direction</param>
      <param name="center">Axis start point</param>
      <param name="slices">Number of slices generated. This value can be also found using <see cref="M:devDept.Geometry.Utility.NumberOfSegments(System.Double,System.Double,System.Double,System.Double)" /></param>
      <param name="natureType">The nature of the mesh</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateSphere(System.Double,System.Int32,System.Int32)">
      <summary>
            Creates a Sphere primitive.
            </summary>
      <param name="radius">Sphere's radius</param>
      <param name="slices">Number of slices</param>
      <param name="stacks">Numer of stacks</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateSphere(System.Double,System.Int32,System.Int32,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
             Creates a Sphere primitive.
             </summary>
      <param name="radius">Sphere's radius</param>
      <param name="slices">Number of slices</param>
      <param name="stacks">Numer of stacks</param>
      <param name="meshNature">Nature of the mesh</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateSphere``1(System.Double,System.Int32,System.Int32)">
      <summary>
            Creates a Sphere primitive.
            </summary>
      <param name="radius">Sphere's radius</param>
      <param name="slices">Number of slices</param>
      <param name="stacks">Numer of stacks</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateSphere``1(System.Double,System.Int32,System.Int32,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
             Creates a Sphere primitive.
             </summary>
      <param name="radius">Sphere's radius</param>
      <param name="slices">Number of slices</param>
      <param name="stacks">Numer of stacks</param>
      <param name="meshNature">Nature of the mesh</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.MergeMeshes(devDept.Geometry.Entities.GMesh[],devDept.Geometry.Entities.GMesh.natureType,System.Boolean)">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateTorus(System.Double,System.Double,System.Int32,System.Int32)">
      <summary>
             Creates a Torus primitive.
             </summary>
      <param name="majorRadius">Torus radius</param>
      <param name="minorRadius">Torus section radius</param>
      <param name="sides">Number of sides</param>
      <param name="rings">Number of rings</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateTorus``1(System.Double,System.Double,System.Int32,System.Int32)">
      <summary>
             Creates a Torus primitive.
             </summary>
      <param name="majorRadius">Torus radius</param>
      <param name="minorRadius">Torus section radius</param>
      <param name="sides">Number of sides</param>
      <param name="rings">Number of rings</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateTorus(System.Double,System.Double,System.Int32,System.Int32,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
             Creates a Torus primitive.
             </summary>
      <param name="majorRadius">Torus radius</param>
      <param name="minorRadius">Torus section radius</param>
      <param name="sides">Number of sides</param>
      <param name="rings">Number of rings</param>
      <param name="meshNature">Nature of the mesh</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateTorus``1(System.Double,System.Double,System.Int32,System.Int32,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
             Creates a Torus primitive.
             </summary>
      <param name="majorRadius">Torus radius</param>
      <param name="minorRadius">Torus section radius</param>
      <param name="sides">Number of sides</param>
      <param name="rings">Number of rings</param>
      <param name="meshNature">Nature of the mesh</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateArrow(System.Double,System.Double,System.Double,System.Double,System.Int32,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
             Creates a 3D arrow primitive.
             </summary>
      <param name="cylRadius">Arrow's cylinder radius</param>
      <param name="cylLength">Arrow's cylinder length</param>
      <param name="coneRadius">Arrow's cone radius</param>
      <param name="coneLength">Arrow's cone length</param>
      <param name="slices">Number of slices</param>
      <param name="meshNature">Nature of the mesh</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateArrow``1(System.Double,System.Double,System.Double,System.Double,System.Int32,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
             Creates a 3D arrow primitive.
             </summary>
      <param name="cylRadius">Arrow's cylinder radius</param>
      <param name="cylLength">Arrow's cylinder length</param>
      <param name="coneRadius">Arrow's cone radius</param>
      <param name="coneLength">Arrow's cone length</param>
      <param name="slices">Number of slices</param>
      <param name="meshNature">Nature of the mesh</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateArrow(System.Double,System.Double,System.Double,System.Double,System.Int32,devDept.Geometry.Entities.GMesh.natureType,devDept.Geometry.Entities.GMesh.edgeStyleType)">
      <summary>
             Creates a 3D arrow primitive.
             </summary>
      <param name="cylRadius">Arrow's cylinder radius</param>
      <param name="cylLength">Arrow's cylinder length</param>
      <param name="coneRadius">Arrow's cone radius</param>
      <param name="coneLength">Arrow's cone length</param>
      <param name="slices">Number of slices</param>
      <param name="meshNature">Nature of the mesh</param>
      <param name="edgeStyle">Style of the edges</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateArrow``1(System.Double,System.Double,System.Double,System.Double,System.Int32,devDept.Geometry.Entities.GMesh.natureType,devDept.Geometry.Entities.GMesh.edgeStyleType)">
      <summary>
             Creates a 3D arrow primitive.
             </summary>
      <param name="cylRadius">Arrow's cylinder radius</param>
      <param name="cylLength">Arrow's cylinder length</param>
      <param name="coneRadius">Arrow's cone radius</param>
      <param name="coneLength">Arrow's cone length</param>
      <param name="slices">Number of slices</param>
      <param name="meshNature">Nature of the mesh</param>
      <param name="edgeStyle">Style of the edges</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateArrow(devDept.Geometry.Point3D,devDept.Geometry.Vector3D,System.Double,System.Double,System.Double,System.Double,System.Int32,devDept.Geometry.Entities.GMesh.natureType,devDept.Geometry.Entities.GMesh.edgeStyleType)">
      <summary>
             Creates a 3D arrow primitive.
             </summary>
      <param name="startPoint">Arrow's start point</param>
      <param name="direction">Arrow's direction</param>
      <param name="cylRadius">Arrow's cylinder radius</param>
      <param name="cylLength">Arrow's cylinder length</param>
      <param name="coneRadius">Arrow's cone radius</param>
      <param name="coneLength">Arrow's cone length</param>
      <param name="slices">Number of slices</param>
      <param name="meshNature">Nature of the mesh</param>
      <param name="edgeStyle">Style of the edges</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateArrow``1(devDept.Geometry.Point3D,devDept.Geometry.Vector3D,System.Double,System.Double,System.Double,System.Double,System.Int32,devDept.Geometry.Entities.GMesh.natureType,devDept.Geometry.Entities.GMesh.edgeStyleType)">
      <summary>
             Creates a 3D arrow primitive.
             </summary>
      <param name="startPoint">Arrow's start point</param>
      <param name="direction">Arrow's direction</param>
      <param name="cylRadius">Arrow's cylinder radius</param>
      <param name="cylLength">Arrow's cylinder length</param>
      <param name="coneRadius">Arrow's cone radius</param>
      <param name="coneLength">Arrow's cone length</param>
      <param name="slices">Number of slices</param>
      <param name="meshNature">Nature of the mesh</param>
      <param name="edgeStyle">Style of the edges</param>
      <returns>The created mesh.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateSpring(System.Double,System.Double,System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
      <summary>Creates a Spring primitive.</summary>
      <param name="radius">Spring radius</param>
      <param name="wireRadius">Wire radius</param>
      <param name="sides">Number of subdivision sides</param>
      <param name="rings">Number of subdivision rings per turn</param>
      <param name="pitch">Height of each complete turn</param>
      <param name="turns">Number of turns</param>
      <param name="reverseTwist">Reverse direction</param>
      <returns>The resulting mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateSpring``1(System.Double,System.Double,System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
      <summary>Creates a Spring primitive.</summary>
      <param name="radius">Spring radius</param>
      <param name="wireRadius">Wire radius</param>
      <param name="sides">Number of subdivision sides</param>
      <param name="rings">Number of subdivision rings per turn</param>
      <param name="pitch">Height of each complete turn</param>
      <param name="turns">Number of turns</param>
      <param name="reverseTwist">Reverse direction</param>
      <returns>The resulting mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateSpring(System.Double,System.Double,System.Int32,System.Int32,System.Double,System.Double,System.Boolean,System.Boolean,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>Creates a Spring primitive.</summary>
      <param name="radius">Spring radius</param>
      <param name="wireRadius">Wire radius</param>
      <param name="sides">Number of subdivision sides</param>
      <param name="rings">Number of subdivision rings per turn</param>
      <param name="pitch">Height of each complete turn</param>
      <param name="turns">Number of turns</param>
      <param name="reverseTwist">Reverse direction</param>
      <param name="closed">Closing caps on both ends</param>
      <param name="meshNature">Nature of the resulting mesh entity</param>
      <returns>The resulting mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.CreateSpring``1(System.Double,System.Double,System.Int32,System.Int32,System.Double,System.Double,System.Boolean,System.Boolean,devDept.Geometry.Entities.GMesh.natureType)">
      <summary>Creates a Spring primitive.</summary>
      <param name="radius">Spring radius</param>
      <param name="wireRadius">Wire radius</param>
      <param name="sides">Number of subdivision sides</param>
      <param name="rings">Number of subdivision rings per turn</param>
      <param name="pitch">Height of each complete turn</param>
      <param name="turns">Number of turns</param>
      <param name="reverseTwist">Reverse direction</param>
      <param name="closed">Closing caps on both ends</param>
      <param name="meshNature">Nature of the resulting mesh entity</param>
      <returns>The resulting mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.Section(devDept.Geometry.Plane,System.Double)">
      <summary>
             Computes the contours resulting from the intersection of the face and the given plane.
            </summary>
      <param name="plane">The plane</param>
      <param name="tol">The tolerance</param>
      <returns>An array of curves representing each section contour.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.Section(devDept.Geometry.Plane,System.Double,System.Collections.Generic.LinkedList{devDept.Geometry.SharedEdge}[])">
      <summary>
            Computes the contours resulting from the intersection of the face and the given plane.
            </summary>
      <param name="plane">The plane</param>
      <param name="tol">The tolerance</param>
      <param name="edgesPerVertex">Pre-computed GMesh unique edges per vertices, not used if the mesh has octree's data</param>
      <returns>An array of curves representing each section contour.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.Section(devDept.Geometry.PlaneEquation,System.Collections.Generic.LinkedList{devDept.Geometry.SharedEdge}[])">
      <summary>
            Computes the contours resulting from the intersection of the GMesh and the given plane.
            </summary>
      <param name="planeEquation">The cutting plane equation</param>
      <param name="edgesPerVertex">Pre-computed GMesh unique edges per vertices, not used if the mesh has octree's data</param>
      <returns>An array of curves representing each section contour.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.Section(devDept.Geometry.Plane,System.Double,devDept.Geometry.SharedEdge[][]@)">
      <summary>
            Computes the contours resulting from the intersection of the face and the given plane.
            </summary>
      <param name="plane">The plane</param>
      <param name="tol">The tolerance</param>
      <param name="edges">The shared edges to which the vertices of the returned <see cref="T:devDept.Geometry.Entities.IGCurve" /> (that are all <see cref="!:LinearPath" />) belong to. Null if the mesh has octree's data.</param>
      <returns>An array of curves representing each section contour.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.Section(devDept.Geometry.PlaneEquation,devDept.Geometry.SharedEdge[][]@)">
      <summary>Computes the contours resulting from the intersection of the GMesh and the given plane.
            </summary>
      <param name="planeEquation">The cutting plane equation</param>
      <param name="edges">The shared edges to which the vertices of the returned <see cref="T:devDept.Geometry.Entities.IGCurve" /> (that are all <see cref="!:LinearPath" />) belong to. Null if the mesh has octree's data.</param>
      <returns>An array of curves representing each section contour.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.SplitDisjoint">
      <summary>
            Divides into separate objects meshes that do not connect, but are still one object.
            </summary>
      <returns>The resulting GMesh objects.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.FixNormals">
      <summary>
            Makes triangles winding order uniform.
            </summary>
      <returns>Number of flipped triangles.</returns>
      <seealso cref="M:devDept.Geometry.Entities.GMesh.FlipNormal" />
      <seealso cref="M:devDept.Geometry.Entities.GMesh.FlipOutward" />
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.SplitBy(devDept.Geometry.Plane,devDept.Geometry.Entities.GMesh[]@)">
      <summary>
            Splits this GMesh object by plane.
            </summary>
      <param name="plane">The splitting plane</param>
      <param name="splits">Array of new Meshes created by splitting</param>
      <returns>The intersection failure type.</returns>
      <remarks>If the operation is <see cref="F:devDept.Geometry.booleanFailureType.Success" /> returns an array of the split objects, otherwise it exits at the first failure.</remarks>
      <seealso cref="M:devDept.Geometry.Entities.GMesh.SplitDisjoint" />
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.SplitBy(devDept.Geometry.Plane,System.Boolean,devDept.Geometry.Entities.GMesh[]@)">
      <summary>
            Splits this GMesh object by plane.
            </summary>
      <param name="plane">The splitting plane</param>
      <param name="splitDisjoint">When true, disjoint objects are separated into individual meshes</param>
      <param name="splits">Array of new Meshes created by splitting</param>
      <returns>The intersection failure type.</returns>
      <remarks>If the operation is <see cref="F:devDept.Geometry.booleanFailureType.Success" /> returns an array of the split objects, otherwise it exits at the first failure.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.SubdivideBy(devDept.Geometry.Plane)">
      <summary>
            Subdivides the mesh by a plane. For geometrical use only.
            </summary>
      <param name="plane">The subdivision plane</param>
      <returns>A <see cref="T:devDept.Geometry.booleanFailureType" /> telling if the operation was successful.</returns>
      <remarks>If the number of triangles doesn't change, the plane is passing through the mesh but is not cutting any triangle edge because some vertices are exactly on the plane.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.ApplyTextureMapping(devDept.Geometry.textureMappingType,System.Double,System.Double)">
      <summary>
            Maps the specified material to this mesh. Before using this method you need to define a material and add it to the Design Materials collection.
            </summary>
      <remarks>
        <para>The mesh nature is set to RichPlain or RichSmooth from this command.</para>
        <para>You may need to call viewport.Entities.Regen() to see the effect of this command.</para>
      </remarks>
      <param name="mappingMode">Indicates the way Material texture is wrapped on the object</param>
      <param name="scaleX">Material texture scale along the X axis</param>
      <param name="scaleY">Material texture scale along the Y axis</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.ApplyTextureMapping(devDept.Geometry.textureMappingType,System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Maps the specified material to this mesh using a custom bounding box. Before using this method you need to define a material and add it to the Design Materials collection.
            </summary>
      <remarks>
        <para>The mesh nature is set to RichPlain or RichSmooth from this command.</para>
        <para>You may need to call viewport.Entities.Regen() to see the effect of this command.</para>
      </remarks>
      <param name="mappingMode">Indicates the way Material texture is wrapped on the object</param>
      <param name="scaleX">Material texture scale along the X axis</param>
      <param name="scaleY">Material texture scale along the Y axis</param>
      <param name="boxMin">Bounding box min point</param>
      <param name="boxMax">Bounding box max point</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.ApplyTextureMapping(devDept.Eyeshot.TextureMappingData)">
      <summary>
            Maps the specified material to this mesh using a custom bounding box. Before using this method you need to define a material and add it to the Design Materials collection.
            </summary>
      <remarks>
        <para>The mesh nature is set to RichPlain or RichSmooth from this command.</para>
        <para>You may need to call viewport.Entities.Regen() to see the effect of this command.</para>
      </remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.ApplyTextureMapping(devDept.Geometry.textureMappingType,System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Transformation)">
      <summary>
            Maps the specified material to this mesh using a custom bounding box. Before using this method you need to define a material and add it to the Design Materials collection.
            </summary>
      <remarks>
        <para>The mesh nature is set to RichPlain or RichSmooth from this command.</para>
        <para>You may need to call viewport.Entities.Regen() to see the effect of this command.</para>
      </remarks>
      <param name="mappingMode">Indicates the way Material texture is wrapped on the object</param>
      <param name="scaleX">Material texture scale along the X axis</param>
      <param name="scaleY">Material texture scale along the Y axis</param>
      <param name="boxMin">Bounding box min point</param>
      <param name="boxMax">Bounding box max point</param>
      <param name="transformation">Transformation to apply to the mapping</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GMesh.RemoveTextureMapping">
      <summary>
            Remove the texture mapping.
            </summary>
      <remarks>You may need to call viewport.Entities.Regen() to see the effect of this command.</remarks>
    </member>
    <member name="T:devDept.Geometry.Entities.sweepMethodType">
      <summary>
            GSurface sweep type.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.sweepMethodType.FrenetSerret">
      <summary>
            Frenet-Serret formulas
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.sweepMethodType.RotationMinimizingFrames">
      <summary>
            Rotation minimizing frames
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.sweepMethodType.RoadlikeTop">
      <summary>
            The section curve maintains its angle to the XY plane throughout the sweep
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.sweepMethodType.RoadlikeFront">
      <summary>
            The section curve maintains its angle to the ZX plane throughout the sweep
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.sweepMethodType.RoadlikeRight">
      <summary>
            The section curve maintains its angle to the YZ plane throughout the sweep
            </summary>
    </member>
    <member name="T:devDept.Geometry.Entities.GCurve">
      <summary>
            Nurbs curve entity.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.LocalApproximation(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Double,devDept.Geometry.Vector3D[]@,System.Boolean)">
      <summary>
            Local cubic approximation of a igCurve bounded to a certain error.
            </summary>
      <param name="Q">The list of points to approximate</param>
      <param name="err">The maximum error allowed</param>
      <param name="tangents">Automatically chosen tangents</param>
      <param name="cornerEnd">If true a corner may appear between the beginning and end of the igCurve, if false (default) the start and end tangents are parallel</param>
      <returns>The approximated igCurve if the operation is successful, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.LocalApproximation(System.Collections.Generic.IList{devDept.Geometry.PointTangent},System.Double)">
      <summary>
            Local cubic approximation of a igCurve bounded to a certain error.
            </summary>
      <param name="Q">The list of points with tangents to approximate</param>
      <param name="err">The maximum error allowed</param>
      <returns>The approximated igCurve if the operation is successful, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.GlobalApproximation(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Int32,System.Double)">
      <summary>
            Global approximation of a igCurve bounded to a certain error.
            </summary>
      <param name="Q">The list of points to approximate</param>
      <param name="deg">The degree of the approximation igCurve</param>
      <param name="err">The maximum error allowed</param>
      <returns>The approximated igCurve if the operation is successful, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.LeastSquares(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Int32,System.Int32)">
      <summary>
            Least squares igCurve approximation.
            </summary>
      <param name="Q">The list of 3D points</param>
      <param name="p">The igCurve degree</param>
      <param name="n">The number of control points in the new igCurve</param>
      <remarks>deg must be smaller than Q.Count</remarks>
      <returns>The approximated igCurve if the operation is successful, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.#ctor(System.Int32,System.Double[],devDept.Geometry.Point4D[],System.Boolean)">
      <summary>
            Standard constructor.
            </summary>
      <param name="degree">The curve degree</param>
      <param name="knotVector">The knot vector</param>
      <param name="ctrlPoints">The control points list</param>
      <param name="checkKnotsAndCtrlPts">If false, avoids all the checks (useless in GetNurbsForm() methods)</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.#ctor(System.Int32,System.Double,devDept.Geometry.Vector3D[])">
      <summary>
            Power basis to Bezier constructor.
            </summary>
      <param name="degree">The curve degree</param>
      <param name="span">The segment span</param>
      <param name="b">The power basis coefficients as an array of 3D vectors</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.#ctor(System.Int32,devDept.Geometry.Point3D[])">
      <summary>
            GCurve by control points constructor.
            </summary>
      <param name="degree">The desired curve degree</param>
      <param name="ctrlPoints">The list of control points</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.#ctor(System.Int32,System.Collections.Generic.IList{devDept.Geometry.Point3D})">
      <summary>
            GCurve by control points constructor.
            </summary>
      <param name="degree">The desired curve degree</param>
      <param name="ctrlPoints">The list of control points</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Point3D)">
      <summary>
            Elliptical arc by three points and two tangents constructor.
            </summary>
      <param name="P0">Start 3D point</param>
      <param name="T0">Start 3D tangent</param>
      <param name="P1">End 3D point</param>
      <param name="T1">End 3D tangent</param>
      <param name="P">A 3D point between P0 and P1.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.Clone">
      <summary>
            Creates a deep copy of this curve.
            </summary>
      <returns>The new curve object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.Resize(System.Int32,System.Int32)">
      <summary>
            Resizes a curve.
            </summary>
      <remarks>The old values are lost and new ones have to be created.</remarks>
      <param name="n">The new number of control points for the curve</param>
      <param name="deg">The new degree for the curve</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.ResizeKeep(System.Int32,System.Int32)">
      <summary>
            Resizes a curve, keeping original values.
            </summary>
      <remarks>The old values are lost and new ones have to be created.</remarks>
      <param name="n">The new number of control points for the curve</param>
      <param name="deg">The new degree for the curve</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.Merge(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.IGCurve)">
      <summary>
            Joins two curves.
            </summary>
      <param name="cl">The lower curve</param>
      <param name="cu">The upper curve</param>
      <returns>The resulting curve</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.Merge(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve})">
      <summary>
            Joins a list of curves. Curves must be properly oriented.
            </summary>
      <param name="curves">A list of curves to merge</param>
      <returns>The merged curve</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.Merge(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Boolean)">
      <summary>
            Joins a list of curves. Curves must be properly oriented.
            </summary>
      <param name="curves">A list of curves to merge</param>
      <param name="clean">When true, it cleans superfluous knots from the resulting curve.</param>
      <returns>The merged curve.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.SplitAt(System.Double,devDept.Geometry.Entities.IGCurve@,devDept.Geometry.Entities.IGCurve@)">
      <summary>
            Splits the curve into two curves.
            </summary>
      <param name="u">Splits at this parametric value</param>
      <param name="lower">The lower curve</param>
      <param name="upper">The upper curve</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.SplitAtDiscontinuities(System.Boolean)">
      <summary>
            Splits the curve at derivative discontinuities (e.g. cusps, kinks), returns an array of the smooth segments that form the curve.
            </summary>
      <param name="speedChange">If true, when the tangents have the same direction but different lengths, the curve will be split. 
            If false, it won't be split.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.Reverse">
      <summary>
            Reverses the curve direction.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.GetNurbsForm">
      <summary>
            Gets the Nurbs form of this curve.
            </summary>
      <returns>The curve itself, not cloned.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.ConvertToArcsAndLines">
      <summary>
            Converts the curve with a sequence of arcs and lines.
            </summary>
      <returns>List of lines and arcs that approximates the curve</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.ConvertToArcsAndLines(System.Double,System.Double,System.Double)">
      <summary>
            Converts the curve with a sequence of arcs and lines.
            </summary>
      <param name="epsDs">Tolerance regarding the curve length approximation</param>
      <param name="epsLc">Tolerance regarding the chordal error</param>
      <param name="epsAt">Tolerance regarding the curve tangent approximation</param>
      <returns>List of lines and arcs that approximates the curve</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.Length">
      <summary>
            Gets the curve length.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.IsLinear(System.Double,devDept.Geometry.Segment3D@)">
      <summary>
            Test a curve to see if the locus of its points is a gLine segment.
            </summary>
      <param name="tolerance">The tolerance</param>
      <param name="line">The gLine where the curve lays</param>
      <returns>True if the ends of the curve are farther than tolerance apart
            and the maximum distance from any point on the curve to
            the gLine segment connecting the curve's ends is &lt;= tolerance
            </returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.IsPlanar(System.Double,devDept.Geometry.Plane@)">
      <summary>
            Checks if the curve is planar.
            </summary>
      <param name="tol">The tolerance</param>
      <param name="plane">The plane where the curve lays</param>
      <returns>True if the curve is planar within tolerance, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.IsInPlane(devDept.Geometry.Plane,System.Double)">
      <summary>
            Checks if the curve lays on the specified plane.
            </summary>
      <param name="plane">The plane to test</param>
      <param name="tol">The tolerance</param>
      <returns>True if the curve lays on this plane, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.ControlLength">
      <summary>
            Gets the length of the curve's control polygon.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.ControlLengthSquared">
      <summary>
            Gets the squared length of the curve's control polygon.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">
      </param>
      <param name="ctxt">
      </param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.GetTrimCurve">
      <summary>
            Gets a GTrimCurve representation of this curve
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.GetTrimCurve(devDept.Geometry.Entities.IGCurve)">
      <summary>
            Gets a TrimIgCurve representation of this curve
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.TryGetArc(devDept.Geometry.Entities.GCircle@)">
      <summary>
            Converts this generic curve to <see cref="T:devDept.Geometry.Entities.GArc" /> or <see cref="T:devDept.Geometry.Entities.GCircle" /> (when possible).
            </summary>
      <param name="arc">The resulting circular curve (when possible)</param>
      <returns>True if the operation succeeds, false otherwise.</returns>
      <remarks>It works for arcs of angle 0, PI/2, PI, and 2PI.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.TryGetLine(devDept.Geometry.Entities.GLine@)">
      <summary>
            Converts this generic curve to <see cref="T:devDept.Geometry.Entities.GLine" /> (when possible).
            </summary>
      <param name="ln">The resulting linear curve (when possible)</param>
      <returns>True if the operation succeeds, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.Promote">
      <summary>
            Converts this generic curve to <see cref="T:devDept.Geometry.Entities.GLine" />, <see cref="T:devDept.Geometry.Entities.GArc" /> or <see cref="T:devDept.Geometry.Entities.GCircle" /> (when possible).
            </summary>
      <returns>The new curve when possible, null/Nothing otherwise.</returns>
      <remarks>For arcs, it works if the angle is 0, PI/2, PI or 2PI.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.PointAt(System.Double)">
      <summary>
            Computes the curve point at parametric value u.
            </summary>
      <param name="u">The parametric value</param>
      <returns>The 3D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.Evaluate(System.Double)">
      <summary>
            Computes the curve point at parametric value u.
            </summary>
      <param name="u">The parametric value</param>
      <returns>The 3D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.Evaluate(System.Double,System.Int32)">
      <summary>
            Computes the curve derivatives at parametric value u.
            </summary>
      <returns>The derivatives array.</returns>
      <example>
                The following code fragment demonstrates how to compute the first 2 derivatives of
                the curve at the parametric value [0.25].
            <code lang="CS">
            Vector3D[] CK = myCurve.Evaluate(0.25, 2);
             
            Vector3D C   = CK[0];
            Vector3D Cu  = CK[1];
            Vector3D Cuu = CK[2];
            </code><code lang="VB">
            Dim CK() As Vector3D = MyCurve.Evaluate(0.25, 2)
             
            Dim C As Vector3D = CK(0)
            Dim Cu As Vector3D = CK(1)
            Dim Cuu As Vector3D = CK(2)
            </code></example>
      <param name="u">The parametric value</param>
      <param name="d">The degree of the derivative</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.Curvature(System.Double)">
      <summary>
            Computes the curve curvature at parametric value u.
            </summary>
      <param name="u">The parametric value</param>
      <returns>The curvature magnitude.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.NormalAt(System.Double)">
      <summary>
            Computes the curve normal at parametric value u.
            </summary>
      <param name="u">The parametric value</param>
      <returns>The normal vector.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.TangentAt(System.Double)">
      <summary>
            Evaluates unit tangent vector at a parameter.
            </summary>
      <param name="t">Evaluation parameter</param>
      <returns>Unit tangent vector of the curve at the parameter t.</returns>
      <remarks>No error handling.</remarks>
      <seealso>EvaluateTangent()</seealso>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.EvaluateTangent(System.Double,devDept.Geometry.Point3D@,devDept.Geometry.Vector3D@)">
      <summary>
            Evaluate unit tangent at a parameter with error checking.
            </summary>
      <param name="t">Evaluation parameter</param>
      <param name="point">The 3D point at t</param>
      <param name="tangent">The unit tangent at t</param>
      <returns>True if the operation succeeded, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.Trim(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.IGCurve,System.Boolean,System.Boolean)">
      <summary>
            Trims two intersecting curves.
            </summary>
      <param name="C1">First curve</param>
      <param name="C2">Second curve</param>
      <param name="flip1">Flips first curve direction</param>
      <param name="flip2">Flips second curve direction</param>
      <returns>True if the operation succeeded, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.Fillet(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.IGCurve,System.Double,System.Boolean,System.Boolean,System.Boolean,System.Boolean,devDept.Geometry.Entities.GArc@)">
      <summary>
            Fillets two coplanar curves with an arc of given radius.
            </summary>
      <param name="C1">First curve</param>
      <param name="C2">Second curve</param>
      <param name="radius">Radius of the fillet arc</param>
      <param name="flip1">Flips first curve direction</param>
      <param name="flip2">Flips second curve direction</param>
      <param name="trim1">When true the first curve is trimmed</param>
      <param name="trim2">When true the second curve is trimmed</param>
      <param name="fillet">The resulting fillet arc</param>
      <returns>True if the operation is successful, false if the curves don't lie on the same plane or don't touch.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.Fillet(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.IGCurve,devDept.Geometry.Vector3D,System.Double,System.Boolean,System.Boolean,System.Boolean,System.Boolean,devDept.Geometry.Entities.GArc@)">
      <summary>
            Fillets two coplanar curves with an arc of given radius.
            </summary>
      <param name="C1">First curve</param>
      <param name="C2">Second curve</param>
      <param name="planeNormal">Unit vector, normal to the plane on which both curves lie.</param>
      <param name="radius">Radius of the fillet arc</param>
      <param name="flip1">Flips first curve direction</param>
      <param name="flip2">Flips second curve direction</param>
      <param name="trim1">When true the first curve is trimmed</param>
      <param name="trim2">When true the second curve is trimmed</param>
      <param name="fillet">The resulting fillet arc</param>
      <returns>True if the operation is successful, false if the curves don't lie on the same plane or don't touch.</returns>
      <remarks> Looking at the curves from the top of planeNormal placed at the intersection, the fillet will be
            on the left side of a curve if its flip parameter is false, and on the right side if its flip is true.
            Use planeNormal only if you know exactly how the curves are oriented and where you want the fillet to be placed.
            Otherwise, set it to null or call the Fillet() method without planeNormal and we will compute it internally.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.Chamfer(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.IGCurve,System.Double,System.Boolean,System.Boolean,System.Boolean,System.Boolean,devDept.Geometry.Entities.GLine@)">
      <summary>
            Chamfers two curves.
            </summary>
      <param name="C1">First curve</param>
      <param name="C2">Second curve</param>
      <param name="distance">The chamfer distance</param>
      <param name="flip1">Flips first curve direction</param>
      <param name="flip2">Flips second curve direction</param>
      <param name="trim1">When true the first curve is trimmed</param>
      <param name="trim2">When true the second curve is trimmed</param>
      <param name="chamfer">The chamfer line</param>
      <returns>True if the operation is successful, false if the curves don't lie on the same plane or don't touch.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.Chamfer(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.IGCurve,devDept.Geometry.Vector3D,System.Double,System.Boolean,System.Boolean,System.Boolean,System.Boolean,devDept.Geometry.Entities.GLine@)">
      <summary>
            Chamfers two curves.
            </summary>
      <param name="C1">First curve</param>
      <param name="C2">Second curve</param>
      <param name="planeNormal">Unit vector, normal to the plane on which both curves lie.</param>
      <param name="distance">The chamfer distance</param>
      <param name="flip1">Flips first curve direction</param>
      <param name="flip2">Flips second curve direction</param>
      <param name="trim1">When true the first curve is trimmed</param>
      <param name="trim2">When true the second curve is trimmed</param>
      <param name="chamfer">The chamfer line</param>
      <returns>True if the operation is successful, false if the curves don't lie on the same plane or don't touch.</returns>
      <remarks> Looking at the curves from the top of planeNormal placed at the intersection, the chamfer will be
            on the left side of a curve if its flip parameter is false, and on the right side if its flip is true.
            Use planeNormal only if you know exactly how the curves are oriented and where you want the chamfer to be placed.
            Otherwise, set it to null or call the Chamfer() method without planeNormal and we will compute it internally.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.InsertKnot(System.Double,System.Int32)">
      <summary>
            Inserts a knot a number of times. It does not affect the shape of the curve.
            </summary>
      <param name="u">The knot to insert</param>
      <param name="r">The number of times to insert</param>
      <returns>The number of knots inserted, zero otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.InsertKnot(devDept.Geometry.Point3D,System.Int32)">
      <summary>
            Inserts a knot a number of times. It is added at the parameter corresponding to the projection of the given point on the curve. 
            The insertion does not affect the shape of the curve.
            </summary>
      <param name="ctrlPoint">The point to be projected on the curve</param>
      <param name="r">The number of times to insert</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.AddControlPoint(devDept.Geometry.Point3D)">
      <summary>
            Inserts a control point on the control polygon. The control point will be added at the projection of the given 3D point on the polygon. 
            The insertion does not affect the shape of the curve.
            </summary>
      <param name="ctrlPoint">The 3D point to be projected on the control polygon</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.RefineKnotVector(System.Double[])">
      <summary>
            Refines the curve knot vector.
            </summary>
      <param name="X">The new knots to insert in the knot vector</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.DegreeElevate(System.Int32)">
      <summary>
            Degree elevates the curve.
            </summary>
      <param name="t">The number of times to increase the degree of the curve</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.Decompose">
      <summary>
            Decomposes the curve into BÃ©zier segments.
            </summary>
      <returns>A list of curves.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.RemoveKnot(System.Int32,System.Int32,System.Int32)">
      <summary>
            Removes an internal knot from a curve.
            </summary>
      <remarks>Must be an internal knot.</remarks>
      <param name="r">The knot to remove</param>
      <param name="s">The multiplicity of the knot</param>
      <param name="num">The number of times to try to remove the knot</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.RemoveKnot(System.Int32,System.Int32,System.Int32,System.Double)">
      <summary>
            Removes an internal knot from a curve.
            </summary>
      <remarks>Must be an internal knot.</remarks>
      <param name="r">The knot to remove</param>
      <param name="s">The multiplicity of the knot</param>
      <param name="num">The number of times to try to remove the knot</param>
      <param name="tol">The allowed tolerance</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.RemoveKnots(System.Double)">
      <summary>
            Removes as many knots as possible from a curve.
            </summary>
      <param name="tol">The allowed tolerance</param>
      <returns>Number of knots removed.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.GlobalInterpolation(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Int32)">
      <summary>
            Global curve interpolation.
            </summary>
      <param name="Q">The list of points to interpolate</param>
      <param name="deg">The desired curve degree</param>
      <returns>The interpolated curve if the operation succeeded, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.LocalInterpolation(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Boolean,System.Boolean)">
      <summary>
            Local interpolation.
            </summary>
      <param name="Q">A list of 3D points to interpolate</param>
      <param name="cornerFlag">If true corners are mantained</param>
      <param name="cornerEndFlag">If true a corner may appear between the beginning and end of the curve, if false (default) the start and end tangents are parallel</param>
      <returns>The interpolated curve if the operation succeeded, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.LocalInterpolation(System.Collections.Generic.IList{devDept.Geometry.PointTangent})">
      <summary>
            Local interpolation.
            </summary>
      <param name="Q">A list of 3D points with 3D tangent to interpolate</param>
      <returns>The interpolated curve if the operation succeeded, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.CubicSplineInterpolation``1(System.Collections.Generic.IList{``0},System.Boolean)">
      <summary>
            Cubic spline interpolation with automatic tangents.
            </summary>
      <param name="Q">The list of 3D points to interpolate</param>
      <param name="cornerEnd">If true a corner may appear between the beginning and end of the curve, if false (default) the start and end tangents are parallel</param>
      <returns>The interpolated curve if the operation succeeded, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.CubicSplineInterpolation(System.Collections.Generic.IList{devDept.Geometry.Point3D},devDept.Geometry.Vector3D,devDept.Geometry.Vector3D)">
      <summary>
            Cubic spline interpolation.
            </summary>
      <param name="Q">The list of 3D points to interpolate</param>
      <param name="startTang">The start 3D tangent vector, magnitude matters (total chord length of the point set can be a reasonable value).</param>
      <param name="endTang">The end 3D tangent vector, magnitude matters (total chord length of the point set can be a reasonable value).</param>
      <returns>The interpolated curve if the operation succeeded, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.ControlBoundingBox(System.Double,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">
      <summary>
            Computes the extension of the control polygon/net.
            </summary>
      <param name="min">Min 3D point</param>
      <param name="max">Max 3D point</param>
      <param name="inflateBy">Offset</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.MinimumDistance(devDept.Geometry.Entities.GCurve,devDept.Geometry.Entities.GCurve,System.Double,System.Double@,System.Double@,System.Double@)">
      <summary>
            Computes the minimum distance between two curves.
            </summary>
      <param name="F">First curve</param>
      <param name="G">Second curve</param>
      <param name="tol">Tolerance</param>
      <param name="u">Initial guess on F curve domain</param>
      <param name="s">Initial guess on G curve domain</param>
      <param name="distance">The resulting minimum distance</param>
      <returns>True if the operation was successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.MinimumDistance(devDept.Geometry.Entities.GCurve,devDept.Geometry.Entities.GCurve,System.Double,System.Boolean,System.Double@,System.Double@,System.Double@)">
      <summary>
            Computes the minimum distance between two curves.
            </summary>
      <param name="F">First curve</param>
      <param name="G">Second curve</param>
      <param name="tol">Tolerance</param>
      <param name="allowOutside">If true result could be outside of the curve</param>
      <param name="u">Initial guess on F curve domain</param>
      <param name="s">Initial guess on G curve domain</param>
      <param name="distance">The resulting minimum distance</param>
      <returns>True if the operation was successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.length">
      <summary>
            Computes an approximation of the length of the igCurve
            using a numerical automatic integrator.
            That integrator uses a Chebyshev Series Expansion
            to perform its approximation. This is why you can
            change the value n which sets the number of 
            elements in the series. 
            The method is simple, integrate between each span.
            This is necessary in case the tangent of a point
            at u_i is undefined. Add the result and return
            this as the approximation.
            </summary>
      <returns>The length of the NURBS igCurve</returns>
    </member>
    <member name="F:devDept.Geometry.Entities.GCurve.seam">
      <summary>
            GCurve seam.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.Project(devDept.Geometry.Point3D,System.Double,System.Boolean,System.Double,System.Double@)">
      <summary>
            Projects a point on the curve.
            </summary>
      <param name="P">The 3D point to project</param>
      <param name="u">The U parametric coordinate of the closest point on curve to P</param>
      <param name="coincTol">Relevant only when P lays on the curve. When the distance between P and its projection is smaller then this value, the projection is considered succesful.</param>
      <param name="allowOutside">When true, the projection is not constrained inside the curve domain</param>
      <param name="prevU">The U parametric coordinate of a previous succesful point projection</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.Project(devDept.Geometry.Point3D,System.Double,System.Boolean,System.Double@)">
      <summary>
            Projects a point on the curve.
            </summary>
      <param name="P">The 3D point to project</param>
      <param name="u">The U parametric position of the closest point on curve to P</param>
      <param name="coincTol">Relevant only when P lays on the curve. When the distance between P and its projection is smaller then this value, the projection is considered succesful.</param>
      <param name="allowOutside">When true, the projection is not constrained inside the curve domain</param>
      <returns>True when the projection is perpendicular to the curve, false otherwise.</returns>
      <remarks>When false is returned, the value of u is not reliable.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.ProjectOn(devDept.Geometry.Plane)">
      <summary>
            Project this curve on the specified plane.
            </summary>
      <param name="plane">The plane</param>
      <returns>A new curve with all control points exactly on the specified plane.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.Drop(devDept.Geometry.Plane,devDept.Geometry.Entities.IGCurve)">
      <summary>
            Project curve on the specified plane.
            </summary>
      <param name="pln">The plane</param>
      <param name="curve">The 3D curve</param>
      <returns>The resulting Nurbs curve.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GCurve.Domain">
      <summary>
            Gets curve domain.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GCurve.Order">
      <summary>
            Gets curve order.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GCurve.Degree">
      <summary>
            Gets or sets the curve degree.
            </summary>
      <remarks>Not validated in setter. Use constructor if you are unsure of the correctness of your data.</remarks>
      <seealso cref="!:IsValid()" />
    </member>
    <member name="P:devDept.Geometry.Entities.GCurve.IsClosed">
      <summary>
            Returns true if the curve is closed.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GCurve.IsRational">
      <summary>
            Returns true if the curve is rational.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GCurve.ControlPoints">
      <summary>
            Gets or sets the curve control point array.
            </summary>
      <remarks>Not validated in setter. Use constructor if you are unsure of the correctness of your data.</remarks>
      <seealso cref="M:devDept.Geometry.Entities.GCurve.IsValid(devDept.Geometry.Point3D[])" />
    </member>
    <member name="P:devDept.Geometry.Entities.GCurve.KnotVector">
      <summary>
            Gets or sets the curve knot vector U.
            </summary>
      <remarks>Not validated in setter. Use constructor if you are unsure of the correctness of your data.</remarks>
      <seealso cref="!:IsValid()" />
    </member>
    <member name="P:devDept.Geometry.Entities.GCurve.IsLine">
      <summary>
            If true the curve is a line and not a degenerated one (a point).
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GCurve.IsPoint">
      <summary>
            If true, the curve is a degenerated one (a point).
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.TrimBy(devDept.Geometry.Point3D,System.Boolean)">
      <summary>
            Trims the curve at the limit point projection.
            </summary>
      <param name="limit">The limit point</param>
      <param name="flipSide">The flip side flag</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.TrimAt(System.Double,System.Boolean)">
      <summary>
            Trims the curve at the provided parametric value.
            </summary>
      <param name="u">The parametric value</param>
      <param name="flipSide">The flip side flag</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.GetParamsFromLength(System.Double[],System.Double[]@)">
      <summary>
            Given a sorted array of lengths along the curve, finds the parameter values that correspond to them.
            </summary>
      <param name="lengths">Sorted lengths along the curve (ascending order)</param>
      <param name="ts">Corresponding parameter values</param>
      <returns>True if all the operations were successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.TrimBy(devDept.Geometry.Plane,System.Double,System.Boolean)">
      <summary>
            Trims the curve at the limit point projection.
            </summary>
      <param name="pln">The limit plane</param>
      <param name="tol">The tolerance</param>
      <param name="flipSide">The flip side flag</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GCurve.IntersectWith(devDept.Geometry.Plane,System.Double)">
      <summary>
            Trims the curve at the limit point projection.
            </summary>
      <param name="pln">The limit plane</param>
      <param name="tol">The search tolerance</param>
      <returns>The list of 3D intersection points.</returns>
    </member>
    <member name="T:devDept.Geometry.Entities.GNurbsBase">
      <exclude />
      <excludetoc />
    </member>
    <member name="M:devDept.Geometry.Entities.GNurbsBase.#ctor">
      <summary>
            GEntity nature constructor.
            </summary>
      <param name="entityNature">
      </param>
    </member>
    <member name="M:devDept.Geometry.Entities.GNurbsBase.Bernstain(System.Int32,System.Int32,System.Double)">
      <summary>
            Computes the value of Berstain polynomial.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GNurbsBase.BernstainDer(System.Int32,System.Int32,System.Double)">
      <summary>
            Computes the value of the first derivative of a Berstain polynomial.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GNurbsBase.ChordLengthParametrization``1(System.Collections.Generic.IList{``0},System.Double[]@)">
      <summary>
            Computes chord length parameterization from a vector of points.
            </summary>
      <param name="Q">The list of 3D points</param>
      <param name="ub">The resulting length parameterization</param>
      <returns>The total chord length.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GNurbsBase.ChordLengthParametrization``1(System.Int32,System.Int32,System.Collections.Generic.IList{``0},System.Double[]@,System.Double[]@)">
      <summary>
            Computes chord length parameterization from a vector of points.
            </summary>
      <param name="from">Start index</param>
      <param name="to">End index</param>
      <param name="Q">The list of 3D points</param>
      <param name="distances">The length of each chord</param>
      <param name="ub">The resulting length parameterization</param>
      <returns>The total chord length.</returns>
    </member>
    <member name="F:devDept.Geometry.Entities.GNurbsBase.geometricalAttributesDirty">
      <summary>
            When true, geometrical attributes need to be updated.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GNurbsBase.ShowControl">
      <summary>
            If true, the control polygon/net for this entity is displayed.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GNurbsBase.ControlBoundingBox(devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">
      <summary>
            Computes the extension of the control polygon/net.
            </summary>
      <param name="min">Min 3D point</param>
      <param name="max">Max 3D point</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GNurbsBase.ControlBoundingBox">
      <summary>
            Computes the extension of the control polygon/net.
            </summary>
      <returns>The 3D size of the control polygon/net</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GNurbsBase.UniformKnotVector(System.Int32,System.Int32)">
      <summary>
            Constructs a uniform clamped knot vector. v[j+1]-v[j] is equal for all inners nodes.
            </summary>
      <param name="p">Degree</param>
      <param name="n">Number of control points</param>
      <returns>The resulting knot vector.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GNurbsBase.BezierToPowerMatrix(System.Int32)">
      <summary>
            Computes Mp efficiently.
            </summary>
      <param name="p">The degree</param>
      <returns>The Mp matrix.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GNurbsBase.PowerToBezierMatrix(System.Int32,System.Double[0:,0:])">
      <summary>
            Computes the inverse of Mp.
            </summary>
      <param name="p">The degree</param>
      <param name="M">The Mp matrix</param>
      <returns>The inverse matrix.</returns>
    </member>
    <member name="T:devDept.Geometry.Entities.KnotVectorExtender">
      <summary>Knot vector definition.</summary>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.Left(System.Double[])">
      <summary>
            First value of this knot vector.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.Right(System.Double[])">
      <summary>
            Last value of this knot vector.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.Offset(System.Double[],System.Double)">
      <summary>
            Adds the specifies delta to all the values of the array.
            </summary>
      <param name="delta">The offset amount</param>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.Scale(System.Double[],System.Double)">
      <summary>
            Scales all the values of the array of the specified scale factor.
            </summary>
      <param name="factor">Scale factor</param>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.Normalize(System.Double[])">
      <summary>
            Normalize the values in the array.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.IsClamped(System.Double[],System.Int32,System.Int32,System.Boolean@,System.Boolean@)">
      <summary>
            Checks if the knot vector is clamped.
            </summary>
      <param name="p">Degree</param>
      <param name="n">Number of control points</param>
      <param name="start">Outputs start clamped status</param>
      <param name="end">Outputs end clamped status</param>
      <remarks>If the first and last p+1 knots are almost equal, we make them equal to the first or last knot.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.IsClamped(System.Double[],System.Int32,System.Int32)">
      <summary>
            Checks if the knot vector is clamped.
            </summary>
      <param name="p">Degree</param>
      <param name="n">Number of control points</param>
      <returns>True if the know vector is clamped, false otherwise.</returns>
      <remarks>If the first and last p+1 knots are almost equal, we make them equal to the first or last knot.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.SpanCount(System.Double[],System.Int32,System.Int32)">
      <summary>
            Computes number of non-empty spans
            </summary>
      <param name="p">Degree</param>
      <param name="n">Number of control points</param>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.Multiplicity(System.Double[],System.Int32)">
      <summary>
            Computes the multiplicity of the spcified knot value.
            </summary>
      <param name="knotIndex">The knot index</param>
      <returns>The knot multiplicity</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.IsValid(System.Double[],System.Int32,System.Int32)">
      <summary>
            Checks knot vector for incorrect multiplicity and monotonicity. 
            The knot vector must have p+1 equal knots at the beginning and at the end. (Clamped igCurve)
            </summary>
      <param name="p">Degree</param>
      <param name="n">Number of control points</param>
      <returns>True if the knot vector is valid, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.IsValid(System.Double[],System.Int32)">
      <summary>
            Checks knot vector for incorrect multiplicity and monotonicity.
            The knot vector is considered valid even if it doesn't have p+1 equal knots at the beginning and at the end. (UNclamped igCurve)
            </summary>
      <param name="p">Degree</param>
      <returns>True if the knot vector is valid, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.FindSpan(System.Double[],System.Int32,System.Int32,System.Double)">
      <summary>
            Determines the knot span index.
            </summary>
      <returns>The knot span index.</returns>
      <param name="n">Number of control points</param>
      <param name="p">Degree</param>
      <param name="u">Parametric value</param>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.FindSpanMult(System.Double[],System.Double,System.Int32,System.Int32@,System.Int32@)">
      <summary>
            Given a double u in the inteval [u_k, u_k+1), finds the index k and the multiplicity s 
            </summary>
      <param name="u">The knot to observe</param>
      <param name="p">The degree</param>
      <param name="k">The knot index</param>
      <param name="s">The knot multiplicity</param>
      <remarks>The highest multiplicity detected is p+1.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.FindSpanMult(System.Double[],System.Double@,System.Int32,System.Double,System.Int32@,System.Int32@)">
      <summary>
            Given a double u in the inteval [u_k, u_k+1), finds the index k and the multiplicity s 
            </summary>
      <param name="u">The knot to observe</param>
      <param name="p">The degree</param>
      <param name="minKnotDist">Minumum Knot distance: if u is closer to a knot than minKnotdist, then u becomes equal to that knot</param>
      <param name="k">The knot index</param>
      <param name="s">The knot multiplicity</param>
      <remarks>The highest multiplicity detected is p+1.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.GetFirstSimilarKnotIndex(System.Double[],System.Int32,System.Double,System.Int32@,System.Int32@)">
      <summary>
            Gets the index of the first similar knot vector (within prescribed tolerance).
            </summary>
      <param name="p">Degree</param>
      <param name="minDist">The min acceptable dist between knots</param>
      <param name="index">The knot to be removed index</param>
      <param name="mult">The knot to be removed multiplicity</param>
      <returns>True if two similar know were found, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.MinAcceptableKnotDistance(System.Double[],System.Int32)">
      <summary>
            Computes the minimum acceptable knot distance.
            </summary>
      <param name="p">Degree</param>
      <returns>The minimum acceptable knot distance.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.Reverse(System.Double[])">
      <summary>
            Reverts the knot vector.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.Reverse(System.Double[],System.Double)">
      <summary>
            Reverts the knot vector.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.GetStyle(System.Double[],System.Int32,System.Int32)">
      <summary>
            Gets the knot vector style.
            </summary>
      <param name="p">Degree</param>
      <param name="n">Number of control points</param>
      <returns>The knot vector style.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.Split(System.Double[],System.Int32,System.Int32,System.Int32@,System.Double@)">
      <summary>
            Split a knot vector at the center, by adding multiplicity k knots near
            the middle of the parameter range. Tries to start with an existing knot,
            but will add a new knot value if there's nothing in "the middle" (e.g. a Bezier igCurve).
            </summary>
      <param name="m">Index of the last control point</param>
      <param name="k">The parent igCurve degree</param>
      <param name="splitPt">Index of the mid value</param>
      <param name="midVal">The domain range mid value</param>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.Split(System.Double[],System.Double,System.Int32,System.Int32,System.Int32,System.Int32@)">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.BasisFuns(System.Double[],System.Int32,System.Double,System.Int32)">
      <summary>
            Compute the non vanishing basis functions.
            </summary>
      <returns>The non-zero basis functions.</returns>
      <param name="i">The non-zero span of the basis functions</param>
      <param name="u">The parametric value</param>
      <param name="p">The degree</param>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.OneBasisFun(System.Double[],System.Int32,System.Double,System.Int32)">
      <summary>
            Computes the basis function Nip.
            </summary>
      <param name="i">The non-zero span of the basis functions</param>
      <param name="u">The parametric value</param>
      <param name="p">The degree</param>
      <returns>The Nip basis funtion</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.KnotVectorExtender.DersBasisFuns(System.Double[],System.Int32,System.Double,System.Int32,System.Int32)">
      <summary>
            Compute nonzero basis functions and their derivatives
            </summary>
      <remarks>i, u, and n must be valid values</remarks>
      <returns>The derivatives, ders[k,j] is the kth derivative of the function Ni-p+j,p</returns>
      <param name="i">The span for the basis functions</param>
      <param name="u">The parametric value</param>
      <param name="p">The degree</param>
      <param name="n">The degree of the derivation</param>
    </member>
    <member name="T:devDept.Geometry.Entities.knotVectorType">
      <summary>
            Knot vector style type.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.knotVectorType.Undefined">
      <summary>
            Undefined
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.knotVectorType.ClampedUniform">
      <summary> 
            Examples: {0,0,0,0, 1,2,3, 4,4,4,4}, {-0.5,-0.5,-0.5, 1,2.5, 4,4,4}
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.knotVectorType.ClampedNonUniform">
      <summary>
            Examples: {0,0,0, 2,3,6, 7,7,7}, {0,0,0,0, 1,2,2,3,4, 5,5,5,5}
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.knotVectorType.UnClampedUniform">
      <summary>
            Examples: {-3,-2,-1,0,1,2,3,4}, {0,1,2,3,4,5,6,7,8,9,10,11}
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.knotVectorType.UnClampedNonUniform">
      <summary>
            Examples: {0,0,1,2,3,4}, {-2,-1,0,4,5,6,7}
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.knotVectorType.PiecewiseBezier">
      <summary>
            Another common knot vector format is for piecewise BÃ©zier igCurves. 
            These are usually used when a bunch of simple primitives, such as 
            arcs, lines or simple igCurve segments are strung together into a single 
            large igCurve. Again, if k is the order, then the igCurve passes through 
            each kâth point on the igCurve, and passes near all of the others. In 
            other words, the igCurve is broken into segments of k points each. 
            Moving any control point within a particular segment affects only 
            that segment, and moving a point where two segments join affects 
            both. If the joint and the control points on either side of it are in a 
            straight line, then the two segments form a smooth continuous 
            igCurve.3 Otherwise a sharp âkinkâ or discontinuity occurs.
            Example: {0,0,0, 1,1, 2,2, 3,3,3}
            </summary>
    </member>
    <member name="T:devDept.Geometry.Entities.GSolid">
      <summary>
            This class represents the base class for 3D primitives.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSolid.TextureMapping">
      <summary>
            Gets the texture mapping data associated with this solid.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.Difference``1(``0,``0,System.Double)">
      <summary>Boolean Difference between two gSolids.</summary>
      <param name="a">First operand</param>
      <param name="b">Second operand</param>
      <param name="tol">Optional tolerance, start with domain size * 1e-6</param>
      <returns>An array of gSolids if the operation is successful, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CutBy(devDept.Geometry.Entities.GSurface,System.Double,System.Boolean)">
      <summary>Cuts the part of the gSolid on the positive side of a gSurface.</summary>
      <param name="surf">The gSurface</param>
      <param name="tolerance">The gSurface tessellation tolerance</param>
      <param name="flipSide">The flip side flag</param>
      <returns>The intersection failure type.</returns>
      <remarks>If the operation is <see cref="F:devDept.Geometry.booleanFailureType.Success" /> the object is modified, otherwise the original object is unmutated.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CutBy(devDept.Geometry.Entities.GSurface,System.Double,System.Boolean,devDept.Geometry.Entities.GSolid[]@)">
      <summary>Cuts the part of the gSolid on the positive side of a gSurface.</summary>
      <param name="surf">The gSurface</param>
      <param name="tolerance">The gSurface tessellation tolerance</param>
      <param name="flipSide">The flip side flag</param>
      <param name="leftOvers">The other gSolids that may result from the operation</param>
      <returns>The intersection failure type.</returns>
      <remarks>If the operation is <see cref="F:devDept.Geometry.booleanFailureType.Success" /> the object is modified, otherwise the original object is unmutated.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.SplitBy(devDept.Geometry.Entities.GSurface,System.Double,devDept.Geometry.Entities.GSolid[]@,devDept.Geometry.Entities.GSolid[]@)">
      <summary>Splits the gSolid with a gSurface.</summary>
      <param name="surf">The gSurface</param>
      <param name="tolerance">The gSurface tessellation tolerance</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.Union``1(``0,``0,System.Double)">
      <summary>Boolean Union between two gSolids.</summary>
      <param name="a">First operand</param>
      <param name="b">Second operand</param>
      <param name="tol">Optional tolerance, start with domain size * 1e-6</param>
      <returns>An array of gSolids if the operation is successful, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.Intersection``1(``0,``0,System.Double)">
      <summary>
        <para>Boolean Intersection between two solids. The method will compute the
            intersection between the two specified solids (gray and blue in the image below)
            and return an array with theÂ result (green). TheÂ returned array may have more
            than oneÂ elementÂ if multipleÂ disjoint intersectionsÂ are found.</para>
        <para>
          <img src="intersection.png" />
        </para>
      </summary>
      <param name="a">First operand</param>
      <param name="b">Second operand</param>
      <param name="tol">Optional tolerance, start with domain size * 1e-6</param>
      <returns>
            An array of solids if the operation is successful. If the operation is
            successful but no intersectionsÂ are found, an empty arrayÂ is returned.
            Otherwise, if due to an error the algorithmÂ fails to compute the
            intersections,Â null/Nothing is returned.
            </returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.Section(devDept.Geometry.PlaneEquation)">
      <summary>Computes the contours resulting from the intersection of the GSolid and the given plane.
            </summary>
      <param name="planeEquation">The cutting plane equation</param>
      <returns>An array Segment3D representing the section contour.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.IntersectionLoops(devDept.Geometry.Entities.GSolid,devDept.Geometry.Entities.GSolid,System.Double)">
      <summary>
            Computes the intersection loops between two GSolid objects.
            </summary>
      <param name="a">First gSolid</param>
      <param name="b">Second gSolid</param>
      <param name="tol">Optional tolerance, start with domain size * 1e-6</param>
      <returns>A list of Segment3D representing the intersection loops.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CutBy(devDept.Geometry.Plane)">
      <summary>Cuts the part of the gSolid on the positive side of a plane.
            </summary>
      <param name="plane">The plane</param>
      <returns>The intersection failure type.</returns>
      <remarks>If the operation is <see cref="F:devDept.Geometry.booleanFailureType.Success" /> the object is modified, otherwise the original object is unmutated.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CutBy(devDept.Geometry.Plane,devDept.Geometry.Entities.GSolid[]@)">
      <summary>Cuts the part of the gSolid on the positive side of a plane.
            </summary>
      <param name="plane">The plane</param>
      <param name="leftOvers">The other gSolids that may result from the operation</param>
      <returns>The intersection failure type.</returns>
      <remarks>If the operation is <see cref="F:devDept.Geometry.booleanFailureType.Success" /> the object is modified, otherwise the original object is unmutated.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.SplitBy(devDept.Geometry.Plane,devDept.Geometry.Entities.GSolid[]@,devDept.Geometry.Entities.GSolid[]@)">
      <summary>Splits the gSolid with a plane.
            </summary>
      <param name="plane">The plane</param>
      <param name="splitF">The F gSolid split list</param>
      <param name="splitG">The G gSolid split list</param>
      <returns>True if the plane intersects the gSolid, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreateBox(System.Double,System.Double,System.Double)">
      <summary>
             Creates a Box primitive.
            </summary>
      <param name="width">Size in X direction</param>
      <param name="depth">Size in Y direction</param>
      <param name="height">Size in Z direction</param>
      <returns>The created solid.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreateBox``1(System.Double,System.Double,System.Double)">
      <summary>
             Creates a Box primitive.
            </summary>
      <param name="width">Size in X direction</param>
      <param name="depth">Size in Y direction</param>
      <param name="height">Size in Z direction</param>
      <returns>The created solid.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreateCone(System.Double,System.Double,System.Double,System.Int32)">
      <summary>
             Creates a Cone primitive.
            </summary>
      <param name="bottomRadius">Cone bottom radius</param>
      <param name="topRadius">Cone top radius</param>
      <param name="height">Cone height</param>
      <param name="slices">Number of subdivisions</param>
      <returns>The created solid.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreateCone``1(System.Double,System.Double,System.Double,System.Int32)">
      <summary>
             Creates a Cone primitive.
            </summary>
      <param name="bottomRadius">Cone bottom radius</param>
      <param name="topRadius">Cone top radius</param>
      <param name="height">Cone height</param>
      <param name="slices">Number of subdivisions</param>
      <returns>The created solid.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreateCone(System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32)">
      <summary>
             Creates a Cone primitive.
            </summary>
      <param name="bottomRadius">Cone bottom radius</param>
      <param name="topRadius">Cone top radius</param>
      <param name="height">Cone height</param>
      <param name="slices">Number of subdivisions</param>
      <returns>The created solid.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreateCone``1(System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32)">
      <summary>
             Creates a Cone primitive.
            </summary>
      <param name="bottomRadius">Cone bottom radius</param>
      <param name="topRadius">Cone top radius</param>
      <param name="height">Cone height</param>
      <param name="slices">Number of subdivisions</param>
      <returns>The created solid.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreatePlanar(devDept.Geometry.Plane,System.Collections.Generic.IList{devDept.Geometry.Point2D})">
      <summary>Triangulates the specified 2D region.</summary>
      <param name="sketchPlane">Plane on which the points lay</param>
      <param name="outer">Outer contour of the region oriented counter-clockwise</param>
      <returns>The created GSolid.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreatePlanar``1(devDept.Geometry.Plane,System.Collections.Generic.IList{devDept.Geometry.Point2D})">
      <summary>Triangulates the specified 2D region.</summary>
      <param name="sketchPlane">Plane on which the points lay</param>
      <param name="outer">Outer contour of the region oriented counter-clockwise</param>
      <returns>The created GSolid.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreatePlanar(devDept.Geometry.Plane,System.Collections.Generic.IList{devDept.Geometry.Point2D},System.Collections.Generic.IList{System.Collections.Generic.IList{devDept.Geometry.Point2D}})">
      <summary>Triangulates the specified 2D region.</summary>
      <param name="sketchPlane">Plane on which the points lay</param>
      <param name="outer">Outer contour of the region oriented counter-clockwise</param>
      <param name="inners">The inner contour list oriented clockwise</param>
      <returns>The created GSolid.</returns>
      <exception cref="!:EyeshotException">Countours must be closed</exception>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreatePlanar``1(devDept.Geometry.Plane,System.Collections.Generic.IList{devDept.Geometry.Point2D},System.Collections.Generic.IList{System.Collections.Generic.IList{devDept.Geometry.Point2D}})">
      <summary>Triangulates the specified 2D region.</summary>
      <param name="sketchPlane">Plane on which the points lay</param>
      <param name="outer">Outer contour of the region oriented counter-clockwise</param>
      <param name="inners">The inner contour list oriented clockwise</param>
      <returns>The created GSolid.</returns>
      <exception cref="!:EyeshotException">Countours must be closed</exception>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreateCylinder(System.Double,System.Double,System.Int32)">
      <summary>
             Creates a Cylinder primitive.
            </summary>
      <param name="radius">Radius of cylinder</param>
      <param name="height">Height of cylinder</param>
      <param name="slices">Number of subdivisions</param>
      <returns>The created solid.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreateCylinder``1(System.Double,System.Double,System.Int32)">
      <summary>
             Creates a Cylinder primitive.
            </summary>
      <param name="radius">Radius of cylinder</param>
      <param name="height">Height of cylinder</param>
      <param name="slices">Number of subdivisions</param>
      <returns>The created solid.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreateCylinder(System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32)">
      <summary>Creates a Cylinder primitive.
            </summary>
      <param name="radius">Cylinder's radius</param>
      <param name="point1">Cylinder's first point</param>
      <param name="point2">Cylinder's second point</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <returns>The created solid.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreateCylinder``1(System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32)">
      <summary>Creates a Cylinder primitive.
            </summary>
      <param name="radius">Cylinder's radius</param>
      <param name="point1">Cylinder's first point</param>
      <param name="point2">Cylinder's second point</param>
      <param name="slices">Number of faces of the cylinder approximation</param>
      <returns>The created solid.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GSolid.SmoothingAngle">
      <summary>
            Gets or sets the angle in radians that determines solid sharp edges. 
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.ApplyTextureMapping(devDept.Geometry.textureMappingType,System.Double,System.Double)">
      <summary>
            Maps the specified material to this solid. Before using this method you need to define a material and add it to the Design Materials collection.
            </summary>
      <remarks>You may need to call viewport.Entities.Regen() to see the effect of this command.</remarks>
      <param name="mappingMode">Indicates the way Material texture is wrapped on the object</param>
      <param name="scaleX">Material texture scale along the X axis</param>
      <param name="scaleY">Material texture scale along the Y axis</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.ApplyTextureMapping(devDept.Geometry.textureMappingType,System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Transformation)">
      <summary>
            Maps the specified material to this solid. Before using this method you need to define a material and add it to the Design Materials collection.
            </summary>
      <remarks>You may need to call viewport.Entities.Regen() to see the effect of this command.</remarks>
      <param name="mappingMode">Indicates the way Material texture is wrapped on the object</param>
      <param name="scaleX">Material texture scale along the X axis</param>
      <param name="scaleY">Material texture scale along the Y axis</param>
      <param name="boxMin">Bounding box min point</param>
      <param name="boxMax">Bounding box max point</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.RemoveTextureMapping">
      <summary>
            Remove the texture mapping.
            </summary>
      <remarks>You may need to call viewport.Entities.Regen() to see the effect of this command.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.ExtrudeAdd(devDept.Geometry.Entities.GRegion,System.Double,System.Double)">
      <summary>
            Modifies current gSolid extruding a contour by a given amount and adding.
            </summary>
      <param name="region">The <see cref="T:devDept.Geometry.Entities.GRegion" /> to extrude</param>
      <param name="amount">Extrusion amount</param>
      <param name="tolerance">GEntity region needs to be converted to gSolid, this is the conversion tolerance</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.ExtrudeAdd(devDept.Geometry.Entities.GRegion,System.Double,System.Double,devDept.Geometry.Entities.GSolid[]@)">
      <summary>
            Modifies current gSolid extruding a contour by a given amount and adding.
            </summary>
      <param name="region">The <see cref="T:devDept.Geometry.Entities.GRegion" /> to extrude</param>
      <param name="amount">Extrusion amount</param>
      <param name="tolerance">GEntity region needs to be converted to gSolid, this is the conversion tolerance</param>
      <param name="leftOvers">The other gSolids that may result from the add operation</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.ExtrudeAdd(devDept.Geometry.Entities.GRegion,devDept.Geometry.Vector3D,System.Double,devDept.Geometry.Entities.GSolid[]@)">
      <summary>
            Modifies current gSolid extruding a contour by a given vector and adding.
            </summary>
      <param name="region">The <see cref="T:devDept.Geometry.Entities.GRegion" /> to extrude</param>
      <param name="amount">Extrusion amount</param>
      <param name="tolerance">GEntity region needs to be converted to gSolid, this is the conversion tolerance</param>
      <param name="leftOvers">The other gSolids that may result from the add operation</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.ExtrudeAdd(devDept.Geometry.Entities.GRegion,devDept.Geometry.Vector3D,System.Double)">
      <summary>
            Modifies current gSolid extruding a contour by a given vector and adding.
            </summary>
      <param name="region">The <see cref="T:devDept.Geometry.Entities.GRegion" /> to extrude</param>
      <param name="amount">Extrusion amount</param>
      <param name="tolerance">GEntity region needs to be converted to gSolid, this is the conversion tolerance</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.ExtrudeAdd(devDept.Geometry.Entities.GRegion,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Modifies current gSolid extruding a contour by a given vector and adding.
            </summary>
      <param name="region">The <see cref="T:devDept.Geometry.Entities.GRegion" /> to extrude</param>
      <param name="x">Extrusion amount along the axis X</param>
      <param name="y">Extrusion amount along the axis Y</param>
      <param name="z">Extrusion amount along the axis Z</param>
      <param name="tolerance">GEntity region needs to be converted to gSolid, this is the conversion tolerance</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.ExtrudeAdd(devDept.Geometry.Entities.GRegion,System.Double,System.Double,System.Double,System.Double,devDept.Geometry.Entities.GSolid[]@)">
      <summary>
            Modifies current gSolid extruding a contour by a given vector and adding.
            </summary>
      <param name="region">The <see cref="T:devDept.Geometry.Entities.GRegion" /> to extrude</param>
      <param name="x">Extrusion amount along the axis X</param>
      <param name="y">Extrusion amount along the axis Y</param>
      <param name="z">Extrusion amount along the axis Z</param>
      <param name="tolerance">GEntity region needs to be converted to gSolid, this is the conversion tolerance</param>
      <param name="leftOvers">The other gSolids that may result from the add operation</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.ExtrudeRemove(devDept.Geometry.Entities.GRegion,System.Double,System.Double,devDept.Geometry.Entities.GSolid[]@)">
      <summary>
             Modifies current gSolid extruding a contour by a given amount and removing.
             </summary>
      <param name="region">The <see cref="T:devDept.Geometry.Entities.GRegion" /> to extrude</param>
      <param name="amount">Extrusion amount</param>
      <param name="tolerance">GEntity region needs to be converted to gSolid, this is the conversion tolerance</param>
      <param name="leftOvers">The other gSolids that may result from the remove operation</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.ExtrudeRemove(devDept.Geometry.Entities.GRegion,System.Double,System.Double)">
      <summary>
             Modifies current gSolid extruding a contour by a given amount and removing.
             </summary>
      <param name="region">The <see cref="T:devDept.Geometry.Entities.GRegion" /> to extrude</param>
      <param name="amount">Extrusion amount</param>
      <param name="tolerance">GEntity region needs to be converted to gSolid, this is the conversion tolerance</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.ExtrudeRemove(devDept.Geometry.Entities.GRegion,devDept.Geometry.Vector3D,System.Double)">
      <summary>
             Modifies current gSolid extruding a contour by a given vector and removing.
             </summary>
      <param name="region">The <see cref="T:devDept.Geometry.Entities.GRegion" /> to extrude</param>
      <param name="amount">Extrusion amount</param>
      <param name="tolerance">GEntity region needs to be converted to gSolid, this is the conversion tolerance</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.ExtrudeRemove(devDept.Geometry.Entities.GRegion,devDept.Geometry.Vector3D,System.Double,devDept.Geometry.Entities.GSolid[]@)">
      <summary>
             Modifies current gSolid extruding a contour by a given vector and removing.
             </summary>
      <param name="region">The <see cref="T:devDept.Geometry.Entities.GRegion" /> to extrude</param>
      <param name="amount">Extrusion amount</param>
      <param name="tolerance">GEntity region needs to be converted to gSolid, this is the conversion tolerance</param>
      <param name="leftOvers">The other gSolids that may result from the remove operation</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.ExtrudeRemove(devDept.Geometry.Entities.GRegion,System.Double,System.Double,System.Double,System.Double,devDept.Geometry.Entities.GSolid[]@)">
      <summary>
             Modifies current gSolid extruding a contour by a given vector and removing.
             </summary>
      <param name="region">The <see cref="T:devDept.Geometry.Entities.GRegion" /> to extrude</param>
      <param name="x">Extrusion amount along the axis X</param>
      <param name="y">Extrusion amount along the axis Y</param>
      <param name="z">Extrusion amount along the axis Z</param>
      <param name="tolerance">GEntity region needs to be converted to gSolid, this is the conversion tolerance</param>
      <param name="leftOvers">The other gSolids that may result from the remove operation</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.ExtrudeRemove(devDept.Geometry.Entities.GRegion,System.Double,System.Double,System.Double,System.Double)">
      <summary>
             Modifies current gSolid extruding a contour by a given vector and removing.
             </summary>
      <param name="region">The <see cref="T:devDept.Geometry.Entities.GRegion" /> to extrude</param>
      <param name="x">Extrusion amount along the axis X</param>
      <param name="y">Extrusion amount along the axis Y</param>
      <param name="z">Extrusion amount along the axis Z</param>
      <param name="tolerance">GEntity region needs to be converted to gSolid, this is the conversion tolerance</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.RevolveAdd(devDept.Geometry.Entities.GRegion,System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32,System.Double)">
      <summary>Modifies current solid revolving a <see cref="T:devDept.Geometry.Entities.GRegion" /> around an axis and adding.</summary>
      <param name="region">The <see cref="T:devDept.Geometry.Entities.GRegion" /> to revolve</param>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axisStart">The axis start point</param>
      <param name="axisEnd">The axis end point</param>
      <param name="slices">Number of slices generated. This value can be also found using <see cref="!:Utility.NumberOfSegments(double, double, double)" /></param>
      <param name="tolerance">GEntity region needs to be converted to <see cref="T:devDept.Geometry.Entities.GSolid" />, this is the conversion tolerance</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.RevolveAdd(devDept.Geometry.Entities.GRegion,System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32,System.Double,devDept.Geometry.Entities.GSolid[]@)">
      <summary>Modifies current solid revolving a <see cref="T:devDept.Geometry.Entities.GRegion" /> around an axis and adding.</summary>
      <param name="region">The <see cref="T:devDept.Geometry.Entities.GRegion" /> to revolve</param>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axisStart">The axis start point</param>
      <param name="axisEnd">The axis end point</param>
      <param name="slices">Number of slices generated. This value can be also found using <see cref="!:Utility.NumberOfSegments(double, double, double)" /></param>
      <param name="tolerance">GEntity region needs to be converted to <see cref="T:devDept.Geometry.Entities.GSolid" />, this is the conversion tolerance</param>
      <param name="leftOvers">The other solids that may result from the add operation</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.RevolveAdd(devDept.Geometry.Entities.GRegion,System.Double,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Int32,System.Double)">
      <summary>Modifies current solid revolving a <see cref="T:devDept.Geometry.Entities.GRegion" /> around an axis and adding.</summary>
      <param name="region">The <see cref="T:devDept.Geometry.Entities.GRegion" /> to revolve</param>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axis">Axis direction</param>
      <param name="center">Axis start point</param>
      <param name="slices">Number of slices generated. This value can be also found using <see cref="!:Utility.NumberOfSegments(double, double, double)" /></param>
      <param name="tolerance">GEntity region needs to be converted to <see cref="T:devDept.Geometry.Entities.GSolid" />, this is the conversion tolerance</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.RevolveAdd(devDept.Geometry.Entities.GRegion,System.Double,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Int32,System.Double,devDept.Geometry.Entities.GSolid[]@)">
      <summary>Modifies current solid revolving a <see cref="T:devDept.Geometry.Entities.GRegion" /> around an axis and adding.</summary>
      <param name="region">The <see cref="T:devDept.Geometry.Entities.GRegion" /> to revolve</param>
      <param name="tolerance">GEntity region needs to be converted to <see cref="T:devDept.Geometry.Entities.GSolid" />, this is the conversion tolerance</param>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axis">Axis direction</param>
      <param name="center">Axis start point</param>
      <param name="slices">Number of slices generated. This value can be also found using <see cref="!:Utility.NumberOfSegments(double, double, double)" /></param>
      <param name="leftOvers">The other solids that may result from the add operation</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.RevolveRemove(devDept.Geometry.Entities.GRegion,System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32,System.Double)">
      <summary>Modifies current solid revolving a <see cref="T:devDept.Geometry.Entities.GRegion" /> around an axis and removing.</summary>
      <param name="region">The <see cref="T:devDept.Geometry.Entities.GRegion" /> to revolve</param>
      <param name="tolerance">GEntity region needs to be converted to <see cref="T:devDept.Geometry.Entities.GSolid" />, this is the conversion tolerance</param>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axisStart">The axis start point</param>
      <param name="axisEnd">The axis end point</param>
      <param name="slices">Number of slices generated. This value can be also found using <see cref="M:devDept.Geometry.Utility.NumberOfSegments(System.Double,System.Double,System.Double,System.Double)" /></param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.RevolveRemove(devDept.Geometry.Entities.GRegion,System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Int32,System.Double,devDept.Geometry.Entities.GSolid[]@)">
      <summary>Modifies current solid revolving a <see cref="T:devDept.Geometry.Entities.GRegion" /> around an axis and removing.</summary>
      <param name="region">The <see cref="T:devDept.Geometry.Entities.GRegion" /> to revolve</param>
      <param name="tolerance">GEntity region needs to be converted to <see cref="T:devDept.Geometry.Entities.GSolid" />, this is the conversion tolerance</param>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axisStart">The axis start point</param>
      <param name="axisEnd">The axis end point</param>
      <param name="slices">Number of slices generated. This value can be also found using <see cref="M:devDept.Geometry.Utility.NumberOfSegments(System.Double,System.Double,System.Double,System.Double)" /></param>
      <param name="leftOvers">The other solids that may result from the remove operation</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.RevolveRemove(devDept.Geometry.Entities.GRegion,System.Double,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Int32,System.Double)">
      <summary>Modifies current solid revolving a <see cref="T:devDept.Geometry.Entities.GRegion" /> around an axis and removing.</summary>
      <param name="region">The <see cref="T:devDept.Geometry.Entities.GRegion" /> to revolve</param>
      <param name="tolerance">GEntity region needs to be converted to <see cref="T:devDept.Geometry.Entities.GSolid" />, this is the conversion tolerance</param>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axis">Axis direction</param>
      <param name="center">Axis start point</param>
      <param name="slices">Number of slices generated. This value can be also found using <see cref="M:devDept.Geometry.Utility.NumberOfSegments(System.Double,System.Double,System.Double,System.Double)" /></param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.RevolveRemove(devDept.Geometry.Entities.GRegion,System.Double,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Int32,System.Double,devDept.Geometry.Entities.GSolid[]@)">
      <summary>Modifies current solid revolving a <see cref="T:devDept.Geometry.Entities.GRegion" /> around an axis and removing.</summary>
      <param name="region">The <see cref="T:devDept.Geometry.Entities.GRegion" /> to revolve</param>
      <param name="tolerance">GEntity region needs to be converted to <see cref="T:devDept.Geometry.Entities.GSolid" />, this is the conversion tolerance</param>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axis">Axis direction</param>
      <param name="center">Axis start point</param>
      <param name="slices">Number of slices generated. This value can be also found using <see cref="M:devDept.Geometry.Utility.NumberOfSegments(System.Double,System.Double,System.Double,System.Double)" /></param>
      <param name="leftOvers">The other solids that may result from the remove operation</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreateSphere(System.Double,System.Int32,System.Int32)">
      <summary>
             Creates a Sphere primitive.
            </summary>
      <param name="radius">Sphere radius</param>
      <param name="slices">Number of meridian subdivisions</param>
      <param name="stacks">Number of parallel subdivisions</param>
      <returns>The created solid.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreateSphere``1(System.Double,System.Int32,System.Int32)">
      <summary>
             Creates a Sphere primitive.
            </summary>
      <param name="radius">Sphere radius</param>
      <param name="slices">Number of meridian subdivisions</param>
      <param name="stacks">Number of parallel subdivisions</param>
      <returns>The created solid.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.Sweep(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.GRegion,System.Double,devDept.Geometry.Entities.sweepMethodType,System.Boolean)">
      <summary>Sweeps the GRegion along the provided trajectory.</summary>
      <param name="rail">The rail igCurve</param>
      <param name="region">The cross section</param>
      <param name="sweepMethod">The sweep method</param>
      <param name="tol">The regeneration tolerance</param>
      <returns>The resulting GSolid if the operation succeeded, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.Sweep``1(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.GRegion,System.Double,devDept.Geometry.Entities.sweepMethodType,System.Boolean)">
      <summary>Sweeps the GRegion along the provided trajectory.</summary>
      <param name="rail">The rail igCurve</param>
      <param name="region">The cross section</param>
      <param name="tol">The regeneration tolerance</param>
      <param name="sweepMethod">The sweep method</param>
      <returns>The resulting GSolid if the operation succeeded, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.Union(System.Collections.Generic.IList{devDept.Geometry.Entities.GSolid})">
      <summary>
            Union between a list of GSolid entities.
            </summary>
      <param name="solids">The entity list</param>
      <returns>The union operation result if the operation succeeded, null/Nothing otherwise.</returns>
      <exception cref="T:System.ArithmeticException">
      </exception>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreateSpring(System.Double,System.Double,System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
      <summary>Creates a Spring primitive.</summary>
      <param name="radius">Spring radius</param>
      <param name="wireRadius">Wire radius</param>
      <param name="sides">Number of subdivision sides</param>
      <param name="rings">Number of subdivision rings per turn</param>
      <param name="pitch">Height of each complete turn</param>
      <param name="turns">Number of turns</param>
      <param name="reverseTwist">Reverse direction</param>
      <returns>The resulting gSolid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreateSpring``1(System.Double,System.Double,System.Int32,System.Int32,System.Double,System.Double,System.Boolean)">
      <summary>Creates a Spring primitive.</summary>
      <param name="radius">Spring radius</param>
      <param name="wireRadius">Wire radius</param>
      <param name="sides">Number of subdivision sides</param>
      <param name="rings">Number of subdivision rings per turn</param>
      <param name="pitch">Height of each complete turn</param>
      <param name="turns">Number of turns</param>
      <param name="reverseTwist">Reverse direction</param>
      <returns>The resulting gSolid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreateSpring(System.Double,System.Double,System.Int32,System.Int32,System.Double,System.Double,System.Boolean,System.Boolean)">
      <summary>Creates a Spring primitive.</summary>
      <param name="radius">Spring radius</param>
      <param name="wireRadius">Wire radius</param>
      <param name="sides">Number of subdivision sides</param>
      <param name="rings">Number of subdivision rings per turn</param>
      <param name="pitch">Height of each complete turn</param>
      <param name="turns">Number of turns</param>
      <param name="reverseTwist">Reverse direction</param>
      <param name="closed">Closing caps on both ends</param>
      <returns>The resulting gSolid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreateSpring``1(System.Double,System.Double,System.Int32,System.Int32,System.Double,System.Double,System.Boolean,System.Boolean)">
      <summary>Creates a Spring primitive.</summary>
      <param name="radius">Spring radius</param>
      <param name="wireRadius">Wire radius</param>
      <param name="sides">Number of subdivision sides</param>
      <param name="rings">Number of subdivision rings per turn</param>
      <param name="pitch">Height of each complete turn</param>
      <param name="turns">Number of turns</param>
      <param name="reverseTwist">Reverse direction</param>
      <param name="closed">Closing caps on both ends</param>
      <returns>The resulting gSolid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreateTorus(System.Double,System.Double,System.Int32,System.Int32)">
      <summary>
             Creates a Torus primitive.
            </summary>
      <param name="majorRadius">Torus radius</param>
      <param name="minorRadius">Torus section radius</param>
      <param name="rings">Number of subdivisions</param>
      <param name="sides">Number of section subdivisions</param>
      <returns>The created solid.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.CreateTorus``1(System.Double,System.Double,System.Int32,System.Int32)">
      <summary>
             Creates a Torus primitive.
            </summary>
      <param name="majorRadius">Torus radius</param>
      <param name="minorRadius">Torus section radius</param>
      <param name="rings">Number of subdivisions</param>
      <param name="sides">Number of section subdivisions</param>
      <returns>The created solid.</returns>
    </member>
    <member name="T:devDept.Geometry.Entities.GSolid.Portion">
      <summary>
            This class represents a portion of the gSolid object. To keep booleans operation reasonably fast, the gSolid is split in more portions.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSolid.Portion.Id">
      <summary>
            Portion identifier.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSolid.Portion.VertexCount">
      <summary>
            Gets the number of portion vertices.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSolid.Portion.FaceCount">
      <summary>
            Gets the number of portion faces.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSolid.Portion.planes">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSolid.Portion.EdgeDatas">
      <summary>
            Gets the list of edge attributes.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSolid.Portion.Faces">
      <summary>
            Gets the list of faces attributes.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSolid.Portion.Cycles">
      <summary>
            Gets the list of cycles attributes.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSolid.Portion.Vertices">
      <summary>
            Gets the gSolid portion's 3D vertices.
            </summary>
      <exception cref="T:devDept.Eyeshot.EyeshotException">Thrown when try to set the property.</exception>
    </member>
    <member name="P:devDept.Geometry.Entities.GSolid.Portion.IsoCurves">
      <summary>
            Gets or sets the portion iso curves.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.Portion.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Constructor with parameters
            </summary>
      <param name="maxNov">
      </param>
      <param name="maxNoe">
      </param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.Portion.#ctor(devDept.Geometry.Entities.GSolid.Portion)">
      <summary>
            Copy constructor.
            </summary>
      <param name="another">
      </param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.Portion.#ctor(devDept.Geometry.Entities.GSolid.EdgeData[],devDept.Geometry.Entities.GSolid.Face[],devDept.Geometry.Entities.GSolid.Cycle[],devDept.Geometry.Point3D[],System.Int32)">
      <summary>
            Standard constructor.
            </summary>
      <param name="edgeDatas">Edges attributes</param>
      <param name="faces">Faces attributes </param>
      <param name="cycles">Cycles attributes</param>
      <param name="vertices">GSolid portion's 3D vertices</param>
      <param name="id">Portion identifier</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.Portion.#ctor(devDept.Geometry.Entities.GSolid.EdgeData[],devDept.Geometry.Entities.GSolid.Face[],devDept.Geometry.Entities.GSolid.Cycle[],devDept.Geometry.Point3D[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Constructor for Eyeshot file format backward compatibility.
            </summary>
      <param name="edgeDatas">Edges attributes</param>
      <param name="faces">Faces attributes </param>
      <param name="cycles">Cycles attributes</param>
      <param name="vertices">GSolid portion's 3D vertices</param>
      <param name="id">Portion identifier</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.Portion.Clone">
      <summary>
            Creates a deep copy of this gSolid portion.
            </summary>
      <returns>The new gSolid portion object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.Portion.CopyData(devDept.Geometry.Entities.GSolid.Portion)">
      <summary>
            Copy data
            </summary>
      <param name="np">piece of data</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.Portion.GetFace(System.Int32,devDept.Geometry.Entities.GLinearPath@,devDept.Geometry.Entities.GLinearPath[]@,System.Double)">
      <summary>
             Gets the specified GSolid face as a number of <see cref="T:devDept.Geometry.Entities.GLinearPath" /> loops.
            </summary>
      <param name="faceNum">The number of the face</param>
      <param name="outer">Outer contour</param>
      <param name="inners">Inner countours</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.Portion.GetFace(System.Int32,devDept.Geometry.PlaneEquation@,devDept.Geometry.Point2D[]@,devDept.Geometry.Point2D[][]@,System.Double)">
      <summary>Gets the face.</summary>
      <param name="faceNum">The number of the face</param>
      <param name="plane">The plane quation of the face</param>
      <param name="outer">Outer contour</param>
      <param name="inners">Inner countours</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.Portion.GetFacePlane(System.Int32)">
      <summary>Gets the plane equation of the face.
            </summary>
      <param name="faceNum">The number of the face</param>
      <returns>The plane quation of the face.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GSolid.Portion.Edges">
      <summary>
            Gets the sharp edges of this gSolid portion.
            </summary>
      <remarks>The setter is public but for internal use only.</remarks>
    </member>
    <member name="P:devDept.Geometry.Entities.GSolid.Portions">
      <summary>
            Gets the gSolid's boundary representation.
            </summary>
    </member>
    <member name="T:devDept.Geometry.Entities.GSolid.EdgeData">
      <summary>
            Edge data.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSolid.EdgeData.BeginVertex">
      <summary>
            Begin vertex
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSolid.EdgeData.EndVertex">
      <summary>
            End vertex
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSolid.EdgeData.Type">
      <summary>
            Edge type
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSolid.EdgeData.NextFace">
      <summary>
            Next face
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSolid.EdgeData.NextEdge">
      <summary>
            Previous edge
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSolid.EdgeData.PreviousFace">
      <summary>
            Previous face
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSolid.EdgeData.PreviousEdge">
      <summary>
            Previous edge
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSolid.EdgeData.Angle">
      <summary>
            Angle
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.EdgeData.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Deprecated contructor.
            </summary>
      <param name="beginVertex">Begin vertex</param>
      <param name="endVertex">End vertex</param>
      <param name="type">Type</param>
      <param name="previousEdge">Previous edge</param>
      <param name="nextEdge">Next edge</param>
      <param name="previousFace">Previous face</param>
      <param name="nextFace">Next face</param>
      <param name="angle">Angle</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.EdgeData.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Single)">
      <summary>
            Standard contructor.
            </summary>
      <param name="beginVertex">Begin vertex</param>
      <param name="endVertex">End vertex</param>
      <param name="type">Type</param>
      <param name="previousEdge">Previous edge</param>
      <param name="nextEdge">Next edge</param>
      <param name="previousFace">Previous face</param>
      <param name="nextFace">Next face</param>
      <param name="angle">Angle</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.EdgeData.ToString">
      <summary>Converts this Edge Data to a human readable string.</summary>
      <returns>A string that represents this Edge Frame.</returns>
    </member>
    <member name="T:devDept.Geometry.Entities.GSolid.EdgeFace">
      <summary>
            Edge face.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSolid.EdgeFace.NextFace">
      <summary>
            Next face
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSolid.EdgeFace.NextEdge">
      <summary>
            Next edge
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSolid.EdgeFace.PreviousFace">
      <summary>
            Previous face
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSolid.EdgeFace.PreviousEdge">
      <summary>
            Previous edge
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.EdgeFace.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Standard constructor.
            </summary>
      <param name="previousEdge">Previous edge</param>
      <param name="nextEdge">Next edge</param>
      <param name="previousFace">Previous face</param>
      <param name="nextFace">Previous face</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.EdgeFace.ToString">
      <summary>Converts this Edge Face to a human readable string.</summary>
      <returns>A string that represents this Edge Face.</returns>
    </member>
    <member name="T:devDept.Geometry.Entities.GSolid.Face">
      <summary>
            Face data.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSolid.Face.FirstContour">
      <summary>
            First contour
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSolid.Face.FaceLabel">
      <summary>
            Face label
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.Face.#ctor(System.Int32,System.Int32)">
      <summary>
            Standard constructor.
            </summary>
      <param name="firstContour">First contour</param>
      <param name="faceLabel">Face label</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.Face.ToString">
      <summary>Converts this Face to a human readable string.</summary>
      <returns>A string that represents this Face.</returns>
    </member>
    <member name="T:devDept.Geometry.Entities.GSolid.Cycle">
      <summary>
            Cycle data.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSolid.Cycle.FirstEdge">
      <summary>
            First Edge
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSolid.Cycle.NextContour">
      <summary>
            Next contour
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.Cycle.#ctor(System.Int32,System.Int32)">
      <summary>
            Standard constructor.
            </summary>
      <param name="firstEdge">First edge</param>
      <param name="nextContour">Next contour</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.#ctor">
      <summary>
            Empty constructor. For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.#ctor(System.Boolean)">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.#ctor(System.Boolean,devDept.Eyeshot.TextureMappingData,System.Collections.Generic.IList{devDept.Geometry.Entities.GSolid.Portion})">
      <summary>
            Boundary representation constructor.
            </summary>
      <param name="closed">
      </param>
      <param name="textureMapping">Texture mapping data</param>
      <param name="portions">Portions list</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.#ctor(System.Boolean,System.Collections.Generic.IList{devDept.Geometry.Entities.GSolid.Portion})">
      <summary>
            Constructor for the Eyeshot proprietary file format.
            </summary>
      <param name="closed">
      </param>
      <param name="portions">Portions list</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.Clone">
      <summary>
            Creates a deep copy of this solid.
            </summary>
      <returns>The new solid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.IsPointInside(devDept.Geometry.Point3D)">
      <summary>
            Checks if the specified point is inside the solid.
            </summary>
      <param name="point">The 3D point</param>
      <returns>True if the 3D point is inside the mesh, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.ConvertToMesh(System.Boolean)">
      <summary>
            Converts this solid into a mesh object.
            </summary>
      <param name="weldNow">If true, the resulting meshes are welded immediately.</param>
      <returns>The resulting mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.TransformBy(devDept.Geometry.Transformation)">
      <summary>
            Applies transformation matrix on 3D object
            </summary>
      <param name="transform">
      </param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.UpdateAngles">
      <summary>
            Updates the variable 'Angle' of array edgeDatas after a scaling transformation. 
            For Ticket #13399
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.GetFaces(System.Int32,System.Int32,System.Int32,System.Collections.Generic.List{System.Int32[]}@,System.Collections.Generic.List{devDept.Geometry.Vector3D[]}@,System.Double)">
      <summary>
            Get faces of 3D object
            </summary>
      <returns>List of faces</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.FromTriangles(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{devDept.Geometry.IndexTriangle})">
      <summary>
            Creates a solid from a list of vertices and triangles.
            </summary>
      <param name="vList">List of vertices</param>
      <param name="tList">List of index triangles</param>
      <returns>True if the operation is successfull, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.FromTriangles``1(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{devDept.Geometry.IndexTriangle})">
      <summary>
            Creates a solid from a list of vertices and triangles.
            </summary>
      <param name="vList">List of vertices</param>
      <param name="tList">List of index triangles</param>
      <returns>True if the operation is successfull, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.FromTriangles(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{devDept.Geometry.IndexTriangle},System.Double,System.Boolean,System.Double)">
      <summary>
            Creates a solid from a list of vertices and triangles.
            </summary>
      <param name="vList">List of vertices</param>
      <param name="tList">List of index triangles</param>
      <param name="smoothingAngle">Smoothing angle in radians</param>
      <param name="check">If true, tries to fix triangles that don't match (slower).</param>
      <param name="tol">Optional tolerance, start with domain size * 1e-6</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.FromTriangles``1(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{devDept.Geometry.IndexTriangle},System.Double,System.Boolean,System.Double)">
      <summary>
            Creates a solid from a list of vertices and triangles.
            </summary>
      <param name="vList">List of vertices</param>
      <param name="tList">List of index triangles</param>
      <param name="smoothingAngle">Smoothing angle in radians</param>
      <param name="check">If true, tries to fix triangles that don't match (slower).</param>
      <param name="tol">Optional tolerance, start with domain size * 1e-6</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSolid.FindClosestTriangle(devDept.Geometry.Transformation,devDept.Geometry.Segment3D)">
      <summary>
            Returns a list of triangles hit by the provided segment.
            </summary>
      <param name="transf">The transformation applied to the entity (necessary if the entity is inside a Block to propagate the BlockReference transformation)</param>
      <param name="seg">The 3D segment representing the viewing direction</param>
      <returns>The sorted list of triangles intersecting the provided segment.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GSolid.IsClosed">
      <summary>
             If true, the solid is closed.
            </summary>
    </member>
    <member name="T:devDept.Geometry.Entities.GBrep">
      <summary>
        <para>BRepÂ solid entity definition. A manifold solid B-rep is a finite, arcwise
            connected volume bounded by one or more gSurfaces, each of which is a connected,
            oriented, finite, closed 2-manifold. There is no restriction on the genus of the
            volume, nor on the number of voids within the volume.</para>
        <para>The Boundary Representation (B-rep) of a manifold solid utilizes a graph
            of edges and vertices embedded in a connected, oriented, finite, closed two
            manifold gSurface. The embedded graph divides the gSurface into arcwise connected
            areas known as faces. The edges and vertices, therefore, form the boundaries of
            the face and the domain of a face does not include its boundaries. The embedded
            graph may be disconnected and may be a pseudo graph. The graph is labeled; that
            is, each entity in the graph has a unique identity. The geometric gSurface
            definition used to specify the geometry of a face shall be 2-manifold embeddable
            in the plane within the domain of the face. In other words, it shall be
            connected, oriented, finite, non-self-intersecting, and of gSurface genus
            0.</para>
        <para>Faces do not intersect except along their boundaries. Each edge along the
            boundary of a face is shared by at most one other face in the assemblage. The
            assemblage of edges in the B-rep do not intersect except at their boundaries
            (i.e., vertices). The geometry igCurve definition used to specify the geometry of
            an edge shall be arcwise connected and shall not self intersect or overlap
            within the domain of the edge. The geometry of an edge shall be consistent with
            the geometry of the faces of which it forms a partial bound. The geometry used
            to define a vertex shall be consistent with the geometry of the faces and edges
            of which it forms a partial bound.</para>
        <para>A B-rep is represented by one or more closed shells which shall be
            disjoint. One shell, the outer, shall completely enclose all the other shells
            and no other shell may enclose a shell. </para>
      </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeRemove(devDept.Geometry.Entities.GRegion,System.Double)">
      <summary>
            Extrudes the specified region and removes it from the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="reg">The region</param>
      <param name="amount">The extrusion amount</param>
      <returns>True if the operation is successful, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeRemove(devDept.Geometry.Entities.GRegion,devDept.Geometry.Interval)">
      <summary>
            Extrudes the specified region and removes it from the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="reg">The region</param>
      <param name="amount">The extrusion amount</param>
      <returns>True if the operation is successful, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeRemove(devDept.Geometry.Entities.GRegion,System.Double,System.Double)">
      <summary>
            Extrudes the specified region with a draft angle and removes it from the original GBrep object.
            </summary>
      <param name="reg">The region</param>
      <param name="amount">The extrusion amount</param>
      <param name="angleInRadians">The draft angle in radians</param>
      <returns>True if the operation is successful, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeRemovePattern(devDept.Geometry.Entities.GRegion,System.Double,System.Double,System.Int32,System.Double,System.Int32)">
      <summary>
            Creates a rectangular pattern by extruding the specified region multiples times and removes it from the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="spacingX">The spacing between pattern instances for plane X direction</param>
      <param name="numberX">The number of pattern instances for plane X direction</param>
      <param name="spacingY">The spacing between pattern instances for plane Y direction</param>
      <param name="numberY">The number of pattern instances for plane Y direction</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeRemovePattern(devDept.Geometry.Entities.GRegion,devDept.Geometry.Interval,System.Double,System.Int32,System.Double,System.Int32)">
      <summary>
            Creates a rectangular pattern by extruding the specified region multiples times and removes it from the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="spacingX">The spacing between pattern instances for plane X direction</param>
      <param name="numberX">The number of pattern instances for plane X direction</param>
      <param name="spacingY">The spacing between pattern instances for plane Y direction</param>
      <param name="numberY">The number of pattern instances for plane Y direction</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeRemovePattern(devDept.Geometry.Entities.GRegion,System.Double,devDept.Geometry.Plane,System.Double,System.Int32,System.Double,System.Int32)">
      <summary>
            Creates a rectangular pattern by extruding the specified region multiples times and removes it from the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="patternPln">The plane used to create the rectangular pattern</param>
      <param name="spacingX">The spacing between pattern instances for plane X direction</param>
      <param name="numberX">The number of pattern instances for plane X direction</param>
      <param name="spacingY">The spacing between pattern instances for plane Y direction</param>
      <param name="numberY">The number of pattern instances for plane Y direction</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeRemovePattern(devDept.Geometry.Entities.GRegion,devDept.Geometry.Interval,devDept.Geometry.Plane,System.Double,System.Int32,System.Double,System.Int32)">
      <summary>
            Creates a rectangular pattern by extruding the specified region multiples times and removes it from the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="patternPln">The plane used to create the rectangular pattern</param>
      <param name="spacingX">The spacing between pattern instances for plane X direction</param>
      <param name="numberX">The number of pattern instances for plane X direction</param>
      <param name="spacingY">The spacing between pattern instances for plane Y direction</param>
      <param name="numberY">The number of pattern instances for plane Y direction</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeRemovePattern(devDept.Geometry.Entities.GRegion,System.Double,System.Double,System.Double,System.Int32,System.Double,System.Int32)">
      <summary>
            Creates a rectangular pattern by extruding the specified region multiples times and removes it from the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="angleInRadians">The draft angle in radians</param>
      <param name="spacingX">The spacing between pattern instances for plane X direction</param>
      <param name="numberX">The number of pattern instances for plane X direction</param>
      <param name="spacingY">The spacing between pattern instances for plane Y direction</param>
      <param name="numberY">The number of pattern instances for plane Y direction</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeRemovePattern(devDept.Geometry.Entities.GRegion,devDept.Geometry.Interval,System.Double,System.Double,System.Int32,System.Double,System.Int32)">
      <summary>
            Creates a rectangular pattern by extruding the specified region multiples times and removes it from the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="angleInRadians">The draft angle in radians</param>
      <param name="spacingX">The spacing between pattern instances for plane X direction</param>
      <param name="numberX">The number of pattern instances for plane X direction</param>
      <param name="spacingY">The spacing between pattern instances for plane Y direction</param>
      <param name="numberY">The number of pattern instances for plane Y direction</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeRemovePattern(devDept.Geometry.Entities.GRegion,System.Double,System.Double,devDept.Geometry.Plane,System.Double,System.Int32,System.Double,System.Int32)">
      <summary>
            Creates a rectangular pattern by extruding the specified region multiples times and removes it from the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="angleInRadians">The draft angle in radians</param>
      <param name="patternPln">The plane used to create the rectangular pattern</param>
      <param name="spacingX">The spacing between pattern instances for plane X direction</param>
      <param name="numberX">The number of pattern instances for plane X direction</param>
      <param name="spacingY">The spacing between pattern instances for plane Y direction</param>
      <param name="numberY">The number of pattern instances for plane Y direction</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeRemovePattern(devDept.Geometry.Entities.GRegion,devDept.Geometry.Interval,System.Double,devDept.Geometry.Plane,System.Double,System.Int32,System.Double,System.Int32)">
      <summary>
            Creates a rectangular pattern by extruding the specified region multiples times and removes it from the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="angleInRadians">The draft angle in radians</param>
      <param name="patternPln">The plane used to create the rectangular pattern</param>
      <param name="spacingX">The spacing between pattern instances for plane X direction</param>
      <param name="numberX">The number of pattern instances for plane X direction</param>
      <param name="spacingY">The spacing between pattern instances for plane Y direction</param>
      <param name="numberY">The number of pattern instances for plane Y direction</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeAddPattern(devDept.Geometry.Entities.GRegion,System.Double,System.Double,System.Int32,System.Double,System.Int32)">
      <summary>
            Creates a rectangular pattern by extruding the specified region multiples times and adds it to the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="spacingX">The spacing between pattern instances for plane X direction</param>
      <param name="numberX">The number of pattern instances for plane X direction</param>
      <param name="spacingY">The spacing between pattern instances for plane Y direction</param>
      <param name="numberY">The number of pattern instances for plane Y direction</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeAddPattern(devDept.Geometry.Entities.GRegion,devDept.Geometry.Interval,System.Double,System.Int32,System.Double,System.Int32)">
      <summary>
            Creates a rectangular pattern by extruding the specified region multiples times and adds it to the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="spacingX">The spacing between pattern instances for plane X direction</param>
      <param name="numberX">The number of pattern instances for plane X direction</param>
      <param name="spacingY">The spacing between pattern instances for plane Y direction</param>
      <param name="numberY">The number of pattern instances for plane Y direction</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeAddPattern(devDept.Geometry.Entities.GRegion,System.Double,devDept.Geometry.Plane,System.Double,System.Int32,System.Double,System.Int32)">
      <summary>
            Creates a rectangular pattern by extruding the specified region multiples times and adds it to the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="patternPln">The plane used to create the rectangular pattern</param>
      <param name="spacingX">The spacing between pattern instances for plane X direction</param>
      <param name="numberX">The number of pattern instances for plane X direction</param>
      <param name="spacingY">The spacing between pattern instances for plane Y direction</param>
      <param name="numberY">The number of pattern instances for plane Y direction</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeAddPattern(devDept.Geometry.Entities.GRegion,devDept.Geometry.Interval,devDept.Geometry.Plane,System.Double,System.Int32,System.Double,System.Int32)">
      <summary>
            Creates a rectangular pattern by extruding the specified region multiples times and adds it to the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="patternPln">The plane used to create the rectangular pattern</param>
      <param name="spacingX">The spacing between pattern instances for plane X direction</param>
      <param name="numberX">The number of pattern instances for plane X direction</param>
      <param name="spacingY">The spacing between pattern instances for plane Y direction</param>
      <param name="numberY">The number of pattern instances for plane Y direction</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeAddPattern(devDept.Geometry.Entities.GRegion,System.Double,System.Double,System.Double,System.Int32,System.Double,System.Int32)">
      <summary>
            Creates a rectangular pattern by extruding the specified region multiples times and adds it to the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="draftAngleInRadians">The draft angle in radians</param>
      <param name="spacingX">The spacing between pattern instances for plane X direction</param>
      <param name="numberX">The number of pattern instances for plane X direction</param>
      <param name="spacingY">The spacing between pattern instances for plane Y direction</param>
      <param name="numberY">The number of pattern instances for plane Y direction</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeAddPattern(devDept.Geometry.Entities.GRegion,devDept.Geometry.Interval,System.Double,System.Double,System.Int32,System.Double,System.Int32)">
      <summary>
            Creates a rectangular pattern by extruding the specified region multiples times and adds it to the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="draftAngleInRadians">The draft angle in radians</param>
      <param name="spacingX">The spacing between pattern instances for plane X direction</param>
      <param name="numberX">The number of pattern instances for plane X direction</param>
      <param name="spacingY">The spacing between pattern instances for plane Y direction</param>
      <param name="numberY">The number of pattern instances for plane Y direction</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeAddPattern(devDept.Geometry.Entities.GRegion,System.Double,System.Double,devDept.Geometry.Plane,System.Double,System.Int32,System.Double,System.Int32)">
      <summary>
            Creates a rectangular pattern by extruding the specified region multiples times and adds it to the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="draftAngleInRadians">The draft angle in radians</param>
      <param name="patternPln">The plane used to create the rectangular pattern</param>
      <param name="spacingX">The spacing between pattern instances for plane X direction</param>
      <param name="numberX">The number of pattern instances for plane X direction</param>
      <param name="spacingY">The spacing between pattern instances for plane Y direction</param>
      <param name="numberY">The number of pattern instances for plane Y direction</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeAddPattern(devDept.Geometry.Entities.GRegion,devDept.Geometry.Interval,System.Double,devDept.Geometry.Plane,System.Double,System.Int32,System.Double,System.Int32)">
      <summary>
            Creates a rectangular pattern by extruding the specified region multiples times and adds it to the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="draftAngleInRadians">The draft angle in radians</param>
      <param name="patternPln">The plane used to create the rectangular pattern</param>
      <param name="spacingX">The spacing between pattern instances for plane X direction</param>
      <param name="numberX">The number of pattern instances for plane X direction</param>
      <param name="spacingY">The spacing between pattern instances for plane Y direction</param>
      <param name="numberY">The number of pattern instances for plane Y direction</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeRemovePattern(devDept.Geometry.Entities.GRegion,System.Double,devDept.Geometry.Point3D,System.Double,System.Int32)">
      <summary>
            Creates a circular pattern by extruding the specified region multiples times and removes it from the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="center">The circular pattern center</param>
      <param name="angleInRadians">The angle between each instance</param>
      <param name="number">The number of instances</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeRemovePattern(devDept.Geometry.Entities.GRegion,devDept.Geometry.Interval,devDept.Geometry.Point3D,System.Double,System.Int32)">
      <summary>
            Creates a circular pattern by extruding the specified region multiples times and removes it from the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="center">The circular pattern center</param>
      <param name="angleInRadians">The angle between each instance</param>
      <param name="number">The number of instances</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeRemovePattern(devDept.Geometry.Entities.GRegion,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Double,System.Int32)">
      <summary>
            Creates a circular pattern by extruding the specified region multiples times and removes it from the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="axis">The circular pattern axis</param>
      <param name="center">The circular pattern center</param>
      <param name="angleInRadians">The angle between each instance</param>
      <param name="number">The number of instances</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeRemovePattern(devDept.Geometry.Entities.GRegion,devDept.Geometry.Interval,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Double,System.Int32)">
      <summary>
            Creates a circular pattern by extruding the specified region multiples times and removes it from the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="axis">The circular pattern axis</param>
      <param name="center">The circular pattern center</param>
      <param name="angleInRadians">The angle between each instance</param>
      <param name="number">The number of instances</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeRemovePattern(devDept.Geometry.Entities.GRegion,System.Double,System.Double,devDept.Geometry.Point3D,System.Double,System.Int32)">
      <summary>
            Creates a circular pattern by extruding the specified region multiples times and removes it from the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="draftAngleInRadians">The draft angle in radians</param>
      <param name="center">The circular pattern center</param>
      <param name="angleInRadians">The angle between each instance</param>
      <param name="number">The number of instances</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeRemovePattern(devDept.Geometry.Entities.GRegion,devDept.Geometry.Interval,System.Double,devDept.Geometry.Point3D,System.Double,System.Int32)">
      <summary>
            Creates a circular pattern by extruding the specified region multiples times and removes it from the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="draftAngleInRadians">The draft angle in radians</param>
      <param name="center">The circular pattern center</param>
      <param name="angleInRadians">The angle between each instance</param>
      <param name="number">The number of instances</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeRemovePattern(devDept.Geometry.Entities.GRegion,System.Double,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Double,System.Int32)">
      <summary>
            Creates a circular pattern by extruding the specified region multiples times and removes it from the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="draftAngleInRadians">The draft angle in radians</param>
      <param name="axis">The circular pattern axis</param>
      <param name="center">The circular pattern center</param>
      <param name="angleInRadians">The angle between each instance</param>
      <param name="number">The number of instances</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeRemovePattern(devDept.Geometry.Entities.GRegion,devDept.Geometry.Interval,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Double,System.Int32)">
      <summary>
            Creates a circular pattern by extruding the specified region multiples times and removes it from the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">The extrusion amount</param>
      <param name="draftAngleInRadians">The draft angle in radians</param>
      <param name="axis">The circular pattern axis</param>
      <param name="center">The circular pattern center</param>
      <param name="angleInRadians">The angle between each instance</param>
      <param name="number">The number of instances</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeAddPattern(devDept.Geometry.Entities.GRegion,System.Double,devDept.Geometry.Point3D,System.Double,System.Int32)">
      <summary>
            Creates a circular pattern by extruding the specified region multiples times and adds it to the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">Extrusion amount</param>
      <param name="center">Circular pattern center</param>
      <param name="angleInRadians">Angle between each instance</param>
      <param name="number">Number of instances</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeAddPattern(devDept.Geometry.Entities.GRegion,devDept.Geometry.Interval,devDept.Geometry.Point3D,System.Double,System.Int32)">
      <summary>
            Creates a circular pattern by extruding the specified region multiples times and adds it to the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">Extrusion amount</param>
      <param name="center">Circular pattern center</param>
      <param name="angleInRadians">Angle between each instance</param>
      <param name="number">Number of instances</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeAddPattern(devDept.Geometry.Entities.GRegion,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Double,System.Int32)">
      <summary>
            Creates a circular pattern by extruding the specified region multiples times and adds it to the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">Extrusion amount</param>
      <param name="axis">Circular pattern axis</param>
      <param name="center">Circular pattern center</param>
      <param name="angleInRadians">Angle between each instance</param>
      <param name="number">Number of instances</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeAddPattern(devDept.Geometry.Entities.GRegion,devDept.Geometry.Interval,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Double,System.Int32)">
      <summary>
            Creates a circular pattern by extruding the specified region multiples times and adds it to the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">Extrusion amount</param>
      <param name="axis">Circular pattern axis</param>
      <param name="center">Circular pattern center</param>
      <param name="angleInRadians">Angle between each instance</param>
      <param name="number">Number of instances</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeAddPattern(devDept.Geometry.Entities.GRegion,System.Double,System.Double,devDept.Geometry.Point3D,System.Double,System.Int32)">
      <summary>
            Creates a circular pattern by extruding the specified region multiples times and adds it to the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">Extrusion amount</param>
      <param name="draftAngleInRadians">The draft angle in radians</param>
      <param name="center">Circular pattern center</param>
      <param name="angleInRadians">Angle between each instance</param>
      <param name="number">Number of instances</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeAddPattern(devDept.Geometry.Entities.GRegion,devDept.Geometry.Interval,System.Double,devDept.Geometry.Point3D,System.Double,System.Int32)">
      <summary>
            Creates a circular pattern by extruding the specified region multiples times and adds it to the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">Extrusion amount</param>
      <param name="draftAngleInRadians">The draft angle in radians</param>
      <param name="center">Circular pattern center</param>
      <param name="angleInRadians">Angle between each instance</param>
      <param name="number">Number of instances</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeAddPattern(devDept.Geometry.Entities.GRegion,System.Double,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Double,System.Int32)">
      <summary>
            Creates a circular pattern by extruding the specified region multiples times and adds it to the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">Extrusion amount</param>
      <param name="draftAngleInRadians">The draft angle in radians</param>
      <param name="axis">Circular pattern axis</param>
      <param name="center">Circular pattern center</param>
      <param name="angleInRadians">Angle between each instance</param>
      <param name="number">Number of instances</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeAddPattern(devDept.Geometry.Entities.GRegion,devDept.Geometry.Interval,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Double,System.Int32)">
      <summary>
            Creates a circular pattern by extruding the specified region multiples times and adds it to the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="region">The region to extrude</param>
      <param name="amount">Extrusion amount</param>
      <param name="draftAngleInRadians">The draft angle in radians</param>
      <param name="axis">Circular pattern axis</param>
      <param name="center">Circular pattern center</param>
      <param name="angleInRadians">Angle between each instance</param>
      <param name="number">Number of instances</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeAdd(devDept.Geometry.Entities.GRegion,System.Double)">
      <summary>
            Extrudes the specified region, overriding the original GBrep with the result of the cut and adds it to the original GBrep object.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="reg">The region</param>
      <param name="amount">The extrusion amount</param>
      <returns>True if the operation is successful, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeAdd(devDept.Geometry.Entities.GRegion,System.Double,System.Double)">
      <summary>
            Extrudes the specified region with a draft angle and adds it to the original GBrep object.
            </summary>
      <param name="reg">The region</param>
      <param name="amount">The extrusion amount</param>
      <param name="angleInRadians">The draft angle in radians</param>
      <returns>True if the operation is successful, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeAdd(devDept.Geometry.Entities.GRegion,devDept.Geometry.Interval)">
      <summary>
            Extrudes the specified region and adds it to the original GBrep object.
            </summary>
      <param name="reg">The region</param>
      <param name="amount">The extrusion amount interval</param>
      <returns>True if the operation is successful, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <!-- Badly formed XML comment ignored for member "M:devDept.Geometry.Entities.GBrep.ExtrudeFace(System.Int32,System.Double)" -->
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeFace(System.Int32,devDept.Geometry.Vector3D,System.Double)">
      <summary>
             Extrudes the specified Face, overriding the original GBrep.
             </summary>
      <param name="faceIndex">the face index</param>
      <param name="amount">The extrusion amount</param>
      <param name="angleInRadians">The draft angle in radians</param>
      <remarks>For this operation in particular, the specified face index will be kept along all the ExtrudeFace()(/RevolveFace() subsequent operations to make easier sheet metal part modeling.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.RevolveFace(System.Int32,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D)">
      <summary>
             Revolves the specified Face, overriding the original GBrep.
             </summary>
      <param name="faceIndex">the face index</param>
      <param name="deltaAngle">Revolution angle in radians</param>
      <param name="axis">Axis direction</param>
      <param name="center">Axis start point</param>
      <remarks>For this operation in particular, the specified face index will be kept along all the ExtrudeFace()(/RevolveFace() subsequent operations to make easier sheet metal part modeling.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.AddFlange(System.Int32,System.Double,System.Double,System.Double)">
      <summary>
            Adds a sheet metal flange to the specified edge.
            </summary>
      <param name="edgeIndex">The edge index</param>
      <param name="radius">The bend radius</param>
      <param name="amount">The bend length</param>
      <param name="angle">The bend angle</param>
      <returns>True if the operation succeeded. False otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.RevolveRemove(devDept.Geometry.Entities.GRegion,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D)">
      <summary>
            Revolves the specified region and removes it from the GBrep object and removes it from the original GBrep object.
            </summary>
      <param name="reg">The region</param>
      <param name="angle">Revolution angle in radians</param>
      <param name="axis">Axis direction</param>
      <param name="center">Axis start point</param>
      <returns>True if the operation is successful, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.RevolveRemove(devDept.Geometry.Entities.GRegion,System.Double,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D)">
      <summary>
            Revolves the specified region and removes it from the GBrep object and removes it from the original GBrep object.
            </summary>
      <param name="reg">The region</param>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axis">Axis direction</param>
      <param name="center">Axis start point</param>
      <returns>True if the operation is successful, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.RevolveAdd(devDept.Geometry.Entities.GRegion,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D)">
      <summary>
            Revolves the specified region and adds it to the GBrep object and adds it to the original GBrep object.
            </summary>
      <param name="reg">The region</param>
      <param name="angle">Revolution angle in radians</param>
      <param name="axis">Axis direction</param>
      <param name="center">Axis start point</param>
      <returns>True if the operation is successful, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.RevolveAdd(devDept.Geometry.Entities.GRegion,System.Double,System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D)">
      <summary>
            Revolves the specified region and adds it to the GBrep object and adds it to the original GBrep object.
            </summary>
      <param name="reg">The region</param>
      <param name="startAngle">Revolution start angle in radians</param>
      <param name="deltaAngle">Revolution delta angle in radians</param>
      <param name="axis">Axis direction</param>
      <param name="center">Axis start point</param>
      <returns>True if the operation is successful, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Remove(devDept.Geometry.Entities.GBrep[])">
      <summary>
            Removes a list of non-intersecting solids from the original GBrep object.
            </summary>
      <param name="solids">The list of disjoint breps to remove</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Remove(System.Collections.Generic.IList{devDept.Geometry.Entities.GBrep},devDept.Geometry.Entities.GBrep[]@)">
      <summary>
            Removes a list of non-intersecting solids from the original GBrep object.
            </summary>
      <param name="solids">The list of disjoint breps to remove</param>
      <param name="leftOvers">The resulting left overs of the operation (null if not present)</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Add(devDept.Geometry.Entities.GBrep[])">
      <summary>
            Adds a list of non-intersecting solids to the original GBrep object.
            </summary>
      <param name="solids">The list of disjoint breps to add</param>
      <returns>True if the operation succeeded, false otherwise keeping the GBrep object unmutated.</returns>
    </member>
    <member name="T:devDept.Geometry.Entities.GBrep.booleanOperationType">
      <summary>
            Boolean operation type.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GBrep.RebuildTolerance">
      <summary>
            Gets or sets the rebuild tolerance used by GBrep section, cut and boolean operations.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Difference(devDept.Geometry.Entities.GBrep,devDept.Geometry.Entities.GBrep)">
      <summary>
            Compute the difference of the solidA with the solidB.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="solidB">
      </param>
      <returns>An array of solids if the operation is successful, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Intersection(devDept.Geometry.Entities.GBrep,devDept.Geometry.Entities.GBrep)">
      <summary>
        <para>Compute the Intersection of the solidA (gray in the sample picture below)
            with the solidB (blue), and return the resulting array of <see cref="!:Brep" />
            (green). TheÂ returned array may have more than oneÂ elementÂ if multipleÂ disjoint
            intersectionsÂ are found.</para>
        <para>
          <img src="intersection.png" />
        </para>
      </summary>
      <param name="solidA">First solid</param>
      <param name="solidB">Second solid</param>
      <returns>
            An array of <see cref="!:Brep" /> containing the intersections if the operation is
            successful. If the operation is successful but no intersectionsÂ are found, an
            empty arrayÂ is returned. Otherwise, if due to an error the algorithmÂ fails to
            compute the intersections,Â null/Nothing is returned.
            </returns>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology">FixTopology method</seealso>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Union(devDept.Geometry.Entities.GBrep,devDept.Geometry.Entities.GBrep)">
      <summary>
             Compute the Union of the solidA with the solidB.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="solidA">
      </param>
      <param name="solidB">
      </param>
      <returns>An array of solids if the operation is successful, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Mirror(System.Int32,devDept.Geometry.Entities.GBrep)">
      <summary>
            Create a mirror entity from the input GBrep by the plane provided.
            </summary>
      <param name="planarFaceIndex">The face index of the GBrep in input needed to get the mirror plane</param>
      <param name="solid">The GBrep entity to mirror</param>
      <returns> The resulting GBrep union between the original input GBrep and the mirrored one.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Mirror(devDept.Geometry.Entities.GBrep.Face,devDept.Geometry.Entities.GBrep)">
      <summary>
            Create a mirror entity from the input GBrep by the plane provided.
            </summary>
      <param name="planarFace">The face of the GBrep in input to use to get the mirror plane</param>
      <param name="solid">The GBrep entity to mirror</param>
      <returns> The resulting GBrep union between the original input GBrep and the mirrored one.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Mirror(devDept.Geometry.Plane,devDept.Geometry.Entities.GBrep)">
      <summary>
            Create a mirror entity from the input GBrep by the provided plane.
            </summary>
      <param name="mirrorPlane">The plane to use to mirror the entity</param>
      <param name="solid">The GBrep entity to mirror</param>
      <returns> The resulting GBrep union between the original input GBrep and the mirrored one.</returns>
    </member>
    <!-- Badly formed XML comment ignored for member "M:devDept.Geometry.Entities.GBrep.MergeAndKeepFaces(devDept.Geometry.Entities.GBrep,devDept.Geometry.Entities.GBrep)" -->
    <!-- Badly formed XML comment ignored for member "M:devDept.Geometry.Entities.GBrep.MergeAndKeepFaces(System.Collections.Generic.IList{devDept.Geometry.Entities.GBrep},devDept.Geometry.Entities.GBrep@)" -->
    <!-- Badly formed XML comment ignored for member "M:devDept.Geometry.Entities.GBrep.MergeAndKeepFaces(System.Collections.Generic.IList{devDept.Geometry.Entities.GBrep})" -->
    <member name="M:devDept.Geometry.Entities.GBrep.MergeFaces">
      <summary>
            Merges coplanar faces when possible.
            </summary>
      <remarks>Rebuild() method could be necessary before to call this.</remarks>
      <returns>then number of the removed faces after merge. -1 if an error occured.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.CreateBox(System.Double,System.Double,System.Double,System.Double)">
      <summary>Creates a box primitive.</summary>
      <param name="width">Box's width</param>
      <param name="depth">Box's depth</param>
      <param name="height">Box's height</param>
      <param name="tolerance">the regeneration tolerance. 0 for default value</param>
      <returns>The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.CreateCylinder(System.Double,System.Double,System.Double)">
      <summary>
             Creates a Cylinder primitive.
             </summary>
      <param name="radius">Cylinder's radius</param>
      <param name="height">Cylinder's height</param>
      <param name="tolerance">the regeneration tolerance. 0 for default value</param>
      <returns>The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.CreateCone(System.Double,System.Double)">
      <summary>Creates a Cone primitive.</summary>
      <param name="baseRadius">Cone's base radius</param>
      <param name="height">The cone's height</param>
      <returns>The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.CreateCone(System.Double,System.Double,System.Double,System.Double)">
      <summary>Creates a Cone primitive.</summary>
      <param name="baseRadius">Cone's base radius</param>
      <param name="topRadius">Cone's top radius</param>
      <param name="height">The cone's height</param>
      <param name="tolerance">the regeneration tolerance. 0 for default value</param>
      <returns>The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.CreateCone(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Creates an Eccentric Cone primitive.
            </summary>
      <param name="baseRadius">Cone's base radius</param>
      <param name="baseInnerRadius">Cone's base inner radius. 0 if the eccentric cone hasn't an inner offset</param>
      <param name="topRadius">Cone's top radius</param>
      <param name="topInnerRadius">Cone's top inner radius. 0 if the eccentric cone hasn't an inner offset</param>
      <param name="height">The cone's height</param>
      <param name="distance">Distance between GCircle centers, both projected on the base plane</param>
      <param name="tolerance">The regeneration tolerance. 0 for default value</param>
      <returns>The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.CreateSphere(System.Double,System.Double)">
      <summary>
             Creates a Sphere primitive.
             </summary>
      <param name="radius">Sphere's radius</param>
      <param name="tolerance">the regeneration tolerance. 0 for default value</param>
      <returns>The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.CreateTorus(System.Double,System.Double,System.Double)">
      <summary>
             Creates a Torus primitive.
             </summary>
      <param name="majorRadius">Torus radius</param>
      <param name="minorRadius">Torus section radius</param>
      <param name="tolerance">the regeneration tolerance. 0 for default value</param>
      <returns>The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Ruled(devDept.Geometry.Entities.GSurface,devDept.Geometry.Entities.GSurface,System.Double)">
      <summary>
            Create a GBrep connecting linearly two gSurfaces.
            </summary>
      <remarks> The two gSurfaces must have the same orientation, with the normal of the first one pointing towards the inside of the resulting brep, and the same number of igCurves in the same order.</remarks>
      <param name="bottom">the bottom gSurface to connect</param>
      <param name="top">the top gSurface to connect</param>
      <param name="tolerance">the regeneration tolerance. 0 for default value</param>
      <returns>The resulting GBrep object.</returns>
      <remarks> The two gSurfaces should not have collapsed edges.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Loft(devDept.Geometry.Entities.IGCurve[])">
      <summary>
            Creates a GBrep from skinning. 
            </summary>
      <param name="curveList">The skinning igCurves</param>
      <returns>The resulting GBrep if the operation succeeds, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Loft(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Double)">
      <summary>
            Creates a GBrep from skinning. 
            </summary>
      <param name="curveList">The skinning igCurves</param>
      <param name="degree">The desired gSurface degree</param>
      <param name="splitAtCorners">If True, it splits the igCurves at corner points. It is useful when the sections are Composite Curves with similar shape, and you want to line up the corners (and curve segments) in the resulting GBrep.</param>
      <param name="endCaps">if true, it creates a closed GBrep</param>
      <param name="speedChange"> Works only when splitAtCorners is true. If true, when the tangents have the same direction but different lengths, the curve will be split. 
                If false, it won't be split.</param>
      <param name="tolerance">the regeneration tolerance. 0 for default value</param>
      <returns>The resulting GBrep if the operation succeeds, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeWithTwist(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Double,System.Double,System.Boolean)">
      <summary>
            Creates a brep extruding and twisting a planar curve.. 
            </summary>
      <param name="curve">The curve to extrude</param>
      <param name="direction">Extrusion direction, normal to the plane of the curve</param>
      <param name="center">point of application for the direction, on the plane of the curve</param>
      <param name="angle">Twist angle in radians</param>
      <param name="tol">Tolerance</param>
      <param name="endCaps">If true, creates a closed GBrep</param>
      <returns>The resulting GBrep if the operation succeeds, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ExtrudeWithTwist(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Double,System.Int32,System.Boolean,System.Double)">
      <summary>
            Creates a brep extruding and twisting a planar curve.. 
            </summary>
      <param name="curve">The curve to extrude</param>
      <param name="direction">Extrusion direction, normal to the plane of the curve</param>
      <param name="center">point of application for the direction, on the plane of the curve</param>
      <param name="angle">Twist angle in radians</param>
      <param name="numberOfSections">Number of internal sections to be interpolated, it corresponds to the number of distinct internal knots in the extrusion gSurface's U direction.</param>
      <param name="endCaps">If true, creates a closed GBrep</param>
      <param name="rebuildTol">The regeneration tolerance. 0 for default value</param>
      <returns>The resulting GBrep if the operation succeeds, null/Nothing otherwise.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GBrep.Vertices">
      <summary>
            Gets or sets vertices array.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GBrep.Edges">
      <summary>
            Gets or sets edge array.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GBrep.ConvexHull">
      <summary>
            The convex hull of the GBrep.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.GetPlanarFaceRegion(System.Int32)">
      <summary>
            Gets the planar face region.
            </summary>
      <param name="index">The face index</param>
      <returns>A <see cref="!:Entities.Region" />, null/nothing otherwise.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GBrep.Faces">
      <summary>
            Gets or sets outer shell face array.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GBrep.Inners">
      <summary>
            Gets or sets inner (void) shells face array.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.#ctor(devDept.Geometry.Point3D[],devDept.Geometry.Entities.GBrep.Edge[],devDept.Geometry.Entities.GBrep.Face[],devDept.Geometry.Entities.GBrep.Face[][],System.Boolean,System.Double)">
      <summary>
            Inner shells constructor.
            </summary>
      <param name="vertices">The vertex array</param>
      <param name="edges">The edge array</param>
      <param name="faces">The outer shell face array</param>
      <param name="inners">The inner shells face array</param>
      <param name="splitEdgesOnSeams">If yes, it splits all the edges that intersect the seams of the faces</param>
      <param name="tolerance">The rebuild tolerance</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.#ctor(devDept.Geometry.Point3D[],devDept.Geometry.Entities.GBrep.Edge[],devDept.Geometry.Entities.GBrep.Face[],System.Boolean,devDept.Geometry.Entities.GBrep.Face[][],System.Boolean,System.Double)">
      <summary>
            Inner shells constructor. For internal use only.
            </summary>
      <param name="vertices">The vertex array</param>
      <param name="edges">The edge array</param>
      <param name="faces">The outer shell face array</param>
      <param name="buildParents">When the shell definition comes from STEP/IGES or EYE import Edge.Parents is ready to use, otherwise it's null.</param>
      <param name="inners">The inner shells face array</param>
      <param name="splitEdgesOnSeams">If yes, it splits all the edges that intersect the seams of the faces</param>
      <param name="tolerance">The rebuild tolerance</param>
            TODO Geo TRS: rimettere internal dopo conversione translator
        </member>
    <member name="M:devDept.Geometry.Entities.GBrep.#ctor(devDept.Geometry.Entities.GBrep.Face[],devDept.Geometry.Entities.GBrep.Face[][])">
      <summary>
            Proprietary file format constructor.
            </summary>
      <param name="faces">The faces stored in the file.</param>
      <param name="inners">The inners stored in the file.</param>
      <seealso cref="!:BrepSurrogate.ConvertToObject" />
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Clone">
      <summary>
            Creates a deep copy of this Solid.
            </summary>
      <returns>The new solid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.GetError">
      <summary>
            Gets the maximum gap between face loops' edge curves.
            </summary>
      <returns>The maximum gap value.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Rebuild(System.Double,System.Boolean)">
      <summary>
            Builds parametric face representation using the specified tolerance.
            </summary>
      <param name="tol">Rebuild tolerance, zero for default.</param>
      <param name="soft">When true, only faces without parametric surfaces are rebuilt.</param>
      <remarks> Using soft = true with an input tolerance different from <see cref="P:devDept.Geometry.Entities.GBrep.RebuildTolerance" /> could generate a  not-watertight Brep.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.GetStraightEdgeIndex(devDept.Geometry.Point3D,devDept.Geometry.Vector3D)">
      <summary>
            Gets the edge index containing the 3D input point.
            </summary>
      <param name="pointOnEdge">A point lying on the desired edge Can be null/Nothing.</param>
      <param name="direction">The edge direction helping to find the desired edge if the pointOnEdge lies on a GBrep vertex. It can be null/Nothing.</param>
      <returns>An integer representing the index of the first edge that satisfies the requirements. -1 if the operation failed.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.GetPlanarFaceIndex(devDept.Geometry.Plane,devDept.Geometry.Point3D)">
      <summary>
            Gets the index of the planar face coincident with the specified plane.
            </summary>
      <param name="plane">A plane coincident with the face's one</param>
      <param name="pointOnFace">A point inside the face contour to help identify coplanar faces. Can be null/Nothing.</param>
      <returns>An integer representing the index of the first face that satisfies the requirements.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ConvertToSurfaces(System.Double)">
      <summary>
            Converts this GBrep to a list of individual gSurfaces.
            </summary>
      <param name="rebuildTol">Conversion tolerance, zero for default one.</param>
      <returns>An array of gSurfaces</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ConvertToSolid(System.Double,System.Double)">
      <summary>
            Converts this Brep to <see cref="!:Solid" /> using the specified tolerance.
            </summary>
      <param name="deviation">The maximum deviation, zero for current tessellation.</param>
      <param name="angle">The maximum angular deflection, ignored when zero.</param>
      <returns>The resulting Solid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ConvertToMesh(System.Double,System.Double,devDept.Geometry.Entities.GMesh.natureType,System.Boolean)">
      <summary>
            Converts this Brep to a <see cref="T:devDept.Geometry.Entities.GMesh" /> using the specified tolerance.
            </summary>
      <param name="deviation">The maximum deviation, zero for current tessellation.</param>
      <param name="angle">The maximum angular deflection, ignored when zero.</param>
      <param name="meshNature">The desired GMesh <see cref="T:devDept.Geometry.Entities.GMesh.natureType">nature</see></param>
      <param name="weldNow">When true, the resulting meshes are welded immediately.</param>
      <returns>The resulting <see cref="T:devDept.Geometry.Entities.GMesh" /> object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ConvertToMesh(System.Double,System.Boolean,System.Double)">
      <summary>
            Converts this Brep to a <see cref="T:devDept.Geometry.Entities.GMesh" /> using the specified triangle size.
            </summary>
      <param name="maxLength">The maximum triangle edge length</param>
      <param name="weldNow">When true, the resulting face meshes are welded immediately.</param>
      <param name="weldMaxGap">The welding maximum acceptable gap between vertices. Zero for auto-estimation.</param>
      <returns>The resulting <see cref="T:devDept.Geometry.Entities.GMesh" /> object.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GBrep.IsClosed">
      <summary>
            Gets the shell closure status.
            </summary>
      <returns>True if the shell is closed, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.ClosestPointTo(devDept.Geometry.Point3D,devDept.Geometry.Point3D@)">
      <summary>
            Computes the signed distance between a 3D point and this GBrep object.
            </summary>
      <param name="P">The 3D point</param>
      <param name="closest">The closest 3D point to P</param>
      <returns>The signed distance with this GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.FixTopology">
      <summary>
            If the geometry is not created inside Eyeshot, it could be necessary call this method to check and fix/add(if needed) missing data,
             to correctly perform operations like Section/Intersection and Booleans.
            </summary>
      <remarks>The original brep is modified with the operation is successful.</remarks>
      <returns> Return true if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.SplitBy(devDept.Geometry.Plane,devDept.Geometry.Entities.GBrep[]@,devDept.Geometry.Entities.GBrep[]@)">
      <summary>
            Splits this solid with the specified plane.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="pln">The cutting plane</param>
      <param name="left">The resulting set of left GBrep objects</param>
      <param name="right">The resulting set of right GBrep objects</param>
      <returns>The intersection failure type.</returns>
      <remarks>If the operation is <see cref="F:devDept.Geometry.booleanFailureType.Success" /> both left and right are filled, otherwise it exits at the first failure.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.SplitBy(devDept.Geometry.Entities.GSurface,devDept.Geometry.Entities.GBrep[]@,devDept.Geometry.Entities.GBrep[]@)">
      <summary>
            Splits this solid with the specified plane.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="G">The cutting GSurface</param>
      <param name="left">The resulting set of left GBrep objects</param>
      <param name="right">The resulting set of right GBrep objects</param>
      <returns>The intersection failure type.</returns>
      <remarks>If the operation is <see cref="F:devDept.Geometry.booleanFailureType.Success" /> both left and right are filled, otherwise it exits at the first failure.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.CutBy(devDept.Geometry.Plane,System.Boolean)">
      <summary>
            Cut the GBrep with the Plane, overriding the original GBrep with the result of the cut.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="pln"> cutting plane</param>
      <param name="flip">When true the cut direction is inverted</param>
      <returns>The intersection failure type.</returns>
      <remarks>If the operation is <see cref="F:devDept.Geometry.booleanFailureType.Success" /> the GBrep is modified, otherwise the original Brep is unmutated.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.CutBy(devDept.Geometry.Plane,devDept.Geometry.Entities.GBrep[]@,System.Boolean)">
      <summary>
            Cut the GBrep with the Plane, overriding the original GBrep with the result of the cut.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="pln">The cutting plane</param>
      <param name="leftOvers">The possible left over solid objects</param>
      <param name="flip">When true the cut direction is inverted</param>
      <returns>The intersection failure type.</returns>
      <remarks>If the operation is <see cref="F:devDept.Geometry.booleanFailureType.Success" /> the GBrep is modified, otherwise the original Brep is unmutated.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.CutBy(devDept.Geometry.Entities.GSurface,System.Boolean)">
      <summary>
            Cuts this solid with the specified plane, overriding the original GBrep with the result of the cut.
            </summary>
      <param name="gSurface">The cutting gSurface</param>
      <param name="flip">When true the cut direction is inverted</param>
      <returns>If true the operation succeeds and the original GBrep is modified, otherwise the operation failed and the original GBrep is unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.CutBy(devDept.Geometry.Entities.GSurface,devDept.Geometry.Entities.GBrep[]@,System.Boolean)">
      <summary>
            Cuts this solid with the specified plane, overriding the original GBrep with the result of the cut.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="gSurface">The cutting gSurface</param>
      <param name="leftOvers">The possible left over solid objects</param>
      <param name="flip">When true the cut direction is inverted</param>
      <returns>If true the operation succeeds and the original GBrep is modified, otherwise the operation failed and the original GBrep is unmutated.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.SubdivideBy(System.Int32,System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve})">
      <summary>
            Subdivide a GBrep face by the given curve list.
            </summary>
      <param name="faceIndex">The position index of the face into GBrep.Faces array.</param>
      <param name="contours">The disjoint contours (lying on the selected face) to be used to split the face.</param>
      <remarks>The resulting GBrep can't be used to perform Boolean operations.</remarks>
      <remarks>The usage of SubdivideBy is suggested at the end of the model construction, for example to perform FEM analysis.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.SubdivideBy(System.Int32,devDept.Geometry.Plane)">
      <summary>
            Subdivide a GBrep face by the given plane.
            </summary>
      <param name="faceIndex">The position index of the face into GBrep.Faces array.</param>
      <param name="plane">The plane used to split the faces.</param>
      <remarks>The resulting GBrep can't be used to perform Boolean operations.</remarks>
      <remarks>The usage of SubdivideBy is suggested at the end of the model construction, for example to perform FEM analysis.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.SubdivideBy(devDept.Geometry.Plane)">
      <summary>
            Subdivide all the GBrep faces by the given plane.
            </summary>
      <param name="plane">The plane used to split the faces.</param>
      <remarks>The resulting GBrep can't be used to perform Boolean operations.</remarks>
      <remarks>The usage of SubdivideBy is suggested at the end of the model construction, for example to perform FEM analysis.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.IsPointInside(devDept.Geometry.Point3D,System.Boolean)">
      <summary>
            Checks if the specified point is inside or onto the GBrep.
            </summary>
      <param name="point">The 3D point</param>
      <param name="skipRebuild">If true, we avoid rebuilding the GBrep internally.</param>
      <returns>The point status.</returns>
    </member>
    <member name="T:devDept.Geometry.Entities.GBrep.Vertex">
      <summary>
            Brep edge definition
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GBrep.Vertex.Parents">
      <summary>
            Parents edges.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Vertex.#ctor(System.Double,System.Double,System.Double)">
      <summary>
            Standard constructor.
            </summary>
      <param name="x">X coordinate value</param>
      <param name="y">Y coordinate value</param>
      <param name="z">Z coordinate value</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Vertex.#ctor(System.Double[])">
      <summary>
            Double array constructor.
            </summary>
      <param name="coords">The XYZ coordinates as a double array</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Vertex.Clone">
      <summary>
            Creates a deep copy of this Edge.
            </summary>
      <returns>The new edge object.</returns>
    </member>
    <member name="T:devDept.Geometry.Entities.GBrep.Edge">
      <summary>
            Brep edge definition
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GBrep.Edge.StartPointIndex">
      <summary>
            Edge start point index.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GBrep.Edge.EndPointIndex">
      <summary>
            Edge end point index.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GBrep.Edge.Curve">
      <summary>
            Edge curve.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GBrep.Edge.ShellIndex">
      <summary>
            Index of the owner shell. Zero represents outer shell.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GBrep.Edge.Parents">
      <summary>
            Parent faces. Can be an array of one or two items. To be used in conjunction with <see cref="F:devDept.Geometry.Entities.GBrep.Edge.ShellIndex" />.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Edge.#ctor(devDept.Geometry.Entities.IGCurve,System.Int32,System.Int32)">
      <summary>
            Curve and end point indices constructor.
            </summary>
      <param name="curve">The actual curve</param>
      <param name="startPointIndex">The start point index</param>
      <param name="endPointIndex">The end point index</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Edge.Clone">
      <summary>
            Creates a deep copy of this Edge.
            </summary>
      <returns>The new edge object.</returns>
    </member>
    <member name="T:devDept.Geometry.Entities.GBrep.Face">
      <summary>
            Brep face definition.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GBrep.Face.Loops">
      <summary>
            Trim loop array.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GBrep.Face.Surface">
      <summary>
            Analytic representation of this face.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GBrep.Face.Parametric">
      <summary>
            Parametric representation of this face.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GBrep.Face.Sense">
      <summary>
            Face sense.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GBrep.Face.ARGB">
      <summary>
            Gets or sets the Color ARGB of the face.
            </summary>
      <remarks>Use it to specify a different color from the Brep color or material.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Face.#ctor(devDept.Geometry.AnalyticSurf,devDept.Geometry.Entities.GBrep.Loop[],System.Boolean,System.Nullable{System.Int32})">
      <summary>
            Faces and loops constructor.
            </summary>
      <param name="surface">The analytic surface</param>
      <param name="loops">The trim loop array</param>
      <param name="sense">The face sense</param>
      <param name="argb">The face Color (overrides the entity color and material)</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Face.#ctor(devDept.Geometry.AnalyticSurf,devDept.Geometry.Entities.GBrep.Loop,System.Boolean,System.Nullable{System.Int32})">
      <summary>
            Faces and loop constructor.
            </summary>
      <param name="surface">The analytic surface</param>
      <param name="loop">The trim loop</param>
      <param name="sense">The face sense</param>
      <param name="argb">The face Color (overrides the entity color and material)</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Face.Clone">
      <summary>
            Creates a deep copy of this Face.
            </summary>
      <returns>The new face object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Face.GetError(devDept.Geometry.Point3D[],devDept.Geometry.Entities.GBrep.Edge[])">
      <summary>
            Gets the maximum gap between face loops' edges.
            </summary>
      <param name="vertices">The object vertices</param>
      <param name="edges">The object edges</param>
      <returns>The maximum gap value.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Face.GetOrientedTrimLoops(System.Collections.Generic.IList{devDept.Geometry.Entities.GBrep.Edge})">
      <summary>
            Gets the list of geometric (3D) trim loops of this face.
            </summary>
      <param name="edges">The <see cref="P:devDept.Geometry.Entities.GBrep.Edges" /> array.</param>
      <returns>An array of <see cref="T:devDept.Geometry.Entities.IGCurve" /> representing the geometric trim loops.</returns>
      <remarks>If curve tessellation is present, it's preserved.</remarks>
    </member>
    <member name="P:devDept.Geometry.Entities.GBrep.Face.TextureScaleU">
      <summary>
            Gets or sets the texture scale U.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GBrep.Face.TextureScaleV">
      <summary>
            Gets or sets the texture scale V.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GBrep.Face.TextureOffsetU">
      <summary>
            Gets or sets the texture offset U.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GBrep.Face.TextureOffsetV">
      <summary>
            Gets or sets the texture offset V.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Face.ConvertToSurface(devDept.Geometry.Entities.GEntity)">
      <summary>
            Convert this face in one or more parametric surfaces.
            </summary>
      <param name="parent">The Brep object (when available) to copy attributes like color, layer, etc.</param>
      <returns>The resulting array of surface objects.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Face.Flip">
      <summary>
            Flips the face normal.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Face.GetPlane(System.Boolean)">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="T:devDept.Geometry.Entities.GBrep.Loop">
      <summary>
            Brep face loop definition.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GBrep.Loop.Sense">
      <summary>
            The loop orientation. True means same sense.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GBrep.Loop.Segments">
      <summary>
            The array of oriented edges that compose the loop.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Loop.#ctor(devDept.Geometry.Entities.GBrep.OrientedEdge[])">
      <summary>
            Segments only constructor.
            </summary>
      <param name="segments">The array of oriented edges that compose the loop</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Loop.#ctor(devDept.Geometry.Entities.GBrep.OrientedEdge[],System.Boolean)">
      <summary>
            Segments and sense constructor.
            </summary>
      <param name="segments">The array of oriented edges that compose the loop.</param>
      <param name="sense">The loop sense</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Loop.Clone">
      <summary>
            Creates a deep copy of this Loop.
            </summary>
      <returns>The new loop object.</returns>
    </member>
    <member name="T:devDept.Geometry.Entities.GBrep.OrientedEdge">
      <summary>
            Brep oriented edge definition.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GBrep.OrientedEdge.Sense">
      <summary>
            Orientation flag.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GBrep.OrientedEdge.CurveIndex">
      <summary>
            Edge curve index in array <see cref="P:devDept.Geometry.Entities.GBrep.Edges" />.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.OrientedEdge.#ctor(System.Int32,System.Boolean)">
      <summary>
            Edge curve index and orientation flag constructor.
            </summary>
      <param name="curveIndex">The edge curve index</param>
      <param name="sense">The edge curve orientation</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.OrientedEdge.GetOrientedCurve(devDept.Geometry.Entities.GBrep.Edge[])">
      <summary>
            Gets a copy of the edge curve properly oriented.
            </summary>
      <param name="edges">The edge array</param>
      <returns>A copy of the curve properly oriented</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.OrientedEdge.GetStartVertex(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{devDept.Geometry.Entities.GBrep.Edge})">
      <summary>
            Gets edge curve start vertex taking in account the <see cref="F:devDept.Geometry.Entities.GBrep.OrientedEdge.Sense" /> flag.
            </summary>
      <param name="vertices">The vertex array</param>
      <param name="edges">The edge array</param>
      <returns>A 3D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.OrientedEdge.GetStartPoint(System.Collections.Generic.IList{devDept.Geometry.Entities.GBrep.Edge})">
      <summary>
            Gets edge curve start point taking in account the <see cref="F:devDept.Geometry.Entities.GBrep.OrientedEdge.Sense" /> flag.
            </summary>
      <param name="edges">The edge array</param>
      <returns>A 3D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.OrientedEdge.GetEndVertex(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{devDept.Geometry.Entities.GBrep.Edge})">
      <summary>
            Gets edge curve end vertex taking in account the <see cref="F:devDept.Geometry.Entities.GBrep.OrientedEdge.Sense" /> flag.
            </summary>
      <param name="vertices">The vertex array</param>
      <param name="edges">The edge array</param>
      <returns>A 3D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.OrientedEdge.GetEndPoint(System.Collections.Generic.IList{devDept.Geometry.Entities.GBrep.Edge})">
      <summary>
            Gets edge curve end point taking in account the <see cref="F:devDept.Geometry.Entities.GBrep.OrientedEdge.Sense" /> flag.
            </summary>
      <param name="edges">The edge array</param>
      <returns>A 3D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Section(devDept.Geometry.Plane,System.Double)">
      <summary>
            Intersect the GBrep with the plane.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="pln"> the plane to intersect</param>
      <param name="tol">the tolerance</param>
      <returns>the list of the resulting intersection curves</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Intersection(devDept.Geometry.Entities.GSurface)">
      <summary>
            Intersect the GBrep with a generic GSurface.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="G"> the GSurface to intersect</param>
      <returns>the list of the resulting intersection curves</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.IntersectionLoops(devDept.Geometry.Entities.GBrep,devDept.Geometry.Entities.GBrep,devDept.Geometry.Entities.IGCurve[]@)">
      <summary>
            Computes the intersection loops between two GBrep objects.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="solidA"> The first GSolid to intersect</param>
      <param name="solidB"> The second GSolid to intersect</param>
      <param name="intCurves">The resulting intersection curves as a list of GCompositeIgCurve</param>
      <returns> Result of the intersection.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GBrep.Intersect(devDept.Geometry.Entities.GBrep,devDept.Geometry.Entities.GBrep,devDept.Geometry.Point3D[]@)">
      <summary>
            Checks if two brep intersect each other.
            </summary>
      <seealso cref="M:devDept.Geometry.Entities.GBrep.FixTopology"> FixTopology method</seealso>
      <param name="solidA"> The first Solid to intersect</param>
      <param name="solidB"> The second Solid to intersect</param>
      <param name="intersectionPoints">The resulting first intersection points found, when available</param>
      <returns> True if they intersect.</returns>
    </member>
    <!-- Badly formed XML comment ignored for member "M:devDept.Geometry.Entities.GBrep.PairEdges(devDept.Geometry.Entities.GBrep.Face,devDept.Geometry.Entities.GBrep.Face,System.Double,System.Collections.Generic.Dictionary{System.Int32,System.Int32}@,System.Boolean)" -->
    <member name="T:devDept.Geometry.Entities.GPlanarSurface">
      <summary>
            Planar gSurface definition. Adds the <see cref="P:devDept.Geometry.Entities.GPlanarSurface.Plane" /> property to standard gSurface.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GPlanarSurface.Plane">
      <summary>
            Gets the planar gSurface plane.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GPlanarSurface.#ctor(System.Int32,System.Double[],System.Int32,System.Double[],devDept.Geometry.Point4D[0:,0:],devDept.Geometry.Plane)">
      <summary>
            Deserialization constructor.
            </summary>
      <param name="uDegree">Degree in the U parametric direction</param>
      <param name="uKnotVector">Knot vector in the U parametric direction</param>
      <param name="vDegree">Degree in the V parametric direction</param>
      <param name="vKnotVector">Knot vector in the V parametric direction</param>
      <param name="ctrlPoints">Control points grid</param>
      <param name="plane">GSurface plane</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GPlanarSurface.Clone">
      <summary>
            Creates a deep copy of this revolution gSurface.
            </summary>
      <returns>The new revolution gSurface object.</returns>
    </member>
    <member name="T:devDept.Geometry.Entities.GRevolvedSurface">
      <summary>
            GSurface of revolution definition, created by rotating the generatrix about the axis of rotation.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GRevolvedSurface.Generatrix">
      <summary>
            Gets the generatrix of this gSurface of revolution.
            </summary>
      <seealso cref="P:devDept.Geometry.Entities.GRevolvedSurface.Axis" />
      <seealso cref="P:devDept.Geometry.Entities.GRevolvedSurface.Center" />
    </member>
    <member name="P:devDept.Geometry.Entities.GRevolvedSurface.Center">
      <summary>
            Gets revolution center point.
            </summary>
      <seealso cref="P:devDept.Geometry.Entities.GRevolvedSurface.Axis" />
      <seealso cref="P:devDept.Geometry.Entities.GRevolvedSurface.Generatrix" />
    </member>
    <member name="P:devDept.Geometry.Entities.GRevolvedSurface.Axis">
      <summary>
            Gets the revolution axis.
            </summary>
      <seealso cref="P:devDept.Geometry.Entities.GRevolvedSurface.Center" />
      <seealso cref="P:devDept.Geometry.Entities.GRevolvedSurface.Generatrix" />
    </member>
    <member name="P:devDept.Geometry.Entities.GRevolvedSurface.Angle">
      <summary>
            Gets the revolution angle in radians.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GRevolvedSurface.SeamPlane">
      <summary>
            Gets the seam plane.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GRevolvedSurface.Plane">
      <summary>
            Gets the base plane.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GRevolvedSurface.#ctor(System.Int32,System.Double[],System.Int32,System.Double[],devDept.Geometry.Point4D[0:,0:],devDept.Geometry.Entities.IGCurve,devDept.Geometry.Plane)">
      <summary>
            Deserialization constructor.
            </summary>
      <param name="uDegree">Degree in the U parametric direction</param>
      <param name="uKnotVector">Knot vector in the U parametric direction</param>
      <param name="vDegree">Degree in the V parametric direction</param>
      <param name="vKnotVector">Knot vector in the V parametric direction</param>
      <param name="ctrlPoints">Control points grid</param>
      <param name="generatrix">Generatrix igCurve</param>
      <param name="seamPlane">Seam plane</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GRevolvedSurface.Clone">
      <summary>
            Creates a deep copy of this revolution gSurface.
            </summary>
      <returns>The new revolution gSurface object.</returns>
    </member>
    <member name="T:devDept.Geometry.Entities.GCylindricalSurface">
      <summary>
            Cylindrical gSurface definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GCylindricalSurface.Radius">
      <summary>
            Gets the cone radius.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GCylindricalSurface.#ctor(System.Int32,System.Double[],System.Int32,System.Double[],devDept.Geometry.Point4D[0:,0:],devDept.Geometry.Entities.IGCurve,System.Double,devDept.Geometry.Plane)">
      <summary>
            Deserialization constructor.
            </summary>
      <param name="uDegree">Degree in the U parametric direction</param>
      <param name="uKnotVector">Knot vector in the U parametric direction</param>
      <param name="vDegree">Degree in the V parametric direction</param>
      <param name="vKnotVector">Knot vector in the V parametric direction</param>
      <param name="ctrlPoints">Control points grid</param>
      <param name="generatrix">Generatrix igCurve</param>
      <param name="radius">Cylinder radius</param>
      <param name="seamPlane">Revolved gSurface seam plane</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GCylindricalSurface.Clone">
      <summary>
            Creates a deep copy of this cylindrical gSurface.
            </summary>
      <returns>The new cylindrical gSurface object.</returns>
    </member>
    <member name="T:devDept.Geometry.Entities.GSphericalSurface">
      <summary>
            Spherical gSurface definition.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSphericalSurface.#ctor(System.Int32,System.Double[],System.Int32,System.Double[],devDept.Geometry.Point4D[0:,0:],devDept.Geometry.Entities.IGCurve,System.Double,devDept.Geometry.Plane)">
      <summary>
            Deserialization constructor.
            </summary>
      <param name="uDegree">Degree in the U parametric direction</param>
      <param name="uKnotVector">Knot vector in the U parametric direction</param>
      <param name="vDegree">Degree in the V parametric direction</param>
      <param name="vKnotVector">Knot vector in the V parametric direction</param>
      <param name="ctrlPoints">Control points grid</param>
      <param name="generatrix">Revolved gSurface generatrix igCurve</param>
      <param name="radius">Sphere radius</param>
      <param name="seamPlane">Revolved gSurface seam plane</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSphericalSurface.Clone">
      <summary>
            Creates a deep copy of this spherical gSurface.
            </summary>
      <returns>The new spherical gSurface object.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GSphericalSurface.Radius">
      <summary>
            Gets sphere radius
            </summary>
    </member>
    <member name="T:devDept.Geometry.Entities.GConicalSurface">
      <summary>
            Conical gSurface definition.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GConicalSurface.#ctor(System.Int32,System.Double[],System.Int32,System.Double[],devDept.Geometry.Point4D[0:,0:],devDept.Geometry.Entities.IGCurve,System.Double,devDept.Geometry.Plane,System.Double,devDept.Geometry.Point3D)">
      <summary>
            Deserialization constructor.
            </summary>
      <param name="uDegree">Degree in the U parametric direction</param>
      <param name="uKnotVector">Knot vector in the U parametric direction</param>
      <param name="vDegree">Degree in the V parametric direction</param>
      <param name="vKnotVector">Knot vector in the V parametric direction</param>
      <param name="ctrlPoints">Control points grid</param>
      <param name="generatrix">Revolved gSurface generatrix igCurve</param>
      <param name="radius">Cone radius</param>
      <param name="seamPlane">Revolved gSurface seam plane</param>
      <param name="halfAngle">Cone half angle</param>
      <param name="coneTip">Cone tip</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GConicalSurface.Clone">
      <summary>
            Creates a deep copy of this conical gSurface.
            </summary>
      <returns>The new conical gSurface object.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GConicalSurface.HalfAngle">
      <summary>
            Gets cone's angle.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GConicalSurface.Tip">
      <summary>
            Gets cone's tip.
            </summary>
    </member>
    <member name="T:devDept.Geometry.Entities.torusType">
      <summary>
            Torus type.
            </summary>
    </member>
    <member name="T:devDept.Geometry.Entities.GToroidalSurface">
      <summary>
            Toroidal gSurface definition.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GToroidalSurface.#ctor(System.Int32,System.Double[],System.Int32,System.Double[],devDept.Geometry.Point4D[0:,0:],devDept.Geometry.Entities.IGCurve,System.Double,System.Double,devDept.Geometry.Plane)">
      <summary>
            Deserialization constructor.
            </summary>
      <param name="uDegree">Degree in the U parametric direction</param>
      <param name="uKnotVector">Knot vector in the U parametric direction</param>
      <param name="vDegree">Degree in the V parametric direction</param>
      <param name="vKnotVector">Knot vector in the V parametric direction</param>
      <param name="ctrlPoints">Control points grid</param>
      <param name="generatrix">Revolved gSurface generatrix igCurve</param>
      <param name="major">Major radius</param>
      <param name="minor">Minor radius</param>
      <param name="seamPlane">Revolved gSurface seam plane</param>
    </member>
    <member name="P:devDept.Geometry.Entities.GToroidalSurface.Type">
      <summary>
            Gets the torus type.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GToroidalSurface.Clone">
      <summary>
            Creates a deep copy of this toroidal gSurface.
            </summary>
      <returns>The new toroidal gSurface object.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GToroidalSurface.MajorRadius">
      <summary>
            Gets torus' major radius.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GToroidalSurface.MinorRadius">
      <summary>
            Gets torus' minor radius.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GToroidalSurface.GetTorusType(System.Double,System.Double)">
      <summary>
            For internal use only.
            </summary>
            TODO Geo TRS: rimettere internal
        </member>
    <member name="T:devDept.Geometry.Entities.GSurface">
      <summary>
            Nurbs gSurface entity.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.MergeV(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface})">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.MergeU(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface})">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.SkinU(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Int32)">
      <summary>
            Creates a gSurface from skinning. The skinning is performed in the U direction.
            </summary>
      <param name="curveList">A list of NURBS curves</param>
      <param name="degU">The degree in the U direction</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.SkinU(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Int32,System.Boolean)">
      <summary>
            Creates a gSurface from skinning. The skinning is performed in the U direction.
            </summary>
      <param name="curveList">A list of NURBS curves</param>
      <param name="degU">The degree in the U direction</param>
      <param name="splitAtCorners">If True, it splits the curves at corner points. It is useful when the sections are Composite Curves with similar shape, and you want to line up the corners (and curve segments) in the resulting gSurface.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.SkinV(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Int32)">
      <summary>
            Creates a gSurface from skinning. The skinning is performed in the V direction.
            </summary>
      <param name="curveList">A list of curves</param>
      <param name="degV">The degree in the V direction</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.SkinV(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Int32,System.Boolean)">
      <summary>
            Creates a gSurface from skinning. The skinning is performed in the V direction.
            </summary>
      <param name="curveList">A list of curves</param>
      <param name="degV">The degree in the V direction</param>
      <param name="splitAtCorners">If True, it splits the curves at corner points. It is useful when the sections are Composite Curves with similar shape, and you want to line up the corners (and curve segments) in the resulting gSurface.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Gordon(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve})">
      <summary>
            Creates a Gordon gSurface.
            </summary>
      <param name="lU">The list of non rational curves in the U direction</param>
      <param name="lV">The list of non rational curves in the V direction</param>
      <returns>The resulting gSurface if the operation succeeds, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Gordon(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},devDept.Geometry.Point3D[0:,0:])">
      <summary>
            Creates a Gordon gSurface.
            </summary>
      <param name="lU">The list of non rational curves in the U direction</param>
      <param name="lV">The list of non rational curves in the V direction</param>
      <param name="intersections">The matrix of curve intersection points</param>
      <returns>The resulting gSurface if the operation succeeds, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Ruled(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.IGCurve)">
      <summary>
            Creates a gSurface connecting linearly two curves.
            </summary>
      <param name="first">First curve</param>
      <param name="second">Second curve</param>
      <returns>The resulting gSurface if the operation succeeds, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Loft(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve})">
      <summary>
            Creates a gSurface from skinning. 
            </summary>
      <param name="curveList">The skinning curves</param>
      <returns>The resulting gSurface array if the operation succeeds, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Loft(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Int32)">
      <summary>
            Creates a gSurface from skinning. 
            </summary>
      <param name="curveList">The skinning curves</param>
      <param name="degree">The desired gSurface degree</param>
      <returns>The resulting gSurface array if the operation succeeds, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Loft(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Int32,System.Boolean,System.Boolean)">
      <summary>
            Creates a gSurface from skinning. 
            </summary>
      <param name="curveList">The skinning curves</param>
      <param name="degree">The desired gSurface degree</param>
      <param name="splitAtCorners">If True, it splits the curves at corner points. It is useful when the curves have similar shapes, and you want to line up the corners in the resulting gSurface.</param>
      <param name="speedChange">Works only when splitAtCorners is true. If true, when the tangents have the same direction but different lengths, the curve will be split. 
            If false, it won't be split.</param>
      <returns>The resulting gSurface array if the operation succeeds, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.ExtrudeWithTwist(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Double,System.Int32)">
      <summary>
            Extrudes and twists a planar curve. 
            </summary>
      <param name="curve">The curve to extrude</param>
      <param name="direction">Extrusion direction, normal to the plane of the curve</param>
      <param name="center">GPoint of application for the direction, on the plane of the curve</param>
      <param name="angle">Twist angle in radians</param>
      <param name="numberOfSections">Number of internal sections to be interpolated, it corresponds to the number of distinct internal knots in the gSurface's V direction.</param>
      <returns>The resulting gSurface array if the operation succeeds, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.ExtrudeWithTwist(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,System.Double,System.Double)">
      <summary>
            Extrudes and twists a planar curve. 
            </summary>
      <param name="curve">The curve to extrude</param>
      <param name="direction">Extrusion direction, normal to the plane of the curve</param>
      <param name="center">GPoint of application for the direction, on the plane of the curve</param>
      <param name="angle">Twist angle in radians</param>
      <param name="tol">Tolerance</param>
      <returns>The resulting gSurface array if the operation succeeds, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.CreatePlanar(devDept.Geometry.Plane,devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>Creates a planar rectangular gSurface parallel to the specified plane.</summary>
      <param name="pln">The plane (determines the gSurface orientation)</param>
      <param name="bottomLeft">First corner (also determines gSurface distance from the world origin)</param>
      <param name="topRight">Second corner (determines gSurface width and height)</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Bounded(devDept.Geometry.Plane,devDept.Geometry.Entities.IGCurve,System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Boolean)">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.CreateEllipsoid(System.Double,System.Double,System.Double)">
      <summary>
            Creates a NURBS ellipsoid centered in the origin.
            </summary>
      <param name="semiaxisX">Length of the semiaxis along the X axis</param>
      <param name="semiaxisY">Length of the semiaxis along the Y axis</param>
      <param name="semiaxisZ">Length of the semiaxis along the Z axis</param>
      <returns>The NURBS ellipsoidal gSurface.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.TryGetPlanar(devDept.Geometry.Entities.GPlanarSurface@)">
      <summary>
            Converts this generic gSurface to <see cref="T:devDept.Geometry.Entities.GPlanarSurface" /> (when possible).
            </summary>
      <param name="ps">The resulting planar gSurface (when possible)</param>
      <returns>True if the operation succeeds, false otherwise. If the gSurface is already a <see cref="T:devDept.Geometry.Entities.GPlanarSurface" />, it returns false.</returns>
      <remarks>It does not work for for planar cones with revolution angle equal to 2PI.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.TryGetRevolved(devDept.Geometry.Entities.GRevolvedSurface@)">
      <summary>
            Converts this generic gSurface to <see cref="T:devDept.Geometry.Entities.GRevolvedSurface" /> (when possible).
            </summary>
      <param name="rs">The resulting revolved gSurface (when possible)</param>
      <returns>True if the operation succeeds, false otherwise. If the gSurface is already a <see cref="T:devDept.Geometry.Entities.GRevolvedSurface" />, it returns false.</returns>
      <remarks>It only converts gSurfaces with angle of revolution of PI and 2PI.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.TryGetTabulated(devDept.Geometry.Entities.GTabulatedSurface@)">
      <summary>
            Converts this generic gSurface to <see cref="T:devDept.Geometry.Entities.GTabulatedSurface" /> (when possible).
            </summary>
      <param name="ts">The resulting tabulated gSurface (when possible)</param>
      <returns>True if the operation succeeds, false otherwise. If the gSurface is already a <see cref="T:devDept.Geometry.Entities.GTabulatedSurface" />, it returns false.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.CheckWeight9">
      <summary>
            Check if the weight of odd control points is Sqrt(2)/2.
            </summary>
      <returns>True if the W component of all odd control points is Sqrt(2)/2, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Promote">
      <summary>
            Converts this generic gSurface to <see cref="T:devDept.Geometry.Entities.GPlanarSurface" />, <see cref="T:devDept.Geometry.Entities.GTabulatedSurface" /> or <see cref="T:devDept.Geometry.Entities.GRevolvedSurface" /> (when possible).
            </summary>
      <returns>The new gSurface when possible, null/Nothing otherwise.</returns>
      <remarks>When the gSurface is already a <see cref="T:devDept.Geometry.Entities.GPlanarSurface" />, <see cref="T:devDept.Geometry.Entities.GTabulatedSurface" /> or <see cref="T:devDept.Geometry.Entities.GRevolvedSurface" />, the method returns null/Nothing.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Promote(devDept.Geometry.Transformation@)">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.ConvexHull">
      <summary>
            The convex hull of the gSurface.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.#ctor(System.Int32,System.Double[],System.Int32,System.Double[],devDept.Geometry.Point4D[0:,0:])">
      <summary>
            Standard constructor.
            </summary>
      <param name="uDegree">Degree in the U parametric direction</param>
      <param name="uKnotVector">Knot vector in the U parametric direction</param>
      <param name="vDegree">Degree in the V parametric direction</param>
      <param name="vKnotVector">Knot vector in the V parametric direction</param>
      <param name="ctrlPoints">Control points grid</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.#ctor(System.Int32,System.Double,System.Double,devDept.Geometry.Vector3D[0:,0:])">
      <summary>
            Power basis to Bezier constructor.
            </summary>
      <param name="degree">The curve degree</param>
      <param name="uSpan">The segment U span</param>
      <param name="vSpan">The segment V span</param>
      <param name="b">The power basis coefficients as an array of 3D vectors</param>
            TODO Geo TRS: rimettere internal
        </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Clone">
      <summary>
            Creates a deep copy of this gSurface.
            </summary>
      <returns>The new gSurface object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Resize(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Resizes a gSurface.
            </summary>
      <remarks>The old values are lost and new ones have to be created.</remarks>
      <param name="n">The new number of control points in the U direction</param>
      <param name="m">The new number of control points in the V direction</param>
      <param name="degU">The degree of the gSurface in the U direction</param>
      <param name="degV">The degree of the gSurface in the V direction</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.ResizeKeep(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Resizes a gSurface, keeping original values.
            </summary>
      <param name="n">The new number of control points in the U direction</param>
      <param name="m">The new number of control points in the V direction</param>
      <param name="degU">The degree of the gSurface in the U direction</param>
      <param name="degV">The degree of the gSurface in the V direction</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.IsocurveU(System.Double)">
      <summary>
            Generates an iso curve in the U parametric direction.
            </summary>
      <param name="v">The V parametric value</param>
      <returns>The iso-parametric curve</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.IsocurveV(System.Double)">
      <summary>
            Generates an iso curve in the V parametric direction.
            </summary>
      <param name="u">The U parametric value</param>
      <returns>The iso-parametric curve</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.SplitAtU(System.Double,devDept.Geometry.Entities.GSurface@,devDept.Geometry.Entities.GSurface@)">
      <summary>
            Splits the gSurface along U.
            </summary>
      <param name="u">The U parametric value</param>
      <param name="sl">The lower gSurface</param>
      <param name="su">The upper gSurface</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.SplitAtV(System.Double,devDept.Geometry.Entities.GSurface@,devDept.Geometry.Entities.GSurface@)">
      <summary>
            Splits the gSurface along V.
            </summary>
      <param name="v">The V parametric value</param>
      <param name="sl">The lower gSurface</param>
      <param name="su">The upper gSurface</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.SplitByU(devDept.Geometry.Point3D,devDept.Geometry.Entities.GSurface@,devDept.Geometry.Entities.GSurface@)">
      <summary>
            Splits the gSurface along U.
            </summary>
      <param name="pt">The point used to get the U parametric value</param>
      <param name="sl">The lower gSurface</param>
      <param name="su">The upper gSurface</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.SplitByV(devDept.Geometry.Point3D,devDept.Geometry.Entities.GSurface@,devDept.Geometry.Entities.GSurface@)">
      <summary>
            Splits the gSurface along V.
            </summary>
      <param name="pt">The point used to get the V parametric value</param>
      <param name="sl">The lower gSurface</param>
      <param name="su">The upper gSurface</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Shrink(System.Double)">
      <summary>
            Shrinks the underlying untrimmed gSurface in order to make it as small as possible.
            </summary>
      <param name="margin">A margin expressed as the percentage of the gSurface domain width/height</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Untrim">
      <summary>
            Clears all trimming loops.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.ReverseU">
      <summary>
            Reverses the gSurface U direction.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.ReverseV">
      <summary>
            Reverses the gSurface V direction.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.SwapUV">
      <summary>
            Swaps the U and V directions of the gSurface.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.IsPlanar(System.Double,devDept.Geometry.Plane@)">
      <summary>
            Checks if the gSurface is planar.
            </summary>
      <param name="tol">The tolerance</param>
      <param name="plane">The gSurface plane</param>
      <returns>True if the gSurface is planar within tolerance, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.GetGeneric">
      <summary>
            Returns the generic representation of this gSurface, it can be useful in data translation. 
            </summary>
      <returns>The new gSurface</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.AdjustTrimLoopsGenericAndRevolved(devDept.Geometry.Entities.GSurface,devDept.Geometry.Entities.GSurface)">
      <summary>
            Transforms the trimLoops when converting a gSurface from Nurbs to angular parametrization and back.
            </summary>
      <param name="source">The original gSurface (Nurbs or Revolved)</param>
      <param name="dest">The destination gSurface (Revolved or Nurbs), whose trimLoops will be transformed.</param>
      <remarks>This method is useful when reading in Eyeshot 11 or higher a GRevolvedSurface stored in your proprietary format before Eyeshot 11.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.GetAnalytic">
      <summary>
            For internal use only.
            </summary>
            TODO Geo TRS: rimettere internal
        </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Blend(devDept.Geometry.Entities.GSurface,devDept.Geometry.Entities.GSurface,System.Int32,System.Int32,System.Double,System.Boolean,System.Boolean)">
      <summary>
            Creates a blend gSurface between two gSurfaces.
            </summary>
      <param name="F">First gSurface</param>
      <param name="G">Second gSurface</param>
      <param name="edgeIndexF">Index of the edge on F</param>
      <param name="edgeIndexG">Index of the edge on G</param>
      <param name="tol">Tolerance</param>
      <param name="flipEdgeF">If true, the edge of the blending gSurface has opposite direction of the edge of F</param>
      <param name="flipEdgeG">If true, the edge of the blending gSurface has opposite direction of the edge of G</param>
      <returns>The blend gSurface.</returns>
      <remarks>It only works for edges of the outer contour of the gSurfaces.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.GetPerimeter">
      <summary>
            Computes the sum of the lengths of all the gSurface's edges.
            </summary>
      <returns>The perimeter amount.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.PointAt(devDept.Geometry.Point2D)">
      <summary>
            Computes the gSurface point.
            </summary>
      <param name="pt">The point in parametric domain</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.PointAt(System.Double,System.Double)">
      <summary>
            Computes the gSurface point at parametric values [u, v].
            </summary>
      <param name="u">Parametric value along U direction</param>
      <param name="v">Parametric value along V direction</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Evaluate(devDept.Geometry.Point2D)">
      <summary>
            Computes the gSurface point.
            </summary>
      <param name="pt">The point in parametric domain</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Evaluate(System.Double,System.Double)">
      <summary>
            Computes the gSurface point at parametric values [u, v].
            </summary>
      <param name="u">Parametric value along U direction</param>
      <param name="v">Parametric value along V direction</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Evaluate(devDept.Geometry.Point2D,System.Int32)">
      <summary>
            Computes the gSurface derivatives.
            </summary>
      <param name="pt">The point in parametric domain</param>
      <param name="d">The degree of the derivatives</param>
      <return>The derivatives SKL[k, l].</return>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Evaluate(System.Double,System.Double,System.Int32)">
      <summary>
            Computes the gSurface derivatives at parametric values [u,v].
            </summary>
      <param name="u">Parametric value along U direction</param>
      <param name="v">Parametric value along V direction</param>
      <param name="d">The degree of the derivatives</param>
      <return>The derivatives SKL[k, l].</return>
      <example>
                The following code fragment demonstrates how to compute the first 2 derivatives of
                the gSurface at the parametric value [0.25, 0.5].
            <code lang="CS">
            Vector3D[,] SKL = mySurf.Evaluate(0.25, 2);
             
            Vector3D S   = SKL[0,0];
            Vector3D Su  = SKL[1,0];
            Vector3D Sv  = SKL[0,1];
            Vector3D Suu = SKL[2,0];
            Vector3D Suv = SKL[1,1];
            Vector3D Svv = SKL[0,2];
            </code><code lang="VB">
            Dim SKL(,) As Vector3D = MySurf.Evaluate(0.25, 0.5, 2)
             
            Dim S As Vector3D = SKL(0,0)
            Dim Su As Vector3D = SKL(1,0)
            Dim Sv As Vector3D = SKL(0,1)
            Dim Suu As Vector3D = SKL(2,0)
            Dim Suv As Vector3D = SKL(1,1)
            Dim Svv As Vector3D = SKL(0,2)
            </code></example>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Curvature(devDept.Geometry.Point2D,System.Double@,System.Double@)">
      <summary>
            Evaluates the gSurface Gaussian and Mean curvatures at the specified 2D point.
            </summary>
      <param name="pt">The point in parametric domain</param>
      <param name="gauss">Gaussian curvature = kappa1*kappa2</param>
      <param name="mean">Mean curvature = (kappa1+kappa2)/2</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Curvature(System.Double,System.Double,System.Double@,System.Double@)">
      <summary>
            Evaluates the gSurface Gaussian and Mean curvatures at the specified parametric point.
            </summary>
      <param name="u">Parametric value along U direction</param>
      <param name="v">Parametric value along V direction</param>
      <param name="gauss">Gaussian curvature = kappa1*kappa2</param>
      <param name="mean">Mean curvature = (kappa1+kappa2)/2</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Curvature(System.Double,System.Double,System.Double@,System.Double@,System.Double@,System.Double@)">
      <summary>
            Evaluates the gSurface curvatures at the specified parametric point.
            </summary>
      <param name="u">Parametric value along U direction</param>
      <param name="v">Parametric value along V direction</param>
      <param name="gauss">Gaussian curvature = kappa1*kappa2</param>
      <param name="mean">Mean curvature = (kappa1+kappa2)/2</param>
      <param name="kappa1">Largest principal curvature value</param>
      <param name="kappa2">Smallest principal curvature value</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Curvature(System.Double,System.Double,System.Double@,System.Double@,System.Double@,System.Double@,devDept.Geometry.Vector3D@,devDept.Geometry.Vector3D@)">
      <summary>
            Evaluates the gSurface curvatures at the specified parametric point.
            </summary>
      <param name="u">Parametric value along U direction</param>
      <param name="v">Parametric value along V direction</param>
      <param name="gauss">Gaussian curvature = kappa1*kappa2</param>
      <param name="mean">Mean curvature = (kappa1+kappa2)/2</param>
      <param name="kappa1">Largest principal curvature value</param>
      <param name="kappa2">Smallest principal curvature value</param>
      <param name="k1">Unit principal direction relative to kappa1</param>
      <param name="k2">Unit principal direction relative to kappa2</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Normal(devDept.Geometry.Point2D)">
      <summary>
            Evaluates the gSurface normal at the specified parametric point.
            </summary>
      <param name="pt">The point in parametric domain</param>
      <returns>The normal vector.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Normal(System.Double,System.Double)">
      <summary>
            Evaluates the gSurface normal at the specified parametric point.
            </summary>
      <param name="u">Parametric value along U direction</param>
      <param name="v">Parametric value along V direction</param>
      <returns>The normal vector.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Fillet(devDept.Geometry.Entities.GSurface,devDept.Geometry.Entities.GSurface,System.Double,System.Double,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Constant fillet between two gSurfaces.
            </summary>
      <param name="F">First gSurface</param>
      <param name="G">Second gSurface</param>
      <param name="radius">Fillet radius</param>
      <param name="tol">Tolerance</param>
      <param name="flipNormalF">First gSurface flip normal flag</param>
      <param name="flipNormalG">Second gSurface flip normal flag</param>
      <param name="trimF">When true the first gSurface is trimmed</param>
      <param name="trimG">When true the second gSurface is trimmed</param>
      <param name="flipTrimSideF">First gSurface flip trim flag</param>
      <param name="flipTrimSideG">Second gSurface flip trim flag</param>
      <param name="fillet">An array of resulting fillet gSurfaces</param>
      <returns>The resulting <see cref="T:devDept.Geometry.ssiFailureType" />.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Fillet(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Double,System.Double,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Constant fillet between two groups of gSurfaces.
            </summary>
      <param name="listF">First gSurface group</param>
      <param name="listG">Second gSurface group</param>
      <param name="radius">Fillet radius</param>
      <param name="tol">Tolerance</param>
      <param name="flipNormalF">First gSurface flip normal flag</param>
      <param name="flipNormalG">Second gSurface flip normal flag</param>
      <param name="trimF">When true the first gSurface is trimmed</param>
      <param name="trimG">When true the second gSurface is trimmed</param>
      <param name="flipTrimSideF">First gSurface flip trim flag</param>
      <param name="flipTrimSideG">Second gSurface flip trim flag</param>
      <param name="fillet">An array of fillet gSurfaces</param>
      <returns>The resulting <see cref="T:devDept.Geometry.ssiFailureType" />.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Fillet(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Double,System.Double,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,devDept.Geometry.Entities.GSurface[]@,devDept.Geometry.Entities.GSurface[]@,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Constant fillet between two groups of gSurfaces, with gSurfaces leftover by the trim operation.
            </summary>
      <param name="listF">First gSurface group</param>
      <param name="listG">Second gSurface group</param>
      <param name="radius">Fillet radius</param>
      <param name="tol">Tolerance</param>
      <param name="flipNormalF">First gSurface flip normal flag</param>
      <param name="flipNormalG">Second gSurface flip normal flag</param>
      <param name="trimF">When true the first gSurface is trimmed</param>
      <param name="trimG">When true the second gSurface is trimmed</param>
      <param name="flipTrimSideF">First gSurface flip trim flag</param>
      <param name="flipTrimSideG">Second gSurface flip trim flag</param>
      <param name="fillet">An array of fillet gSurfaces</param>
      <param name="leftOversF">Trim operation leftover list for listF</param>
      <param name="leftOversG">Trim operation leftover list for listG</param>
      <returns>The resulting <see cref="T:devDept.Geometry.ssiFailureType" />.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.VariableFillet(devDept.Geometry.Entities.GSurface,devDept.Geometry.Entities.GSurface,System.Double,System.Double,System.Boolean,System.Double,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Variable fillet between two individual gSurfaces.
            </summary>
      <param name="F">First gSurface</param>
      <param name="G">Second gSurface</param>
      <param name="startRadius">Starting fillet radius</param>
      <param name="endRadius">Ending fillet radius</param>
      <param name="linear">Linear/cubic transition flag</param>
      <param name="tol">Tolerance</param>
      <param name="flipNormalF">First gSurface flip normal flag</param>
      <param name="flipNormalG">Second gSurface flip normal flag</param>
      <param name="trimF">When true the first gSurface is trimmed</param>
      <param name="trimG">When true the second gSurface is trimmed</param>
      <param name="flipTrimSideF">First gSurface flip trim flag</param>
      <param name="flipTrimSideG">Second gSurface flip trim flag</param>
      <param name="fillet">An array of fillet gSurfaces</param>
      <returns>The resulting ssiFailureType.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.VariableFillet(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Double,System.Double,System.Boolean,System.Double,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Variable fillet between two groups of gSurfaces.
            </summary>
      <param name="listF">First gSurface group</param>
      <param name="listG">Second gSurface group</param>
      <param name="startRadius">Starting fillet radius</param>
      <param name="endRadius">Ending fillet radius</param>
      <param name="linear">Linear/cubic transition flag</param>
      <param name="tol">Tolerance</param>
      <param name="flipNormalF">First gSurface flip normal flag</param>
      <param name="flipNormalG">Second gSurface flip normal flag</param>
      <param name="trimF">When true the first gSurface is trimmed</param>
      <param name="trimG">When true the second gSurface is trimmed</param>
      <param name="flipTrimSideF">First gSurface flip trim flag</param>
      <param name="flipTrimSideG">Second gSurface flip trim flag</param>
      <param name="fillet">An array of fillet gSurfaces</param>
      <returns>The resulting ssiFailureType.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.VariableFillet(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Double,System.Double,System.Boolean,System.Double,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,devDept.Geometry.Entities.GSurface[]@,devDept.Geometry.Entities.GSurface[]@,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Variable fillet between two groups of gSurfaces, with gSurfaces leftover by the trim operation.
            </summary>
      <param name="listF">First gSurface group</param>
      <param name="listG">Second gSurface group</param>
      <param name="startRadius">Starting fillet radius</param>
      <param name="endRadius">Ending fillet radius</param>
      <param name="linear">Linear/cubic transition flag</param>
      <param name="tol">Tolerance</param>
      <param name="flipNormalF">First gSurface flip normal flag</param>
      <param name="flipNormalG">Second gSurface flip normal flag</param>
      <param name="trimF">When true the first gSurface is trimmed</param>
      <param name="trimG">When true the second gSurface is trimmed</param>
      <param name="flipTrimSideF">First gSurface flip trim flag</param>
      <param name="flipTrimSideG">Second gSurface flip trim flag</param>
      <param name="fillet">An array of fillet gSurfaces</param>
      <param name="leftOversF">Trim operation leftover list for listF</param>
      <param name="leftOversG">Trim operation leftover list for listG</param>
      <returns>The resulting ssiFailureType.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Chamfer(devDept.Geometry.Entities.GSurface,devDept.Geometry.Entities.GSurface,System.Double,System.Double,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Constant chamfer between two gSurfaces.
            </summary>
      <param name="F">First gSurface</param>
      <param name="G">Second gSurface</param>
      <param name="radius">Chamfer distance</param>
      <param name="tol">Tolerance</param>
      <param name="flipNormalF">First gSurface flip normal flag</param>
      <param name="flipNormalG">Second gSurface flip normal flag</param>
      <param name="trimF">When true the first gSurface is trimmed</param>
      <param name="trimG">When true the second gSurface is trimmed</param>
      <param name="flipTrimSideF">First gSurface flip trim flag</param>
      <param name="flipTrimSideG">Second gSurface flip trim flag</param>
      <param name="chamfer">An array of resulting chamfer gSurfaces</param>
      <returns>The resulting <see cref="T:devDept.Geometry.ssiFailureType" />.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Chamfer(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Double,System.Double,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Constant chamfer between two groups of gSurfaces.
            </summary>
      <param name="listF">First gSurface group</param>
      <param name="listG">Second gSurface group</param>
      <param name="radius">Chamfer distance</param>
      <param name="tol">Tolerance</param>
      <param name="flipNormalF">First gSurface flip normal flag</param>
      <param name="flipNormalG">Second gSurface flip normal flag</param>
      <param name="trimF">When true the first gSurface is trimmed</param>
      <param name="trimG">When true the second gSurface is trimmed</param>
      <param name="flipTrimSideF">First gSurface flip trim flag</param>
      <param name="flipTrimSideG">Second gSurface flip trim flag</param>
      <param name="chamfer">An array of chamfer gSurfaces</param>
      <returns>The resulting <see cref="T:devDept.Geometry.ssiFailureType" />.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Chamfer(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Double,System.Double,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,devDept.Geometry.Entities.GSurface[]@,devDept.Geometry.Entities.GSurface[]@,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Constant chamfer between two groups of gSurfaces, with gSurfaces leftover by the trim operation.
            </summary>
      <param name="listF">First gSurface group</param>
      <param name="listG">Second gSurface group</param>
      <param name="radius">Chamfer distance</param>
      <param name="tol">Tolerance</param>
      <param name="flipNormalF">First gSurface flip normal flag</param>
      <param name="flipNormalG">Second gSurface flip normal flag</param>
      <param name="trimF">When true the first gSurface is trimmed</param>
      <param name="trimG">When true the second gSurface is trimmed</param>
      <param name="flipTrimSideF">First gSurface flip trim flag</param>
      <param name="flipTrimSideG">Second gSurface flip trim flag</param>
      <param name="chamfer">An array of chamfer gSurfaces</param>
      <param name="leftOversF">Trim operation leftover list for listF</param>
      <param name="leftOversG">Trim operation leftover list for listG</param>
      <returns>The resulting <see cref="T:devDept.Geometry.ssiFailureType" />.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.VariableChamfer(devDept.Geometry.Entities.GSurface,devDept.Geometry.Entities.GSurface,System.Double,System.Double,System.Boolean,System.Double,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Variable chamfer between two gSurfaces.
            </summary>
      <param name="F">First gSurface</param>
      <param name="G">Second gSurface</param>
      <param name="startRadius">Starting chamfer distance</param>
      <param name="endRadius">Ending chamfer distance</param>
      <param name="linear">Linear/cubic transition flag</param>
      <param name="tol">Tolerance</param>
      <param name="flipNormalF">First gSurface flip normal flag</param>
      <param name="flipNormalG">Second gSurface flip normal flag</param>
      <param name="trimF">When true the first gSurface is trimmed</param>
      <param name="trimG">When true the second gSurface is trimmed</param>
      <param name="flipTrimSideF">First gSurface flip trim flag</param>
      <param name="flipTrimSideG">Second gSurface flip trim flag</param>
      <param name="chamfer">An array of chamfer gSurfaces</param>
      <returns>The resulting ssiFailureType.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.VariableChamfer(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Double,System.Double,System.Boolean,System.Double,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Variable chamfer between two groups of gSurfaces.
            </summary>
      <param name="listF">First gSurface group</param>
      <param name="listG">Second gSurface group</param>
      <param name="startRadius">Starting chamfer distance</param>
      <param name="endRadius">Ending chamfer distance</param>
      <param name="linear">Linear/cubic transition flag</param>
      <param name="tol">Tolerance</param>
      <param name="flipNormalF">First gSurface flip normal flag</param>
      <param name="flipNormalG">Second gSurface flip normal flag</param>
      <param name="trimF">When true the first gSurface is trimmed</param>
      <param name="trimG">When true the second gSurface is trimmed</param>
      <param name="flipTrimSideF">First gSurface flip trim flag</param>
      <param name="flipTrimSideG">Second gSurface flip trim flag</param>
      <param name="chamfer">An array of chamfer gSurfaces</param>
      <returns>The resulting ssiFailureType.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.VariableChamfer(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Double,System.Double,System.Boolean,System.Double,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,devDept.Geometry.Entities.GSurface[]@,devDept.Geometry.Entities.GSurface[]@,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Variable chamfer between two groups of gSurfaces, with gSurfaces leftover by the trim operation.
            </summary>
      <param name="listF">First gSurface group</param>
      <param name="listG">Second gSurface group</param>
      <param name="startRadius">Starting chamfer distance</param>
      <param name="endRadius">Ending chamfer distance</param>
      <param name="linear">Linear/cubic transition flag</param>
      <param name="tol">Tolerance</param>
      <param name="flipNormalF">First gSurface flip normal flag</param>
      <param name="flipNormalG">Second gSurface flip normal flag</param>
      <param name="trimF">When true the first gSurface is trimmed</param>
      <param name="trimG">When true the second gSurface is trimmed</param>
      <param name="flipTrimSideF">First gSurface flip trim flag</param>
      <param name="flipTrimSideG">Second gSurface flip trim flag</param>
      <param name="chamfer">An array of chamfer gSurfaces</param>
      <param name="leftOversF">Trim operation leftover list for listF</param>
      <param name="leftOversG">Trim operation leftover list for listG</param>
      <returns>The resulting ssiFailureType.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.GetIndividualSurfaces(devDept.Geometry.Entities.GSurface)">
      <summary>
            Subdivides a gSurface at knots of multiplicity equal to the order. 
            Tabulated Surfaces are divided only along the U direction, Revolved Surfaces only in the V direction. 
            </summary>
      <param name="current">Parent gSurface</param>
      <returns>List of kids gSurfaces</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.InsertKnotU(System.Double,System.Int32)">
      <summary>
            Inserts a knot a number of times in the U parametric direction.
            </summary>
      <param name="u">The knot to Insert</param>
      <param name="r">The number of times to Insert</param>
      <returns>The number of knots inserted, zero otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.InsertKnotU(devDept.Geometry.Point3D,System.Int32)">
      <summary>
            Inserts a knot a number of times in the U parametric direction. It is added at the U parameter corresponding to the projection of the given point on the gSurface. 
            The operation does not affect the shape of the gSurface.
            </summary>
      <param name="ctrlPoint">The point to be projected on the gSurface</param>
      <param name="r">The number of times to insert</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.InsertKnotV(System.Double,System.Int32)">
      <summary>
            Inserts a knot a number of times in the V parametric direction.
            </summary>
      <param name="v">The knot to Insert</param>
      <param name="r">The number of times to Insert</param>
      <returns>The number of knots inserted, zero otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.InsertKnotV(devDept.Geometry.Point3D,System.Int32)">
      <summary>
            Inserts a knot a number of times in the V parametric direction. It is added at the V parameter corresponding to the projection of the given point on the gSurface. 
            The operation does not affect the shape of the gSurface.
            </summary>
      <param name="ctrlPoint">The point to be projected on the gSurface</param>
      <param name="r">The number of times to insert</param>
      <returns>True if the operation is successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.RefineKnotVectorU(System.Double[])">
      <summary>
            Refines the gSurface knot vector U.
            </summary>
      <param name="X">The new knots to Insert in the knot vector</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.RefineKnotVectorV(System.Double[])">
      <summary>
            Refines the gSurface knot vector V.
            </summary>
      <param name="X">The new knots to Insert in the knot vector</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.DegreeElevateU(System.Int32)">
      <summary>
            Degree elevates the gSurface in the U parametric direction.
            </summary>
      <param name="t">Degree elevation amount</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.DegreeElevateV(System.Int32)">
      <summary>
            Degree elevates the gSurface in the V parametric direction.
            </summary>
      <param name="t">Degree elevation amount</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.DecomposeU">
      <summary>
            Decomposes the gSurface into BÃ©zier patches in the U parametric direction.
            </summary>
      <returns>A list of gSurfaces.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.DecomposeV">
      <summary>
            Decomposes the gSurface into BÃ©zier patches in the U parametric direction.
            </summary>
      <returns>A list of gSurfaces.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Decompose">
      <summary>
            Decomposes the gSurface into BÃ©zier patches.
            </summary>
      <returns>A rectangular array of gSurfaces.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.RemoveKnotU(System.Int32,System.Int32,System.Int32)">
      <summary>
            Removes an internal knot from the gSurface U knot vector.
            </summary>
      <param name="r">The knot to remove</param>
      <param name="s">The multiplicity of the knot</param>
      <param name="num">The number of times to try to remove the knot</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.RemoveKnotV(System.Int32,System.Int32,System.Int32)">
      <summary>
            Removes an internal knot from the gSurface V knot vector.
            </summary>
      <param name="r">The knot to remove</param>
      <param name="s">The multiplicity of the knot</param>
      <param name="num">The number of times to try to remove the knot</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.RemoveKnotsU(System.Double)">
      <summary>
            Removes as many knots as possible from the U knot vector of a gSurface.
            </summary>
      <param name="tol">The allowed tolerance</param>
      <returns>Number of knots removed.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.RemoveKnotsV(System.Double)">
      <summary>
            Removes as many knots as possible from the V knot vector of a gSurface.
            </summary>
      <param name="tol">The allowed tolerance</param>
      <returns>Number of knots removed.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.GlobalInterpolation(devDept.Geometry.Point3D[0:,0:],System.Int32,System.Int32)">
      <summary>
            Global gSurface interpolation.
            </summary>
      <param name="Q">A matrix of 3D points</param>
      <param name="degU">The degree of interpolation in the U direction</param>
      <param name="degV">The degree of interpolation in the V direction</param>
      <returns>The interpolated gSurface if the operation is successful, null/Nothing otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.LocalInterpolation(devDept.Geometry.Point3D[0:,0:])">
      <summary>
            Local bicubic gSurface interpolation.
            </summary>
      <param name="Q">A matrix of 3D points.</param>
      <returns>The interpolated gSurface.</returns>
    </member>
    <!-- Badly formed XML comment ignored for member "M:devDept.Geometry.Entities.GSurface.SolLineEqua2x2(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double@,System.Double@)" -->
    <member name="T:devDept.Geometry.Entities.GSurface.regionInflateType">
      <summary>
            FOr internal use only.
            </summary>
            TODO Geo TRS: rimettere internal
        </member>
    <member name="M:devDept.Geometry.Entities.GSurface.GetEmptyRegion(devDept.Geometry.Entities.GSurface.regionInflateType)">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.ControlBoundingBox">
      <summary>
            Returns the 3D size of the gSurface control point net axis aligned bounding box.
            </summary>
      <returns>The 3D size</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.ControlBoundingBox(devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">
      <summary>
            Computes the minimum and maximum 3D points of the gSurface control point net axis aligned bounding box.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Section(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},devDept.Geometry.Plane,System.Double)">
      <summary>
            Computes the section of a group of gSurfaces and a plane as a collection of curves.
            </summary>
      <param name="listF">GSurface group</param>
      <param name="pln">The plane</param>
      <param name="tol">The tolerance</param>
      <returns>The array of intersection curves.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Intersection(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Double,devDept.Geometry.Entities.IGCurve[]@)">
      <summary>
            Computes the intersection of two groups of gSurfaces as a collection of curves.
            </summary>
      <param name="listF">First gSurface group</param>
      <param name="listG">Second gSurface group</param>
      <param name="iGCurves">A list of intersection curves</param>
      <param name="tol">The tolerance</param>
      <returns>The intersection failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.IntersectWith(devDept.Geometry.Entities.GSurface,System.Double,devDept.Geometry.Entities.IGCurve[]@)">
      <summary>
            Computes the intersection with the specified gSurface as a collection of curves.
            </summary>
      <param name="G">The gSurface</param>
      <param name="iGCurves">A list of intersection curves</param>
      <param name="tol">The tolerance</param>
      <returns>The intersection failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Intersect(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Double)">
      <summary>
            Determines if two groups of surfaces intersect.
            </summary>
      <param name="listF">First surface group</param>
      <param name="listG">Second surface group</param>
      <param name="tol">The tolerance</param>
      <returns>True if the surfaces intersect, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Intersects(devDept.Geometry.Entities.GSurface,System.Double)">
      <summary>
            Determines if the surface intersects with another surface.
            </summary>
      <param name="G">The surface</param>
      <param name="tol">The tolerance</param>
      <returns>True if the surfaces intersect, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.IntersectWith(devDept.Geometry.Plane,System.Double)">
      <summary>
            Computes the intersection of a gSurface and a plane as a collection of curves.
            </summary>
      <param name="pln">The plane</param>
      <param name="tol">The tolerance</param>
      <returns>The array of intersection curves.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.IntersectWith(devDept.Geometry.Entities.IGCurve,System.Double)">
      <summary>
            Finds all the 3D points where a igCurve and a gSurface intersect.
            </summary>
      <param name="curve3D">The 3D igCurve</param>
      <param name="searchTol">The search tolerance</param>
      <returns>The list of intersection points (if any).</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.MinimumDistance(devDept.Geometry.Entities.GSurface,devDept.Geometry.Entities.GSurface,System.Double,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
      <summary>
            Computes the minimum distance between two gSurfaces.
            </summary>
      <param name="F">First gSurface</param>
      <param name="G">Second gSurface</param>
      <param name="tol">Tolerance</param>
      <param name="u">Initial guess on F gSurface U parametric direction</param>
      <param name="v">Initial guess on F gSurface V parametric direction</param>
      <param name="s">Initial guess on G gSurface U parametric direction</param>
      <param name="t">Initial guess on G gSurface V parametric direction</param>
      <param name="distance">The resulting minimum distance</param>
      <returns>True if the operation was successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.MinimumDistance(devDept.Geometry.Entities.GSurface,devDept.Geometry.Entities.GSurface,System.Double,System.Boolean,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
      <summary>
            Computes the minimum distance between two surfaces.
            </summary>
      <param name="F">First surface</param>
      <param name="G">Second surface</param>
      <param name="tol">Tolerance</param>
      <param name="allowOutside">If true result could be outside of the curve</param>
      <param name="u">Initial guess on F surface U parametric direction</param>
      <param name="v">Initial guess on F surface V parametric direction</param>
      <param name="s">Initial guess on G surface U parametric direction</param>
      <param name="t">Initial guess on G surface V parametric direction</param>
      <param name="distance">The resulting minimum distance</param>
      <returns>True if the operation was successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.MinimumDistance(devDept.Geometry.Entities.GCurve,devDept.Geometry.Entities.GSurface,System.Double,System.Double@,System.Double@,System.Double@,System.Double@)">
      <summary>
            Computes the minimum distance between a curve and a surface
            </summary>
      <param name="C">The curve</param>
      <param name="S">The surface</param>
      <param name="tol">Tolerance</param>
      <param name="s">Initial guess on C curve</param>
      <param name="u">Initial guess on S surface U parametric direction</param>
      <param name="v">Initial guess on S surface U parametric direction</param>
      <param name="distance">The resulting minimum distance</param>
      <returns>True if the operation was successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.MinimumDistance(devDept.Geometry.Entities.GCurve,devDept.Geometry.Entities.GSurface,System.Double,System.Boolean,System.Double@,System.Double@,System.Double@,System.Double@)">
      <summary>
            Computes the minimum distance between a curve and a surface
            </summary>
      <param name="C">The curve</param>
      <param name="S">The surface</param>
      <param name="tol">Tolerance</param>
      <param name="allowOutside">If true result could be outside of the curve</param>
      <param name="s">Initial guess on C curve</param>
      <param name="u">Initial guess on S surface U parametric direction</param>
      <param name="v">Initial guess on S surface U parametric direction</param>
      <param name="distance">The resulting minimum distance</param>
      <returns>True if the operation was successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.CollinearNormal(devDept.Geometry.Entities.GSurface,devDept.Geometry.Entities.GSurface,System.Double,System.Double@,System.Double@,System.Double@,System.Double@)">
      <summary>
            Computes the collinear normal between two gSurfaces.
            </summary>
      <param name="F">First gSurface</param>
      <param name="G">Second gSurface</param>
      <param name="tol">Tolerance</param>
      <param name="u">Initial guess on F gSurface U parametric direction</param>
      <param name="v">Initial guess on F gSurface V parametric direction</param>
      <param name="s">Initial guess on G gSurface U parametric direction</param>
      <param name="t">Initial guess on G gSurface V parametric direction</param>
      <returns>True if the operation was successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Offset(System.Double,System.Double,devDept.Geometry.Entities.GSurface@)">
      <summary>
            Computes the offset gSurface.
            </summary>
      <param name="amount">The signed distance</param>
      <param name="tol">The tolerance</param>
      <param name="offsetSurf">The resulting offset gSurface</param>
      <returns>True if the operation is succeful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.BuildOffsetSurface(System.Double,System.Double)">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSurface.leftEdge">
      <summary>
            GSurface's bottom pole or tip.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSurface.topEdge">
      <summary>
            GSurface's right pole or tip.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSurface.rightEdge">
      <summary>
            GSurface's top pole or tip.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Entities.GSurface.bottomEdge">
      <summary>
            GSurface's left pole or tip.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.ExtractLoops3D">
      <summary>
            Returns all the gSurface 3D edge igCurves.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.ExtractEdges">
      <summary>
            Returns all the gSurface 3D edge igCurves.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.ExtractEdge(System.Int32,System.Int32)">
      <summary>
            Returns the specified 3D edge igCurve.
            </summary>
      <param name="loopIndex">Trim loop index</param>
      <param name="curveIndex">Loop igCurve index</param>
      <returns>The gSurface 3D edge as an individual igCurve.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.RebuildEdge(System.Int32,System.Int32,System.Double)">
      <summary>
            Rebuild the 3D edge igCurve corresponding to a 2D trim igCurve in the parameter space of the gSurface.
            </summary>
      <param name="loopIndex">Trim loop index</param>
      <param name="curveIndex">Loop igCurve index</param>
      <param name="tolerance">The tolerance used in the rebuild process</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.RebuildEdges(System.Double)">
      <summary>
            Rebuild all the gSurface 3D edges.
            </summary>
      <param name="tolerance">The tolerance used in the rebuild process</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.LiftCurve(devDept.Geometry.Entities.GCurve,System.Double)">
      <summary>
            Creates the 3D igCurve corresponding to a 2D igCurve in the parametric space of the gSurface.
            </summary>
      <param name="curve">The igCurve in parametric space.</param>
      <param name="tol">Allowed tolerance</param>
      <returns>The individual 3D igCurve.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.ClosestPointTo(devDept.Geometry.Point3D,System.Double@,System.Double@)">
      <summary>
            Finds the closest point on the gSurface.
            </summary>
      <param name="P">The 3D point to project</param>
      <param name="u">The U parametric coordinate of the closest point on gSurface to P</param>
      <param name="v">The V parametric coordinate of the closest point on gSurface to P</param>
      <remarks>It also checks the trimloops, so that the result is always on the gSurface.</remarks>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.ClosestPointTo(devDept.Geometry.Point3D,devDept.Geometry.Point3D@)">
      <summary>
            Computes the signed distance between a 3D point and this gSurface object.
            </summary>
      <param name="P">The 3D point</param>
      <param name="closest">The closest 3D point to P</param>
      <returns>The signed distance with this gSurface object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Project(devDept.Geometry.Point3D,devDept.Geometry.Point2D@)">
      <summary>
            Projects a point on the gSurface.
            </summary>
      <param name="P">The 3D point to project</param>
      <param name="proj">The parametric position of the projection on gSurface to P</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Project(devDept.Geometry.Point3D,System.Double,System.Boolean,devDept.Geometry.Point2D@)">
      <summary>
            Projects a point on the gSurface.
            </summary>
      <param name="P">The 3D point to project</param>
      <param name="allowOutside">When true, the projection is not constrained inside the gSurface domain</param>
      <param name="proj">The parametric coordinates of projection on gSurface to P</param>
      <param name="coincTol">Relevant only when P lays on the gSurface. When the distance between P and its projection is smaller then this value, the projection is considered succesful.</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Project(devDept.Geometry.Point3D,System.Double,System.Boolean,devDept.Geometry.Point2D@,devDept.Geometry.Vector2D@)">
      <summary>
            Projects a point on the gSurface.
            </summary>
      <param name="P">The 3D point to project</param>
      <param name="allowOutside">When true, the projection is not constrained inside the gSurface domain</param>
      <param name="proj">The parametric coordinates of projection on gSurface to P</param>
      <param name="coincTol">Relevant only when P lays on the gSurface. When the distance between P and its projection is smaller then this value, the projection is considered succesful.</param>
      <param name="W">The 2D tangent vector in parametric space</param>
      <returns>True when the projection is perpendicular to the gSurface, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Project(devDept.Geometry.Point3D,System.Double,System.Boolean,devDept.Geometry.Point2D,devDept.Geometry.Point2D@)">
      <summary>
            Projects a point on the gSurface.
            </summary>
      <param name="P">The 3D point to project</param>
      <param name="proj">The parametric coordinates of the projection on gSurface to P</param>
      <param name="coincTol">Relevant only when P lays on the gSurface. When the distance between P and its projection is smaller then this value, the projection is considered succesful.</param>
      <param name="allowOutside">When true, the projection is not constrained inside the gSurface domain</param>
      <param name="prev">The parametric coordinates of a previous succesful point projection</param>
      <returns>True when the projection is perpendicular to the gSurface, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Project(devDept.Geometry.Point3D,System.Double,System.Boolean,System.Double,System.Double,System.Double@,System.Double@)">
      <summary>
            Projects a point on the gSurface.
            </summary>
      <param name="P">The 3D point to project</param>
      <param name="u">The U parametric coordinate of the projection on gSurface to P</param>
      <param name="v">The V parametric coordinate of the projection on gSurface to P</param>
      <param name="coincTol">Relevant only when P lays on the gSurface. When the distance between P and its projection is smaller then this value, the projection is considered succesful.</param>
      <param name="allowOutside">When true, the projection is not constrained inside the gSurface domain</param>
      <param name="prevU">The U parametric coordinate of a previous succesful point projection</param>
      <param name="prevV">The V parametric coordinate of a previous succesful point projection</param>
      <returns>True when the projection is perpendicular to the gSurface, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Project(devDept.Geometry.Point3D,System.Double,System.Boolean,devDept.Geometry.Point2D,devDept.Geometry.Point2D@,devDept.Geometry.Vector2D@)">
      <summary>
            Projects a point on the gSurface.
            </summary>
      <param name="P">The 3D point to project</param>
      <param name="proj">The parametric coordinates of the projection on gSurface to P</param>
      <param name="coincTol">Relevant only when P lays on the gSurface. When the distance between P and its projection is smaller then this value, the projection is considered succesful.</param>
      <param name="allowOutside">When true, the projection is not constrained inside the gSurface domain</param>
      <param name="prev">The parametric coordinates of a previous succesful point projection</param>
      <param name="W">The 2D tangent vector in parametric space</param>
      <returns>True when the projection is perpendicular to the gSurface, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Project(devDept.Geometry.Point3D,System.Double,System.Boolean,System.Double,System.Double,System.Double@,System.Double@,devDept.Geometry.Vector2D@)">
      <summary>
            Projects a point on the gSurface.
            </summary>
      <param name="P">The 3D point to project</param>
      <param name="u">The U parametric coordinate of the projection on gSurface to P</param>
      <param name="v">The V parametric coordinate of the projection on gSurface to P</param>
      <param name="coincTol">Relevant only when P lays on the gSurface. When the distance between P and its projection is smaller then this value, the projection is considered succesful.</param>
      <param name="allowOutside">When true, the projection is not constrained inside the gSurface domain</param>
      <param name="prevU">The U parametric coordinate of a previous successful point projection</param>
      <param name="prevV">The V parametric coordinate of a previous successful point projection</param>
      <param name="W">The 2D tangent vector in parametric space</param>
      <returns>True when the projection is perpendicular to the gSurface, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Project(devDept.Geometry.Point3D,System.Double@,System.Double@)">
      <summary>
            Projects a point on the gSurface.
            </summary>
      <param name="P">The 3D point to project</param>
      <param name="u">The U parametric coordinate of the projection on gSurface to P</param>
      <param name="v">The V parametric coordinate of the projection on gSurface to P</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Project(devDept.Geometry.Point3D,System.Double,devDept.Geometry.Point2D@)">
      <summary>
            Projects a point on the gSurface.
            </summary>
      <param name="P">The 3D point to project</param>
      <param name="coincTol">Relevant only when P lays on the gSurface. When the distance between P and its projection is smaller then this value, the projection is considered succesful.</param>
      <param name="proj">The parametric coordinates of the projection on gSurface to P</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Project(devDept.Geometry.Point3D,System.Double,System.Boolean,System.Double@,System.Double@)">
      <summary>
            Projects a point on the gSurface.
            </summary>
      <param name="P">The 3D point to project</param>
      <param name="coincTol">Relevant only when P lays on the gSurface. When the distance between P and its projection is smaller then this value, the projection is considered succesful.</param>
      <param name="allowOutside">When true, the projection is not constrained inside the gSurface domain</param>
      <param name="u">The U parametric coordinate of the projection on gSurface to P</param>
      <param name="v">The V parametric coordinate of the projection on gSurface to P</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.PointInversion(devDept.Geometry.Point3D,System.Double,System.Double@,System.Double@)">
      <summary>
            Projects a point on the gSurface. The point must already lay on the gSurface.
            </summary>
      <param name="P">The 3D point to project</param>
      <param name="coincTol">Relevant only when P lays on the gSurface. When the distance between P and its projection is smaller then this value, the projection is considered succesful.</param>
      <param name="u">The U parametric coordinate of the projection on gSurface to P</param>
      <param name="v">The V parametric coordinate of the projection on gSurface to P</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Project(devDept.Geometry.Point3D,System.Double,System.Boolean,System.Double@,System.Double@,devDept.Geometry.Vector2D@)">
      <summary>
            Projects a point on the gSurface.
            </summary>
      <param name="P">The 3D point to project</param>
      <param name="coincTol">Relevant only when P lays on the gSurface. When the distance between P and its projection is smaller then this value, the projection is considered succesful.</param>
      <param name="allowOutside">When true, the projection is not constrained inside the surace domain</param>
      <param name="u">The U parametric coordinate of the projection on gSurface to P</param>
      <param name="v">The V parametric coordinate of the projection on gSurface to P</param>
      <param name="W">The 2D tangent vector in parametric space</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.PointInversion(devDept.Geometry.Point3D,System.Double,devDept.Geometry.Point2D@,devDept.Geometry.Vector2D@)">
      <summary>
            Projects a point on the gSurface. The point must already lay on the gSurface.
            </summary>
      <param name="P">The 3D point to project</param>
      <param name="coincTol">Relevant only when P lays on the gSurface. When the distance between P and its projection is smaller then this value, the projection is considered succesful.</param>
      <param name="proj">The parametric coordinates of the projection on gSurface to P</param>
      <param name="W">The 2D tangent vector in parametric space</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.PointInversion(devDept.Geometry.Point3D,System.Double,devDept.Geometry.Point2D@)">
      <summary>
            Projects a point on the gSurface. The point must already lay on the gSurface.
            </summary>
      <param name="P">The 3D point to project</param>
      <param name="coincTol">Relevant only when P lays on the gSurface. When the distance between P and its projection is smaller then this value, the projection is considered succesful.</param>
      <param name="proj">The parametric coordinates of the projection on gSurface to P</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.PointInversion(devDept.Geometry.Point3D,System.Double,System.Double@,System.Double@,devDept.Geometry.Vector2D@)">
      <summary>
            Projects a point on the gSurface. The point must already lay on the gSurface.
            </summary>
      <param name="P">The 3D point to project</param>
      <param name="coincTol">Relevant only when P lays on the gSurface. When the distance between P and its projection is smaller then this value, the projection is considered succesful.</param>
      <param name="u">The U parametric coordinate of the projection on gSurface to P</param>
      <param name="v">The V parametric coordinate of the projection on gSurface to P</param>
      <param name="W">The 2D tangent vector in parametric space</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.DropLoops(devDept.Geometry.Entities.GSurface,System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve})">
      <summary>
            Creates the 2D parametric trim loops corresponding to a 3D geometric - closed - contours list which lie on a gSurface.
            </summary>
      <param name="untrimmed">The gSurface</param>
      <param name="contours">A list of 3D contours</param>
      <returns>One or more trimmed gSurfaces.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.GetPlanarRegion(devDept.Geometry.Plane,System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve})">
      <summary>
            Prepare contours for planar gSurfaces. For internal use only.
            </summary>
            TODO Geo TRS
        </member>
    <member name="T:devDept.Geometry.Entities.GSurface.PolygonPoint">
      <summary>
        <see cref="P:devDept.Geometry.Entities.GSurface.PolyRegion" /> 2D point definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.PolygonPoint.TrimCurveIndex">
      <summary>
            Gets or sets the curve index.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.PolygonPoint.#ctor(System.Double,System.Double,System.Int32)">
      <summary>
            Standard constructor.
            </summary>
      <param name="x">GPoint's X coordinate</param>
      <param name="y">GPoint's Y coordinate</param>
      <param name="trimCurveIndex">Trim curve index</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.DropCurve(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.GCurve@)">
      <summary>
            Creates the 2D parametric curve corresponding to a 3D geometric curve which lies on or near a gSurface.
            </summary>
      <param name="curve">The curve to be dropped</param>
      <param name="parametric">The resulting 2D curve</param>
      <returns>True if the function succeeded, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.IsOnSeamU(devDept.Geometry.Entities.IGCurve,System.Double)">
      <summary>
            Checks if a curve is on the seam of a surface.
            </summary>
      <param name="curve">The curve</param>
      <param name="tol">Maximum distance from seam curve</param>
      <returns>True if the curve lies on the seam, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.IsOnSeamV(devDept.Geometry.Entities.IGCurve,System.Double)">
      <summary>
            Checks if a curve is on the seam of a gSurface.
            </summary>
      <param name="curve">The curve</param>
      <param name="tol">Maximum distance from seam curve</param>
      <returns>True if the curve lies on the seam, false otherwise.</returns>
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.DomainU">
      <summary>
            Gets gSurface domain in U parametric direction.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.DomainV">
      <summary>
            Gets gSurface domain in V parametric direction.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.Trimming">
      <summary>
            Gets or sets the surface's trimming region.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.IsClosedU">
      <summary>
            Returns true if the gSurface is closed in the U direction.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.IsClosedV">
      <summary>
            Returns true if the gSurface is closed in the V direction.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.IsRational">
      <summary>
            Returns true if the gSurface is rational.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.KnotVectorU">
      <summary>
            Gets or sets the gSurface knot vector in the U parametric direction.
            </summary>
      <remarks>Not validated in setter. Use constructor if you are unsure of the correctness of your data.</remarks>
      <seealso cref="M:devDept.Geometry.Entities.GSurface.IsValid(devDept.Geometry.Point3D[])" />
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.KnotVectorV">
      <summary>
            Gets or sets the gSurface knot vector in the V parametric direction.
            </summary>
      <remarks>Not validated in setter. Use constructor if you are unsure of the correctness of your data.</remarks>
      <seealso cref="!:IsValid()" />
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.DegreeU">
      <summary>
            Gets gSurface degree in the U direction.
            </summary>
      <remarks>Not validated in setter. Use constructor if you are unsure of the correctness of your data.</remarks>
      <seealso cref="M:devDept.Geometry.Entities.GSurface.IsValid(devDept.Geometry.Point3D[])" />
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.DegreeV">
      <summary>
            Gets gSurface degree in the V direction.
            </summary>
      <remarks>Not validated in setter. Use constructor if you are unsure of the correctness of your data.</remarks>
      <seealso cref="M:devDept.Geometry.Entities.GSurface.IsValid(devDept.Geometry.Point3D[])" />
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.ControlPoints">
      <summary>
            Gets the gSurface control points array.
            </summary>
      <remarks>Not validated in setter. Use constructor if you are unsure of the correctness of your data.</remarks>
      <seealso cref="M:devDept.Geometry.Entities.GSurface.IsValid(devDept.Geometry.Point3D[])" />
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.IsTrimmed">
      <summary>
            Returns true if the gSurface is trimmed.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.SeamU">
      <summary>
            Gets gSurface seam U, if exists.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.SeamV">
      <summary>
            Gets gSurface seam V, if exists.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.TextureScaleU">
      <summary>
            Gets or set surface texture mapping scale in U direction.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.TextureScaleV">
      <summary>
            Gets or set surface texture mapping scale in V direction.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.TextureOffsetU">
      <summary>
            Gets or set surface texture mapping offset in U direction.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.TextureOffsetV">
      <summary>
            Gets or set surface texture mapping offset in V direction.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GSurface.PolyRegion">
      <summary>
            Gets or sets surface tessellation polygonal region.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.ConvertToMesh(System.Double,System.Double,devDept.Geometry.Entities.GMesh.natureType,System.Boolean)">
      <summary>
            Converts this Surface to a <see cref="!:Mesh" /> object.
            </summary>
      <param name="deviation">The maximum deviation, zero for current tessellation.</param>
      <param name="angle">The maximum angular deflection, ignored when zero.</param>
      <param name="meshNature">The desired Mesh <see cref="!:Mesh.natureType">nature</see></param>
      <param name="skipEdges">If true, skips the Edges computation</param>
      <returns>The resulting Mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.ConvertToBrep(System.Double)">
      <summary>
            Converts this GSurface to a <see cref="T:devDept.Geometry.Entities.GBrep" /> object.
            </summary>
      <param name="rebuildTolerance">The rebuild tolerance to set to the object. Zero for default value.</param>
      <returns>The resulting GBrep object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.ConvertToSolid(System.Double,System.Double)">
      <summary>
            Converts this Surface to a <see cref="!:Mesh" /> object.
            </summary>
      <param name="deviation">The maximum deviation, zero for current tessellation.</param>
      <param name="angle">The maximum angular deflection, ignored when zero.</param>
      <returns>The resulting Solid object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.TrimBy(devDept.Geometry.Entities.IGCurve,System.Boolean)">
      <summary>
            Trims the gSurface using an open or closed contour.
            </summary>
      <param name="contour">The 3D geometric contour</param>
      <param name="clockwise">If true, the contour orientation in 2D parametric domain will be clockwise (hole).</param>
      <returns>True if the operation succeeded, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.TrimInternal(devDept.Geometry.Entities.GSurface,System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Boolean)">
      <summary>
      </summary>
      <param name="surf">
      </param>
      <param name="curveList">Must be already oriented and sorted</param>
      <param name="clockwiseSense">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Trim(devDept.Geometry.Entities.GSurface,System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve})">
      <summary>
      </summary>
      <param name="surf">
      </param>
      <param name="curveList">Must be already oriented and sorted</param>
      <returns>
      </returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Reparametrize(devDept.Geometry.Entities.GSurface,System.Double@,System.Double@,devDept.Geometry.Entities.GSurface@)">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.TrimBy(devDept.Geometry.Entities.GSurface,System.Double,System.Boolean)">
      <summary>
            Trim the gSurface using the limit gSurface provided.
            </summary>
      <param name="G">Limit gSurface</param>
      <param name="tol">The tolerance</param>
      <param name="flipSide">Reverse flag</param>
      <returns>The failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.TrimBy(devDept.Geometry.Entities.GSurface,System.Double,System.Boolean,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Trim the gSurface using the limit gSurface provided.
            </summary>
      <param name="G">Limit gSurface</param>
      <param name="tol">The tolerance</param>
      <param name="flipSide">Reverse flag</param>
      <param name="leftOvers">Trim operation left over list</param>
      <returns>The failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.TrimBy(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Double,System.Boolean)">
      <summary>
            Trims the gSurface using the limit gSurface group provided.
            </summary>
      <param name="listG">Limit gSurface group</param>
      <param name="tol">The tolerance</param>
      <param name="flipSide">Reverse flag</param>
      <returns>The failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.TrimBy(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Double,System.Boolean,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Trims the gSurface using the limit gSurface group provided.
            </summary>
      <param name="listG">Limit gSurface group</param>
      <param name="tol">The tolerance</param>
      <param name="flipSide">Reverse flag</param>
      <param name="leftOvers">Trim operation left over list</param>
      <returns>The failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Trim(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},devDept.Geometry.Plane,System.Double)">
      <summary>
            Trims a gSurface group using the limit plane provided. Always removes the splits on the positive side of the plane.
            </summary>
      <param name="listF">The gSurface group</param>
      <param name="pln">The limit plane</param>
      <param name="tol">The tolerance</param>
      <returns>The failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Trim(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},devDept.Geometry.Plane,System.Double,System.Boolean,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Trims a gSurface group using the limit plane provided. Always removes the splits on the positive side of the plane.
            </summary>
      <param name="listF">The gSurface group</param>
      <param name="pln">The limit plane</param>
      <param name="tol">The tolerance</param>
      <param name="flipSideF">Reverse flag array for the gSurface group</param>
      <param name="leftOversF">Trim operation left over list</param>
      <returns>The failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.TrimBy(devDept.Geometry.Plane,System.Double,System.Boolean)">
      <summary>
            Trims the gSurface using the limit plane provided.
            </summary>
      <param name="pln">The limit plane</param>
      <param name="tol">The tolerance</param>
      <param name="flipSide">Reverse flag</param>
      <returns>The failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.TrimBy(devDept.Geometry.Plane,System.Double,System.Boolean,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Trims the gSurface using the limit plane provided.
            </summary>
      <param name="pln">The limit plane</param>
      <param name="tol">The tolerance</param>
      <param name="flipSide">Reverse flag</param>
      <param name="leftOvers">Trim operation leftovers list</param>
      <returns>The failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.TrimBy(devDept.Geometry.Plane,System.Double)">
      <summary>
            Trims the gSurface using the limit plane provided. Always removes the gSurface on the positive side of the plane.
            </summary>
      <param name="pln">The limit plane</param>
      <param name="tol">The tolerance</param>
      <returns>The failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Trim(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Double,System.Boolean,System.Boolean)">
      <summary>
            Trims a gSurface group against the other.
            </summary>
      <param name="listF">First gSurface group</param>
      <param name="listG">Second gSurface group</param>
      <param name="tol">The tolerance</param>
      <param name="flipSideF">Reverse flag for the first gSurface group</param>
      <param name="flipSideG">Reverse flag for the second gSurface group</param>
      <returns>The intersection failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Trim(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},System.Double,System.Boolean,System.Boolean,devDept.Geometry.Entities.GSurface[]@,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Trims a gSurface group against the other.
            </summary>
      <param name="listF">First gSurface group</param>
      <param name="listG">Second gSurface group</param>
      <param name="tol">The tolerance</param>
      <param name="flipSideF">Reverse flag for the first gSurface group</param>
      <param name="flipSideG">Reverse flag for the second gSurface group</param>
      <param name="leftOversF">Trim operation left over list</param>
      <param name="leftOversG">Trim operation left over list</param>
      <returns>The intersection failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Trim(devDept.Geometry.Entities.GSurface,devDept.Geometry.Entities.GSurface,System.Double,System.Boolean,System.Boolean)">
      <summary>
            Trims a gSurface against the other.
            </summary>
      <param name="F">First gSurface</param>
      <param name="G">Second gSurface</param>
      <param name="tol">The tolerance</param>
      <param name="flipSideF">Reverse flag for the first gSurface</param>
      <param name="flipSideG">Reverse flag for the second gSurface</param>
      <returns>The failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Trim(devDept.Geometry.Entities.GSurface,devDept.Geometry.Entities.GSurface,System.Double,System.Boolean,System.Boolean,devDept.Geometry.Entities.GSurface[]@,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Trims a gSurface against the other.
            </summary>
      <param name="F">First gSurface</param>
      <param name="G">Second gSurface</param>
      <param name="tol">The tolerance</param>
      <param name="flipSideF">Reverse flag for the first gSurface</param>
      <param name="flipSideG">Reverse flag for the second gSurface</param>
      <param name="leftOversF">
      </param>
      <param name="leftOversG">
      </param>
      <returns>The failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Trim(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},devDept.Geometry.Plane,System.Double,System.Boolean)">
      <summary>
            Trims a gSurface group by a plane.
            </summary>
      <param name="listF">The gSurface group</param>
      <param name="pln">The plane</param>
      <param name="tol">The tolerance</param>
      <param name="flipSideF">Reverse flag array for the first gSurface group</param>
      <returns>The intersection failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.SplitBy(devDept.Geometry.Plane,System.Double,devDept.Geometry.Entities.GSurface[]@,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Splits the gSurface by a plane.
            </summary>
      <param name="pln">The plane</param>
      <param name="tol">The tolerance</param>
      <param name="splitsF">The resulting F gSurface splits</param>
      <param name="splitsG">The resulting gIg gSurface splits</param>
      <returns>The intersection failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.TrimBy(devDept.Geometry.Plane,System.Double,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Trims the gSurface using the limit plane provided. Always removes the gSurface on the positive side of the plane.
            </summary>
      <param name="pln">The limit plane</param>
      <param name="tol">The tolerance</param>
      <param name="leftOvers">Trim operation left over list</param>
      <returns>The failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.SplitBy(devDept.Geometry.Entities.GSurface,System.Double,devDept.Geometry.Entities.GSurface[]@,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Splits the gSurface by a gSurface.
            </summary>
      <param name="G">The gSurface</param>
      <param name="tol">The tolerance</param>
      <param name="splitF">F gSurface split list</param>
      <param name="splitG">gIg gSurface split list </param>
      <returns>The intersection failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Split(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},devDept.Geometry.Entities.GSurface,System.Double,devDept.Geometry.Entities.GSurface[]@,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Splits a gSurface group by a gSurface.
            </summary>
      <param name="listF">The gSurface group</param>
      <param name="G">The gSurface</param>
      <param name="tol">The tolerance</param>
      <param name="splitF">F gSurface split list</param>
      <param name="splitG">gIg gSurface split list</param>
      <returns>The intersection failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.Split(System.Collections.Generic.IList{devDept.Geometry.Entities.GSurface},devDept.Geometry.Plane,System.Double,devDept.Geometry.Entities.GSurface[]@,devDept.Geometry.Entities.GSurface[]@)">
      <summary>
            Splits a gSurface group by a plane.
            </summary>
      <param name="listF">The gSurface group</param>
      <param name="pln">The plane</param>
      <param name="tol">The tolerance</param>
      <param name="splitF">F gSurface split list</param>
      <param name="splitG">gIg gSurface split list</param>
      <returns>The intersection failure type.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GSurface.SplitBy(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.GSurface@,devDept.Geometry.Entities.GSurface@)">
      <summary>
            Splits the gSurface using an open or closed contour.
            </summary>
      <param name="contour">The 3D geometric contour</param>
      <param name="split1">The first split</param>
      <param name="split2">The second split</param>
      <returns>True if the operation succeeded, false otherwise.</returns>
    </member>
    <member name="T:devDept.Geometry.Entities.GTabulatedSurface">
      <summary>
            Tabulated gSurface definition, formed by moving a line segment called the generatrix parallel to itself along a igCurve called the directrix.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GTabulatedSurface.Directrix">
      <summary>
            Gets the tabulated gSurface generatrix.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GTabulatedSurface.Generatrix">
      <summary>
            Gets the tabulated gSurface generatrix.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GTabulatedSurface.#ctor(System.Int32,System.Double[],System.Int32,System.Double[],devDept.Geometry.Point4D[0:,0:],devDept.Geometry.Vector3D,devDept.Geometry.Entities.IGCurve)">
      <summary>
            Deserialization constructor.
            </summary>
      <param name="uDegree">Degree in the U parametric direction</param>
      <param name="uKnotVector">Knot vector in the U parametric direction</param>
      <param name="vDegree">Degree in the V parametric direction</param>
      <param name="vKnotVector">Knot vector in the V parametric direction</param>
      <param name="ctrlPoints">Control points grid</param>
      <param name="theGeneratrix">Generatrix 3D vector</param>
      <param name="theDirectrix">Directrix igCurve</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GTabulatedSurface.Clone">
      <summary>
            Creates a deep copy of this revolution gSurface.
            </summary>
      <returns>The new revolution gSurface object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GTabulatedSurface.IsOrthogonal">
      <summary>
            This method determines a priori if we can apply the fast point projection on this tabulated gSurface.
            </summary>
      <returns>True if the directix is a planar igCurve and its plane is perpendicular to the generatrix, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GTabulatedSurface.TryGetCylindrical(devDept.Geometry.Entities.GSurface@)">
      <summary>
            Converts this tabulated gSurface to <see cref="T:devDept.Geometry.Entities.GCylindricalSurface" /> (when possible).
            </summary>
      <returns>The resulting cylindrical gSurface (when possible)</returns>
      <returns>True if the operation succeeds, false otherwise.</returns>
      <remarks>To be converted, this tabulated gSurface must have a GCircle or an GArc as directrix.</remarks>
    </member>
    <member name="T:devDept.Geometry.Entities.GTrimCurve">
      <summary>
            Trim curve definition (2D parametric).
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GTrimCurve.Index">
      <summary>
            Gets or sets the curve index.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Entities.GTrimCurve.Edge">
      <summary>
            Associated 3D edge of this trim curve (model space).
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GTrimCurve.#ctor(System.Int32,System.Double[],devDept.Geometry.Point4D[],devDept.Geometry.Entities.IGCurve)">
      <summary>
            Parametric space curve data and edge constructor.
            </summary>
      <param name="degree">The parametric space curve degree</param>
      <param name="knotVector">The parametric space curve knot vector</param>
      <param name="ctrlPoints">The parametric space curve control points</param>
      <param name="edge">The associated model space edge</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GTrimCurve.#ctor(devDept.Geometry.Entities.GCurve,devDept.Geometry.Entities.IGCurve)">
      <summary>
            Parametric space curve and model space edge constructor.
            </summary>
      <param name="parametricSpace">The parametric space curve</param>
      <param name="modelSpace">The associated model space edge</param>
    </member>
    <member name="M:devDept.Geometry.Entities.GTrimCurve.Clone">
      <summary>
            Creates a deep copy of this trim curve.
            </summary>
      <returns>The new trim curve object.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GTrimCurve.Reverse">
      <summary>
            Reverses both the 2D parametric trim curve and the associated 3D geometric edge.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GTrimCurve.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">
      </param>
      <param name="ctxt">
      </param>
    </member>
    <member name="M:devDept.Geometry.Entities.GTrimCurve.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Entities.GTrimCurve.IsHorizontal(System.Double)">
      <summary>
            Returns true if the trim curve is horizontal.
            </summary>
      <param name="domainV">Domain V length</param>
      <returns>True if the line is horizontal, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Entities.GTrimCurve.IsVertical(System.Double)">
      <summary>
            Returns true if the trim curve is horizontal.
            </summary>
      <param name="domainU">Domain U length</param>
      <returns>True if the line is horizontal, false otherwise.</returns>
    </member>
    <member name="P:devDept.Geometry.QuadEntityDataNode.TreeSource">
      <summary>
            Gets the reference to the entire tree on which this node belongs to.
            </summary>
    </member>
    <member name="P:devDept.Geometry.QuadEntityDataNode.Children">
      <summary>
            Gets the children of the current octant.
            </summary>
    </member>
    <member name="P:devDept.Geometry.QuadEntityDataNode.ElementsIndices">
      <summary>
            Gets the indices of the elements stored in the current node (the elements in the children are not included).
            </summary>
    </member>
    <member name="P:devDept.Geometry.QuadEntityDataNode.HasChildren">
      <summary>
            True if the current node has children.
            </summary>
    </member>
    <member name="M:devDept.Geometry.QuadEntityDataNode.IsElemInsideNode(System.Int32)">
      <summary>
            Checks when the element at elemIndex is inside the Quad node
            </summary>
      <param name="elemIndex">the index of the element in the source entity element list(vertices or triangles)</param>
      <returns>true if the element is completly inside the quad node. False otherwise.</returns>
    </member>
    <member name="T:devDept.Geometry.QuadTree">
      <summary>
            This class help divide the GMesh's space in 8 parts, each one with a definite number of Triangles.
            </summary>
    </member>
    <member name="P:devDept.Geometry.QuadTree.OriginalDataSource">
      <summary>
            The original <see cref="T:devDept.Geometry.Entities.GEntity" /> on which the tree subdivision data refers to.
            </summary>
    </member>
    <member name="P:devDept.Geometry.QuadTree.Root">
      <summary>
            The first node of the tree. It can be a <see cref="T:devDept.Geometry.QuadEntityDataNode" /> for <see cref="T:devDept.Geometry.QuadTree" /> or <see cref="T:devDept.Geometry.Octant" /> for <see cref="T:devDept.Geometry.Octree" />.
            </summary>
    </member>
    <member name="M:devDept.Geometry.QuadTree.#ctor(devDept.Geometry.Entities.GEntity,System.Double)">
      <summary>
            Initializes a new instance of the <see cref="T:devDept.Geometry.Octree" /> class.
            Standard Constructor that defines the maximum number of triangles per Octant as (GMesh.Triangles.Length / 100).
            </summary>
      <param name="entity">The GEntity to be subdivided</param>
      <param name="chordalError">The chordalError needed to regenerate the input entity (if curved type)</param>
    </member>
    <member name="M:devDept.Geometry.QuadTree.#ctor(devDept.Geometry.QuadTree)">
      <summary>
            Build Octree from other (to build OrientedOctree quickly). The resulting Octree should be Read Only.
            (For internal use only)
            </summary>
    </member>
    <member name="M:devDept.Geometry.QuadTree.#ctor(devDept.Geometry.Entities.GEntity,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:devDept.Geometry.QuadTree" /> class.
            Constructor with possibility to define an integer for maximum number of element per Quad node.
            </summary>
      <param name="GEntity">The 2D GEntity source to subdivide</param>
      <param name="limit">Maximum number of element per Quad node</param>
    </member>
    <member name="M:devDept.Geometry.QuadTree.DoWork(System.ComponentModel.BackgroundWorker,System.ComponentModel.DoWorkEventArgs)">
      <summary>
            Does the work.
            </summary>
      <param name="worker">The worker.</param>
      <param name="doWorkEventArgs">The <see cref="T:System.ComponentModel.DoWorkEventArgs" /> instance containing the event data.</param>
    </member>
    <member name="T:devDept.Geometry.Octree">
      <summary>
            This class help divide the GMesh's space in 8 parts, each one with a definite number of Triangles.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Octree.Root">
      <summary>
            The first node of the tree.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Octree.#ctor(devDept.Geometry.Entities.GMesh)">
      <summary>
            Initializes a new instance of the <see cref="T:devDept.Geometry.Octree" /> class.
            Standard Constructor that defines the maximum number of triangles per Octant as (GMesh.Triangles.Length / 100).
            </summary>
      <param name="mesh">The mesh.</param>
    </member>
    <member name="M:devDept.Geometry.Octree.#ctor">
      <summary>
            Empty constructor - for internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Octree.#ctor(devDept.Geometry.Octree)">
      <summary>
            Build Octree from other (to build OrientedOctree quickly). The resulting Octree should be Read Only.
            (For internal use only)
            </summary>
    </member>
    <member name="M:devDept.Geometry.Octree.#ctor(devDept.Geometry.Entities.GMesh,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:devDept.Geometry.Octree" /> class.
            Constructor with possibility to define an integer for maximum number of triangles per Octant.
            </summary>
      <param name="mesh">The mesh.</param>
      <param name="limit">Maximum number of triangles per Octant.</param>
    </member>
    <member name="M:devDept.Geometry.Octree.DoWork(System.ComponentModel.BackgroundWorker,System.ComponentModel.DoWorkEventArgs)">
      <summary>
            Does the work.
            </summary>
      <param name="worker">The worker.</param>
      <param name="doWorkEventArgs">The <see cref="T:System.ComponentModel.DoWorkEventArgs" /> instance containing the event data.</param>
    </member>
    <member name="M:devDept.Geometry.Octree.FindClosestTriangle(devDept.Geometry.Segment3D,devDept.Geometry.Transformation,System.Collections.Generic.SortedList{System.Double,devDept.Geometry.Entities.HitTriangle})">
      <summary>
            Find intersection between Ray and Octant's GMesh.
            </summary>
      <param name="seg">The segment to check if intersect with the Triangles of the Octant GMesh </param>
      <param name="transf">The transformation applied to the Points of intersection</param>
      <param name="triList">Sorted list (distance related between segment's Start Point and HitPoint) of hit triangles</param>
    </member>
    <member name="T:devDept.Geometry.Octant">
      <summary>
            One of the eight space containing a definite number of Triangles per GMesh
            </summary>
    </member>
    <member name="M:devDept.Geometry.Octant.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Octree)">
      <summary>
            Bounding box min/max constructor.
            </summary>
      <param name="boxMin">Bounding box min corner</param>
      <param name="boxMax">Bounding box max corner</param>
    </member>
    <member name="M:devDept.Geometry.Octant.IsPointInside(devDept.Geometry.Point3D)">
      <summary>
            Checks if a point is inside the BoundingBox of the current node.
            </summary>
      <param name="point">
      </param>
      <returns>True if it's inside or onto the boundary of the BoundingBox, false otherwise.</returns>
    </member>
    <member name="T:devDept.Geometry.AccurateCollisionUtility">
      <summary>
            Utility class for helping CollisionDetection to compute Accurate intersections and volumes.
            </summary>
    </member>
    <member name="M:devDept.Geometry.AccurateCollisionUtility.Intersect(devDept.Geometry.Entities.GEntity,devDept.Geometry.Entities.GEntity,System.Boolean,System.Collections.Generic.List{devDept.Geometry.Entities.GEntity}@,System.String@)">
      <summary>
            Checks if two GEntity intersect geometrically.
            </summary>
      <param name="first">the GEntity to check intersection with second</param>
      <param name="second">the GEntity to check intersection with first</param>
      <param name="touch">When false doesn't consider the coincidences as intersections.</param>
      <param name="intersectionData">The information about the volumes and/or position of collisions</param>
      <param name="log">The resulting error log for the operation</param>
      <returns>True if the two entities intersect.</returns>
    </member>
    <member name="M:devDept.Geometry.AccurateCollisionUtility.Intersect2D(devDept.Geometry.Entities.GEntity,devDept.Geometry.Entities.GEntity,System.Boolean,System.Collections.Generic.List{devDept.Geometry.Entities.GEntity}@,System.String@)">
      <summary>
            Checks if two 2D GEntity intersect geometrically on Plane XY.
            </summary>
      <param name="first">the GEntity to check intersection with second</param>
      <param name="second">the GEntity to check intersection with first</param>
      <param name="touch">When false doesn't consider the coincidences as intersections.</param>
      <param name="intersectionData">The information about the volumes and/or position of collisions</param>
      <param name="log">The resulting error log for the operation</param>
      <returns>True if the two entities intersect.</returns>
    </member>
    <member name="M:devDept.Geometry.AccurateCollisionUtility.ComputeAccurateVolume(devDept.Geometry.Entities.GEntity,devDept.Geometry.Entities.GEntity,System.Collections.Generic.List{devDept.Geometry.Entities.GEntity}@)">
      <summary>
            Computes intersection volumes between the two input Entities depending on their type.
            The intersectionData is filled with the list of the intersection volumes found.
            </summary>
      <param name="entity1">The first entity</param>
      <param name="entity2">The second entity</param>
      <param name="intersectionData">The intersection volumes</param>
      <returns>True if the main volume computation succeeded, false otherwise.</returns>
      <remarks>The two input entities should have the same type.</remarks>
      <remarks> When the complex volumes computation fails, an easier accessible intersection data is returned anyway if available.</remarks>
    </member>
    <member name="M:devDept.Geometry.AccurateCollisionUtility.ComputeAccurateVolume2D(devDept.Geometry.Entities.GEntity,devDept.Geometry.Entities.GEntity,System.Collections.Generic.List{devDept.Geometry.Entities.GEntity}@)">
      <summary>
            Computes intersection volumes on XY plane between the two input Entities depending on their type.
            The intersectionData is filled with the list of the intersection volumes found.
            </summary>
      <param name="entity1">The first entity</param>
      <param name="entity2">The second entity</param>
      <param name="intersectionData">The intersection volumes</param>
      <returns>True if the main volume computation succeeded, false otherwise.</returns>
      <remarks>The two input entities should have the same type.</remarks>
      <remarks> When the complex volumes computation fails, an easier accessible intersection data is returned anyway if available.</remarks>
    </member>
    <member name="T:devDept.Geometry.MinimumDistance">
      <summary>
            Utility class to computes the minimum distance between BRep's vertices, edges, faces and BRep themselves.
            </summary>
      <remarks>As a side effect, you can use this class to compute minumum distance even between curves and points.</remarks>
      <seealso cref="!:ComputeDistances" />
    </member>
    <member name="T:devDept.Geometry.IntegerGrid">
      <summary>
            Utility class to map real coordinates on a grid integers.
            </summary>
    </member>
    <member name="M:devDept.Geometry.IntegerGrid.#ctor(System.Int32,devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            Standard constructor.
            </summary>
      <param name="halfSize">The half size of the integer grid</param>
      <param name="min">The minimum extend of the real coordinates</param>
      <param name="max">The maximum extend of the real coordinates</param>
    </member>
    <member name="P:devDept.Geometry.IntegerGrid.ScaleMax">
      <summary>
            Max scale factor from original to grid values.
            </summary>
    </member>
    <member name="M:devDept.Geometry.IntegerGrid.ScaleToGrid(System.Double,System.Double,System.Int32[])">
      <summary>
            Scales real coordinates to integer grid values.
            </summary>
      <param name="x">The x real coordinate to scale</param>
      <param name="y">The y real coordinate to scale</param>
      <param name="vertex">The array filled with the scaled integer values</param>
    </member>
    <member name="M:devDept.Geometry.IntegerGrid.ScaleToGrid(System.Double,System.Double,System.Int32@,System.Int32@)">
      <summary>
            Scales real coordinates to integer grid values.
            </summary>
      <param name="x">The x real coordinate to scale</param>
      <param name="y">The y real coordinate to scale</param>
      <param name="gridX">The scaled integer x value</param>
      <param name="gridY">The scaled integer y value</param>
    </member>
    <member name="M:devDept.Geometry.IntegerGrid.ScaleToGrid(System.Double,System.Double,System.Int64@,System.Int64@)">
      <summary>
            Scales real coordinates to integer grid values.
            </summary>
      <param name="x">The x real coordinate to scale</param>
      <param name="y">The y real coordinate to scale</param>
      <param name="gridX">The scaled integer x value</param>
      <param name="gridY">The scaled integer y value</param>
    </member>
    <member name="M:devDept.Geometry.IntegerGrid.ScaleYToGrid(System.Double)">
      <summary>
            Scales Y coordinate to integer grid value.
            </summary>
      <param name="y">The y real coordinate to scale</param>
      <return>The scaled integer y value</return>
    </member>
    <member name="M:devDept.Geometry.IntegerGrid.ScaleToWorld(System.Int32,System.Int32,System.Double@,System.Double@)">
      <summary>
            Gets real coordinates from integer grid values.
            </summary>
      <param name="gridX">The scaled integer x value</param>
      <param name="gridY">The scaled integer y value</param>
      <param name="x">The resulting x real coordinate</param>
      <param name="y">The resulting y real coordinate to scale</param>
    </member>
    <member name="M:devDept.Geometry.IntegerGrid.ScaleToWorld(System.Int64,System.Int64,System.Double@,System.Double@)">
      <summary>
            Gets real coordinates from integer grid values.
            </summary>
      <param name="gridX">The scaled integer x value</param>
      <param name="gridY">The scaled integer y value</param>
      <param name="x">The resulting x real coordinate</param>
      <param name="y">The resulting y real coordinate to scale</param>
    </member>
    <member name="T:devDept.Geometry.InterPoint">
      <summary>
            Intersection point definition.
            </summary>
    </member>
    <member name="F:devDept.Geometry.InterPoint.IsTangent">
      <summary>
            When true, the intersection is a tangent one.
            </summary>
    </member>
    <member name="M:devDept.Geometry.InterPoint.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Standard constructor
            </summary>
      <param name="x">X coordinate value</param>
      <param name="y">Y coordinate value</param>
      <param name="z">Z coordinate value</param>
      <param name="u">First gSurface parametric U coordinate value</param>
      <param name="v">First gSurface parametric V coordinate value</param>
      <param name="s">Second gSurface parametric U coordinate value</param>
      <param name="t">Second gSurface parametric V coordinate value</param>
    </member>
    <member name="M:devDept.Geometry.InterPoint.Clone">
      <summary>
            Creates a deep copy of this intersection point.
            </summary>
      <returns>The new intersection point object.</returns>
    </member>
    <member name="M:devDept.Geometry.InterPoint.ToString">
      <summary>
            Converts this 3D point to a human readable string.
            </summary>
      <returns>A string that represents this 3d point.</returns>
    </member>
    <member name="T:devDept.Geometry.InitialPoint">
      <summary>
            Intersection initial point definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.InitialPoint.CurveTangent">
      <summary>
            Gets or set the tangent of the igCurve in GCurve - GSurface intersection.
            </summary>
    </member>
    <member name="M:devDept.Geometry.InitialPoint.Clone">
      <summary>
            Creates a deep copy of this initial point.
            </summary>
      <returns>The new initial point object.</returns>
    </member>
    <member name="M:devDept.Geometry.InitialPoint.ToString">
      <summary>
            Converts this 3D point to a human readable string.
            </summary>
      <returns>A string that represents this 3d point.</returns>
    </member>
    <member name="T:devDept.Geometry.PolyRegion2D">
      <summary>
            Class that performs boolean operations on contours of 2D polygonal region.
            </summary>
      <remarks>The algorithm is more robust than the one used by the GRegion, but it changes the coordinates a little bit.</remarks>
    </member>
    <member name="M:devDept.Geometry.PolyRegion2D.#ctor">
      <summary>
            Empty constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.PolyRegion2D.#ctor(devDept.Geometry.Plane,System.Collections.Generic.IList{System.Collections.Generic.IList{devDept.Geometry.Point3D}})">
      <summary>
            Constructor for 3D profiles.
            </summary>
      <param name="plane">The profile plane</param>
      <param name="contourList">The list of contours points</param>
    </member>
    <member name="M:devDept.Geometry.PolyRegion2D.#ctor(devDept.Geometry.Plane,System.Collections.Generic.IList{System.Collections.Generic.IList{devDept.Geometry.Point3D}},System.Boolean)">
      <summary>
            Construtor for 3D profiles.
            </summary>
      <param name="plane">The profile plane</param>
      <param name="contourList">The list of contours points</param>
      <param name="sortAndOrient">When true, the profiles are properly sorted and oriented.</param>
    </member>
    <member name="M:devDept.Geometry.PolyRegion2D.#ctor(System.Collections.Generic.IList{devDept.Geometry.Polygon2D})">
      <summary>
            Standard constructor.
            </summary>
      <param name="contourList">The list of contours points</param>
    </member>
    <member name="M:devDept.Geometry.PolyRegion2D.#ctor(System.Collections.Generic.IList{devDept.Geometry.Polygon2D},System.Boolean)">
      <summary>
            Standard constructor.
            </summary>
      <param name="contourList">The list of contours points</param>
      <param name="sortAndOrient">When true, the profiles are properly sorted and oriented.</param>
    </member>
    <member name="M:devDept.Geometry.PolyRegion2D.FromRegion(devDept.Geometry.Entities.GRegion,devDept.Geometry.Plane,System.Double)">
      <summary>
            Creates a PolyRegion2D object from a GRegion.
            </summary>
      <param name="region">The region</param>
      <param name="plane">The plane on which the region profiles will be projected</param>
      <param name="deviation">The maximum deviation</param>
      <returns>The PolyRegion2D object.</returns>
    </member>
    <member name="M:devDept.Geometry.PolyRegion2D.UpdateBoundingRect">
      <summary>
            Update/initialize the min and max 2D points for each contour polygon.
            </summary>
    </member>
    <member name="M:devDept.Geometry.PolyRegion2D.ToRegion(devDept.Geometry.Plane)">
      <summary>
            Creates a GRegion object from the current PolyRegion2D object.
            </summary>
      <param name="plane">The plane of the GRegion</param>
      <returns>The GRegion object.</returns>
    </member>
    <member name="M:devDept.Geometry.PolyRegion2D.Union(devDept.Geometry.PolyRegion2D,devDept.Geometry.PolyRegion2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            Boolean union between two PolyRegion2D.
            </summary>
      <remarks>The domain min and max parameters may be useful for execute a sequence of operations.</remarks>
      <param name="a">First operand</param>
      <param name="b">Second operand</param>
      <param name="domainMin">The minimum point of the domain bounding rectangle, null for automatic estimation.</param>
      <param name="domaniMax">The maximum point of the domain bounding rectangle, null for automatic estimation.</param>
      <returns>An array of PolyRegion2D objects.</returns>
    </member>
    <member name="M:devDept.Geometry.PolyRegion2D.Intersection(devDept.Geometry.PolyRegion2D,devDept.Geometry.PolyRegion2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            Boolean intersection between two PolyRegion2D.
            </summary>
      <remarks>The domain min and max parameters may be useful for execute a sequence of operations.</remarks>
      <param name="a">First operand</param>
      <param name="b">Second operand</param>
      <param name="domainMin">The minimum point of the domain bounding rectangle, null for automatic estimation.</param>
      <param name="domaniMax">The maximum point of the domain bounding rectangle, null for automatic estimation.</param>
      <returns>An array of PolyRegion2D objects.</returns>
    </member>
    <member name="M:devDept.Geometry.PolyRegion2D.Difference(devDept.Geometry.PolyRegion2D,devDept.Geometry.PolyRegion2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            Boolean difference between two PolyRegion2D.
            </summary>
      <remarks>The domain min and max parameters may be useful for execute a sequence of operations.</remarks>
      <param name="a">First operand</param>
      <param name="b">Second operand</param>
      <param name="domainMin">The minimum point of the domain bounding rectangle, null for automatic estimation.</param>
      <param name="domaniMax">The maximum point of the domain bounding rectangle, null for automatic estimation.</param>
      <returns>An array of PolyRegion2D objects.</returns>
    </member>
    <member name="M:devDept.Geometry.PolyRegion2D.IsPointInside(devDept.Geometry.Point2D)">
      <summary>
            Check if the specified point is inside the PolyRegion2D.
            </summary>
      <param name="point">The 2D point</param>
      <returns>True if the given point is inside the PolyRegion2D, false otherwise.</returns>
      <remarks>Takes for granted that the first (index = 0) polygon is the outer one.</remarks>
      <seealso cref="!:SortAndOrient()" />
    </member>
    <member name="M:devDept.Geometry.PolyRegion2D.IsPolygonInside(devDept.Geometry.Polygon2D)">
      <summary>
            Check if the specified 2D polygon is inside the PolyRegion2D.
            </summary>
      <param name="poly">The 2D polygon</param>
      <returns>True if the given 2D polygon is inside the PolyRegion2D, false otherwise.</returns>
      <seealso cref="!:SortAndOrient()" />
    </member>
    <member name="M:devDept.Geometry.PolyRegion2D.IsPolygonOutside(devDept.Geometry.Polygon2D)">
      <summary>
            Check if the specified 2D polygon is outside the PolyRegion2D.
            </summary>
      <param name="poly">The 2D polygon</param>
      <returns>True if the given 2D polygon is outside the PolyRegion2D, false otherwise.</returns>
      <seealso cref="!:SortAndOrient()" />
    </member>
    <member name="M:devDept.Geometry.PolyRegion2D.IsPointInside(devDept.Geometry.Point2D,System.Double)">
      <summary>
            Check if the specified point is inside or onto the PolyRegion2D.
            </summary>
      <param name="point">The 2D point</param>
      <param name="domainSize">The problem size, like the biggest diagonal that contains the polygonal region.</param>
      <returns>True if the given point is inside or onto the PolyRegion2D, false otherwise.</returns>
      <remarks>Takes for granted that the first (index = 0) polygon is the outer one.</remarks>
      <seealso cref="!:SortAndOrient()" />
    </member>
    <member name="T:devDept.Geometry.Utility">
      <summary>
            Contains a collection of utility methods and constants for internal use.
            </summary>
      <summary>
            Contains a collection of utility methods and constants.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Utility.IntersectionLineLine(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.IGCurve,devDept.Geometry.Plane,devDept.Geometry.Point3D@)">
      <summary>
            Finds the intersection between two coplanar GLine entities
            </summary>
      <param name="line1">The first line entity</param>
      <param name="line2">The second line entity</param>
      <param name="pln">The plane where the two entities lay</param>
      <param name="i0">The intersection point (when it exists)</param>
      <returns>True if the intersection is found and inside to both the lines, false when the two entities don't touch.</returns>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionCircleCircle(devDept.Geometry.Entities.GCircle,devDept.Geometry.Entities.GCircle,devDept.Geometry.Plane,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionCircleCircle Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionCircleCircle3D(devDept.Geometry.Entities.GCircle,devDept.Geometry.Entities.GCircle,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionCircleCircle3D Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionLineCircle(devDept.Geometry.Entities.GLine,devDept.Geometry.Entities.GCircle,devDept.Geometry.Plane,System.Boolean,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionLineCircle Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionLineCircle3D(devDept.Geometry.Entities.GLine,devDept.Geometry.Entities.GCircle,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionLineCircle3D Method</seealso>
      <seealso cref="!:GCurve.Intersection(IGCurve, IGCurve)">GCurve.Intersection(IGCurve, IGCurve) Method</seealso>
      <seealso cref="!:GCurve.Intersection(IGCurve, IGCurve, double)">GCurve.Intersection(IGCurve, IGCurve, double) Method</seealso>
      <seealso cref="!:GCurve.Intersection2D(IGCurve, IGCurve, Plane)">GCurve.Intersection2D Method</seealso>
      <seealso cref="M:devDept.Geometry.Entities.IGCurve.IntersectWith(devDept.Geometry.Entities.IGCurve,System.Boolean)">IGCurve.IntersectWith Method</seealso>
    </member>
    <member name="M:devDept.Geometry.Utility.IntersectionLineLine(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.IGCurve,devDept.Geometry.Point3D@)">
      <summary>
            Finds the intersection between two GLine entities
            </summary>
      <param name="line1">The first line entity</param>
      <param name="line2">The second line entity</param>
      <param name="i0">The intersection point (when it exists)</param>
      <returns>True if the intersection is found, false when the two entities don't touch.</returns>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionCircleCircle(devDept.Geometry.Entities.GCircle,devDept.Geometry.Entities.GCircle,devDept.Geometry.Plane,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionCircleCircle Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionCircleCircle3D(devDept.Geometry.Entities.GCircle,devDept.Geometry.Entities.GCircle,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionCircleCircle3D Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionLineCircle(devDept.Geometry.Entities.GLine,devDept.Geometry.Entities.GCircle,devDept.Geometry.Plane,System.Boolean,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionLineCircle Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionLineCircle3D(devDept.Geometry.Entities.GLine,devDept.Geometry.Entities.GCircle,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionLineCircle3D Method</seealso>
      <seealso cref="!:GCurve.Intersection(IGCurve, IGCurve)">GCurve.Intersection(IGCurve, IGCurve) Method</seealso>
      <seealso cref="!:GCurve.Intersection(IGCurve, IGCurve, double)">GCurve.Intersection(IGCurve, IGCurve, double) Method</seealso>
      <seealso cref="!:GCurve.Intersection2D(IGCurve, IGCurve, Plane)">GCurve.Intersection2D Method</seealso>
      <seealso cref="M:devDept.Geometry.Entities.IGCurve.IntersectWith(devDept.Geometry.Entities.IGCurve,System.Boolean)">IGCurve.IntersectWith Method</seealso>
    </member>
    <member name="M:devDept.Geometry.Utility.IntersectionLineCircle(devDept.Geometry.Entities.GLine,devDept.Geometry.Entities.GCircle,devDept.Geometry.Plane,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">
      <summary>
            Finds the intersection between an GArc/GCircle and a GLine entity.
            </summary>
      <param name="line">The line entity</param>
      <param name="arc">The arc/circle entity</param>
      <param name="pln">The plane where the two entities lay</param>
      <param name="i0">The first intersection point (when it exists)</param>
      <param name="i1">The second intersection point (when it exists)</param>
      <returns>True if the intersection is found, false when the two entities don't touch.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.IntersectionLineCircle(devDept.Geometry.Entities.GLine,devDept.Geometry.Entities.GCircle,devDept.Geometry.Plane,System.Boolean,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">
      <summary>
            Finds the intersection between an GArc/GCircle and a GLine entity.
            </summary>
      <param name="line">The line entity</param>
      <param name="arc">The arc/circle entity</param>
      <param name="pln">The plane where the two entities lay</param>
      <param name="infiniteLine">If true, we look for intersections even outside the boundaries of the line.</param>
      <param name="i0">The first intersection point (when it exists)</param>
      <param name="i1">The second intersection point (when it exists)</param>
      <returns>True if the intersection is found, false when the two entities don't touch.</returns>
      <seealso cref="!:GCompositeCurve.IntersectionLineCircle3D(GLine, GCircle, out Point3D, out Point3D)">GCompositeCurve.IntersectionLineCircle3D Method</seealso>
      <seealso cref="!:GCompositeCurve.IntersectionLineLine(IGCurve, IGCurve, out Point3D)">GCompositeCurve.IntersectionLineLine Method</seealso>
      <seealso cref="!:GCompositeCurve.IntersectionCircleCircle(GCircle, GCircle, Plane, out Point3D, out Point3D)">GCompositeCurve.IntersectionCircleCircle Method</seealso>
      <seealso cref="!:GCompositeCurve.IntersectionCircleCircle3D(GCircle, GCircle, out Point3D, out Point3D)">GCompositeCurve.IntersectionCircleCircle3D Method</seealso>
      <seealso cref="!:GCurve.Intersection(IGCurve, IGCurve)">GCurve.Intersection(IGCurve, IGCurve) Method</seealso>
      <seealso cref="!:GCurve.Intersection(IGCurve, IGCurve, double)">GCurve.Intersection(IGCurve, IGCurve, double) Method</seealso>
      <seealso cref="!:GCurve.Intersection2D(IGCurve, IGCurve, Plane)">GCurve.Intersection2D Method</seealso>
      <seealso cref="M:devDept.Geometry.Entities.IGCurve.IntersectWith(devDept.Geometry.Entities.IGCurve,System.Boolean)">IGCurve.IntersectWith Method</seealso>
    </member>
    <member name="M:devDept.Geometry.Utility.IntersectionLineCircle3D(devDept.Geometry.Entities.GLine,devDept.Geometry.Entities.GCircle,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">
      <summary>
            Finds the intersection between an GArc/GCircle and a GLine entity.
            </summary>
      <param name="line">The line entity</param>
      <param name="circ">The arc/circle entity</param>
      <param name="i0">The first intersection point (when it exists)</param>
      <param name="i1">The second intersection point (when it exists)</param>
      <returns>True if the intersection is found, false when the two entities don't touch.</returns>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionLineCircle(devDept.Geometry.Entities.GLine,devDept.Geometry.Entities.GCircle,devDept.Geometry.Plane,System.Boolean,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionLineCircle Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionLineLine(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.IGCurve,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionLineLine Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionCircleCircle(devDept.Geometry.Entities.GCircle,devDept.Geometry.Entities.GCircle,devDept.Geometry.Plane,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionCircleCircle Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionCircleCircle3D(devDept.Geometry.Entities.GCircle,devDept.Geometry.Entities.GCircle,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionCircleCircle3D Method</seealso>
      <seealso cref="!:GCurve.Intersection(IGCurve, IGCurve)">GCurve.Intersection(IGCurve, IGCurve) Method</seealso>
      <seealso cref="!:GCurve.Intersection(IGCurve, IGCurve, double)">GCurve.Intersection(IGCurve, IGCurve, double) Method</seealso>
      <seealso cref="!:GCurve.Intersection2D(IGCurve, IGCurve, Plane)">GCurve.Intersection2D Method</seealso>
      <seealso cref="M:devDept.Geometry.Entities.IGCurve.IntersectWith(devDept.Geometry.Entities.IGCurve,System.Boolean)">IGCurve.IntersectWith Method</seealso>
    </member>
    <member name="M:devDept.Geometry.Utility.IntersectionCircleCircle(devDept.Geometry.Entities.GCircle,devDept.Geometry.Entities.GCircle,devDept.Geometry.Plane,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">
      <summary>
            Finds the intersection between two GArc/GCircle entities.
            </summary>
      <param name="arc1">The first arc/circle entity</param>
      <param name="arc2">The second arc/circle entity</param>
      <param name="pln">The plane where the two entities lay</param>
      <param name="i0">The first intersection point (when it exists)</param>
      <param name="i1">The second intersection point (when it exists)</param>
      <returns>True if the intersection is found, false when the two entities don't touch.</returns>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionCircleCircle3D(devDept.Geometry.Entities.GCircle,devDept.Geometry.Entities.GCircle,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionCircleCircle3D Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionLineLine(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.IGCurve,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionLineLine Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionLineCircle(devDept.Geometry.Entities.GLine,devDept.Geometry.Entities.GCircle,devDept.Geometry.Plane,System.Boolean,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionLineCircle Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionLineCircle3D(devDept.Geometry.Entities.GLine,devDept.Geometry.Entities.GCircle,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionLineCircle3D Method</seealso>
      <seealso cref="!:GCurve.Intersection(IGCurve, IGCurve)">GCurve.Intersection(IGCurve, IGCurve) Method</seealso>
      <seealso cref="!:GCurve.Intersection(IGCurve, IGCurve, double)">GCurve.Intersection(IGCurve, IGCurve, double) Method</seealso>
      <seealso cref="!:GCurve.Intersection2D(IGCurve, IGCurve, Plane)">GCurve.Intersection2D Method</seealso>
      <seealso cref="M:devDept.Geometry.Entities.IGCurve.IntersectWith(devDept.Geometry.Entities.IGCurve,System.Boolean)">IGCurve.IntersectWith Method</seealso>
    </member>
    <member name="M:devDept.Geometry.Utility.IntersectionCircleCircle3D(devDept.Geometry.Entities.GCircle,devDept.Geometry.Entities.GCircle,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">
      <summary>
            Finds the intersection between two GArc/GCircle entities.
            </summary>
      <param name="arc1">The first arc/circle entity</param>
      <param name="arc2">The second arc/circle entity</param>
      <param name="i0">The first intersection point (when it exists)</param>
      <param name="i1">The second intersection point (when it exists)</param>
      <returns>True if the intersection is found, false when the two entities don't touch.</returns>
      <seealso cref="!:GCompositeCurve.IntersectionCircleCircle(GCircle, GCircle, Plane, out Point3D, out Point3D)">GCompositeCurve.IntersectionCircleCircle Method</seealso>
      <seealso cref="!:GCompositeCurve.IntersectionLineLine(IGCurve, IGCurve, out Point3D)">GCompositeCurve.IntersectionLineLine Method</seealso>
      <seealso cref="!:GCompositeCurve.IntersectionLineCircle(GLine, GCircle, Plane, bool, out Point3D, out Point3D)">GCompositeCurve.IntersectionLineCircle Method</seealso>
      <seealso cref="!:GCompositeCurve.IntersectionLineCircle3D(GLine, GCircle, out Point3D, out Point3D)">GCompositeCurve.IntersectionLineCircle3D Method</seealso>
      <seealso cref="!:GCurve.Intersection(IGCurve, IGCurve)">GCurve.Intersection(IGCurve, IGCurve) Method</seealso>
      <seealso cref="!:GCurve.Intersection(IGCurve, IGCurve, double)">GCurve.Intersection(IGCurve, IGCurve, double) Method</seealso>
      <seealso cref="!:GCurve.Intersection2D(IGCurve, IGCurve, Plane)">GCurve.Intersection2D Method</seealso>
      <seealso cref="M:devDept.Geometry.Entities.IGCurve.IntersectWith(devDept.Geometry.Entities.IGCurve,System.Boolean)">IGCurve.IntersectWith Method</seealso>
    </member>
    <member name="M:devDept.Geometry.Utility.Intersection2D(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.IGCurve,devDept.Geometry.Plane)">
      <summary>
            Finds all 3D points where the provided coplanar igCurves intersect.
            </summary>
      <returns>The list of intersection points.</returns>
      <param name="C1">The first igCurve</param>
      <param name="C2">The second igCurve</param>
      <param name="plane">The plane where the two igCurves lay</param>
      <remarks>For PROFESSIONAL edition, this method doesn't work for Ellipses, Elliptical Arcs and GCompositeIgCurve containing Ellipses or Elliptical Arcs.</remarks>
    </member>
    <member name="M:devDept.Geometry.Utility.Intersection(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.IGCurve,System.Boolean)">
      <summary>
            Finds all 3D points where the provided curves intersect.
            </summary>
      <returns>The list of intersection points.</returns>
      <param name="C1">The first curve</param>
      <param name="C2">The second curve</param>
      <param name="computeParameters">When true intersection points array is filled with InterPoints. False, for a quick computation without curves' paramters data.</param>
      <seealso cref="M:devDept.Geometry.Utility.Intersection(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.IGCurve,System.Double)">GCurve.Intersection(ICurve, ICurve, double) Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.Intersection2D(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.IGCurve,devDept.Geometry.Plane)">GCurve.Intersection2D Method</seealso>
      <seealso cref="M:devDept.Geometry.Entities.IGCurve.IntersectWith(devDept.Geometry.Entities.IGCurve,System.Boolean)">ICurve.IntersectWith Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionLineLine(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.IGCurve,devDept.Geometry.Point3D@)">CompositeCurve.IntersectionLineLine Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionCircleCircle(devDept.Geometry.Entities.GCircle,devDept.Geometry.Entities.GCircle,devDept.Geometry.Plane,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">CompositeCurve.IntersectionCircleCircle Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionCircleCircle3D(devDept.Geometry.Entities.GCircle,devDept.Geometry.Entities.GCircle,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">CompositeCurve.IntersectionCircleCircle3D Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionLineCircle(devDept.Geometry.Entities.GLine,devDept.Geometry.Entities.GCircle,devDept.Geometry.Plane,System.Boolean,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">CompositeCurve.IntersectionLineCircle Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionLineCircle3D(devDept.Geometry.Entities.GLine,devDept.Geometry.Entities.GCircle,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">CompositeCurve.IntersectionLineCircle3D Method</seealso>
    </member>
    <member name="M:devDept.Geometry.Utility.Intersection(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.IGCurve,System.Double)">
      <summary>
            Finds all 3D points where the provided curves intersect within the specified gap.
            </summary>
      <returns>The list of intersection points.</returns>
      <param name="C1">The first curve</param>
      <param name="C2">The second curve</param>
      <param name="maxGap">Maximum distance between curves</param>
      <seealso cref="M:devDept.Geometry.Utility.Intersection(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.IGCurve,System.Boolean)">GCurve.Intersection(IGCurve, IGCurve) Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.Intersection2D(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.IGCurve,devDept.Geometry.Plane)">GCurve.Intersection2D Method</seealso>
      <seealso cref="M:devDept.Geometry.Entities.IGCurve.IntersectWith(devDept.Geometry.Entities.IGCurve,System.Boolean)">IGCurve.IntersectWith Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionLineLine(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Entities.IGCurve,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionLineLine Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionCircleCircle(devDept.Geometry.Entities.GCircle,devDept.Geometry.Entities.GCircle,devDept.Geometry.Plane,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionCircleCircle Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionCircleCircle3D(devDept.Geometry.Entities.GCircle,devDept.Geometry.Entities.GCircle,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionCircleCircle3D Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionLineCircle(devDept.Geometry.Entities.GLine,devDept.Geometry.Entities.GCircle,devDept.Geometry.Plane,System.Boolean,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionLineCircle Method</seealso>
      <seealso cref="M:devDept.Geometry.Utility.IntersectionLineCircle3D(devDept.Geometry.Entities.GLine,devDept.Geometry.Entities.GCircle,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">GCompositeCurve.IntersectionLineCircle3D Method</seealso>
    </member>
    <member name="M:devDept.Geometry.Utility.GetMaxGap(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Boolean)">
      <summary>
            Computes the maximum gap between igCurve segments.Assumes sorted and oriented segments.
            </summary>
      <param name="segments">The list of igCurve segments</param>
      <param name="closed">When true, we need to check gap between end and start segments as well.</param>
      <returns>The maximum gap between igCurve segments.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.SmartAdd(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Boolean)">
      <summary>
            Returns a GCompositeCurve if the number of igCurves is bigger than one.
            </summary>
      <param name="curveList">The list of igCurves</param>
      <param name="sortAndOrient">When true, the igCurves are properly sorted and oriented.</param>
      <returns>The igCurve itself or a GCompositeCurve if the igCurve number is bigger than one.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetCpuCount(System.Int32,System.Int32[]@,System.Int32[]@)">
      <summary>
            Gets the number of logical processors.
            </summary>
      <param name="len">Total number of the items to process</param>
      <param name="startIndex">Array of start indices</param>
      <param name="endIndex">Array of end indices</param>
      <returns>The number of logical processors</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.FlipTriangles(System.Collections.Generic.IList{devDept.Geometry.IndexTriangle})">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Utility.RotationMinimizingFrames(devDept.Geometry.Plane,devDept.Geometry.Point3D[],devDept.Geometry.Vector3D[])">
      <summary>
            Computes a set of planes along the igCurve that are perpendicular to the igCurve and are oriented in a way that avoids abrupt changes in the directions of the X and Y axes.
            </summary>
      <param name="prevFrame">The plane at the beginning of the igCurve. It can be null</param>
      <param name="x">The array of points along the igCurve where the planes will be computed</param>
      <param name="t">The array of tangents at each point</param>
      <returns>The array of planes.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.SortAndOrient(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve})">
      <summary>
            Chains curves using the minimum distance between individual curve ends.
            </summary>
      <param name="curveList">The list of curves</param>
      <remarks>The curves are not cloned</remarks>
    </member>
    <member name="M:devDept.Geometry.Utility.SortAndOrient(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Double)">
      <summary>
            Chains curves using the minimum distance between individual igCurve ends keeping the first curve first.
            </summary>
      <param name="curveList">The list of curves</param>
      <param name="closureTol">The max distance between the contour start and end points to assume the curve as closed.</param>
      <remarks>The curves are not cloned</remarks>
    </member>
    <member name="M:devDept.Geometry.Utility.SortAndOrient(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Boolean,System.Double)">
      <summary>
            Chains curves using the minimum distance between individual curve ends keeping the first igCurve first.
            </summary>
      <param name="curveList">The list of curves</param>
      <param name="assumeClosed">In case you already know that the contour is/has to be closed.</param>
      <param name="closureTol">Use zero if you know that the contour is/has to be closed</param>
      <remarks>The curves are not cloned</remarks>
    </member>
    <member name="M:devDept.Geometry.Utility.FixLoopEdgeOrderAndOrientation(devDept.Geometry.Entities.GBrep)">
      <summary>
            For internal use only. Loops over every face's loop and check edge order and orientation. If inconsistent we rebuild it correctly.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Utility.FixLoopNestingOrder(devDept.Geometry.Entities.GBrep,System.Double)">
      <summary>
            For internal use only. Loops over every face's loop and check edge order and orientation. If inconsistent we rebuild it correctly.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Utility.SplitEdgeOnSurfaceSeams(devDept.Geometry.Entities.GBrep)">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Utility.GetConnectedCurves(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Double)">
      <summary>
            Groups the igCurves that are connected into CompositeCurves. 
            </summary>
      <param name="unsorted">The list of igCurves</param>
      <param name="gap">The distance necessary to consider two igCurves disconnected</param>
      <remarks>Two igCurves are considered connected if the distance between their endpoints is smaller than gap.</remarks>
    </member>
    <member name="M:devDept.Geometry.Utility.DetectRegionsFromContours(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Double,devDept.Geometry.Plane)">
      <summary>
            Creates an array of Regions from the igCurves list, automatically detecting inner and outer contours.
            </summary>
      <param name="contours"> The list of igCurves</param>
      <param name="deviation">The regeneration tolerance</param>
      <param name="plane">The plane used to create the regions</param>
      <returns>The resulting GRegion array.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.DetectRegionsFromContours(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve})">
      <summary>
            For internal use only. The results can be regions with contours orientation flipped.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Utility.FindClosestTriangle(devDept.Geometry.Transformation,devDept.Geometry.Segment3D,System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{devDept.Geometry.IndexTriangle})">
      <summary>
            Finds the triangles intersecting the <paramref name="seg" /> segment and puts them in the <paramref name="triList" />.
            </summary>
      <param name="transf">The transformation applied to the segment (inverse transformation) and to the resulting points (original transformation)</param>
      <param name="seg">The segment to intersect</param>
      <param name="vertices">The vertices collection</param>
      <param name="triangles">The triangles collection</param>
      <param name="faceIndex">The face index (<see cref="T:devDept.Geometry.Entities.GBrep" /> only)</param>
      <param name="shellIndex">The shell index (<see cref="T:devDept.Geometry.Entities.GBrep" /> only)</param>
      <param name="triList">The list of intersecting triangles, sorted by the distance of the intersection point from the first point of <paramref name="seg" /></param>
    </member>
    <member name="M:devDept.Geometry.Utility.GetOuterIndex(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Double)">
      <summary>
            Returns the outer contour index.
            </summary>
      <param name="loops">The list of 2D contours</param>
      <param name="tolerance">The tolerance used to tessellate contours</param>
      <returns>The outer loop index</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetOuterIndex(System.Collections.Generic.IList{System.Collections.Generic.IList{devDept.Geometry.Point2D}})">
      <summary>
            Returns the outer loop index.
            </summary>
      <param name="loops">The list of 2D contours</param>
      <returns>The outer loop index, -1 if the loops aren't nested.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetOuterIndex(System.Collections.Generic.IList{devDept.Geometry.Polygon2D})">
      <summary>
            Returns the outer contour index.
            </summary>
      <param name="loops">The list of 2D contours</param>
      <returns>The outer loop index</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.CreateCone(devDept.Geometry.Entities.GMesh.natureType,System.Double,System.Double,System.Double,System.Int32,System.Boolean,System.Int32@,System.Int32@,devDept.Geometry.Point3D[]@,devDept.Geometry.IndexTriangle[]@,devDept.Geometry.Vector3D[]@)">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Utility.CreateTriangle(devDept.Geometry.Entities.GMesh.natureType,System.Int32,System.Int32,System.Int32)">
      <summary>
            Create a triangle according to the <see cref="!:meshNature" />.
            </summary>
      <param name="meshNature">Nature of the mesh</param>
      <param name="v1">Index of the first triangle vertex</param>
      <param name="v2">Index of the second triangle vertex</param>
      <param name="v3">Index of the third triangle vertex</param>
      <returns>The created triangle.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.CreateTriangle(devDept.Geometry.Entities.GMesh.natureType,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Create a triangle according to the <see cref="!:meshNature" />.
            </summary>
      <param name="meshNature">Nature of the mesh</param>
      <param name="v1">Index of the first triangle vertex</param>
      <param name="v2">Index of the second triangle vertex</param>
      <param name="v3">Index of the third triangle vertex</param>
      <param name="n1">Index of the first vertex normal</param>
      <param name="n2">Index of the second vertex normal</param>
      <param name="n3">Index of the third vertex normal</param>
      <returns>The created triangle.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.CreateTriangle(devDept.Geometry.Entities.GMesh.natureType,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Create a triangle according to the <see cref="!:meshNature" />.
            </summary>
      <param name="meshNature">Nature of the mesh</param>
      <param name="v1">Index of the first triangle vertex</param>
      <param name="v2">Index of the second triangle vertex</param>
      <param name="v3">Index of the third triangle vertex</param>
      <param name="n1">Index of the first vertex normal</param>
      <param name="n2">Index of the second vertex normal</param>
      <param name="n3">Index of the third vertex normal</param>
      <param name="t1">Index of the first vertex texture</param>
      <param name="t2">Index of the second vertex texture</param>
      <param name="t3">Index of the third vertex texture</param>
      <returns>The created triangle.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.CreateVertex(devDept.Geometry.Entities.GMesh.natureType,System.Double,System.Double,System.Double)">
      <summary>
            Create a vertex according to the <see cref="!:meshNature" />.
            </summary>
      <param name="meshNature">Nature of the mesh</param>
      <param name="x">X coordinate value</param>
      <param name="y">Y coordinate value</param>
      <param name="z">Z coordinate value</param>
      <returns>The created vertex.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.CreateSphere(devDept.Geometry.Entities.GMesh.natureType,System.Double,System.Int32,System.Int32,System.Boolean,System.Boolean,devDept.Geometry.Point3D[]@,devDept.Geometry.IndexTriangle[]@,devDept.Geometry.Vector3D[]@,devDept.Geometry.PointF[]@)">
      <summary>
            For internal use only.
            </summary>
    </member>
    <!-- Badly formed XML comment ignored for member "M:devDept.Geometry.Utility.NeedToFlipTrianglesForExtrusion(System.Collections.Generic.IList{devDept.Geometry.IndexTriangle},System.Collections.Generic.IList{devDept.Geometry.Point3D},devDept.Geometry.Vector3D)" -->
    <member name="M:devDept.Geometry.Utility.ConvexHull(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Double,System.Boolean,System.Boolean)">
      <summary>
            Computes the Convex Hull of a set of 3D points.
            </summary>
      <param name="points">The 3D point array</param>
      <param name="domainSize">The 3D diagonal length of the input set, zero for automatic estimation.</param>
      <returns>The resulting Mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.ConvexHull(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Double,devDept.Geometry.Point3D[]@,devDept.Geometry.IndexTriangle[]@,System.Boolean,System.Boolean)">
      <summary>
             Computes the Convex Hull of a set of 3D points.
            </summary>
      <param name="points">The 3D point list</param>
      <param name="domainSize">The 3D diagonal length of the input set</param>
      <param name="iVertices">The resulting 3D point vertices array.</param>
      <param name="iTriangles">The resulting IndexTriangle array.</param>
      <param name="getFaces">
      </param>
      <param name="fixNormals">
      </param>
    </member>
    <member name="M:devDept.Geometry.Utility.ConvexHull(System.Collections.Generic.IList{System.Single},System.Double)">
      <summary>
            Computes the Convex Hull of a set of 3D points.
            </summary>
      <param name="pointsCoords">The 3D points coordinates defined as XYZ tuples</param>
      <param name="domainSize">The 3D diagonal length of the input set</param>
      <returns>The array of the minimum unordered points coordinates defining the Convex Hull.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.ConvexHull2D(System.Collections.Generic.IList{devDept.Geometry.Point2D})">
      <summary>
            Computes the Convex Hull of a set of 2D points.
            </summary>
      <param name="points">The 2D point list</param>
      <returns>The resulting GLinearPath object.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.ConvexHull2D(System.Collections.Generic.IList{devDept.Geometry.Point2D},System.Boolean)">
      <summary>
            Computes the Convex Hull of a set of 2D points.
            </summary>
      <param name="points">The 2D point list</param>
      <param name="sorted">When true, the resulting array of points is sorted.</param>
      <returns>The resulting array of 2D points.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.ConvexHull2D(System.Collections.Generic.IList{System.Single})">
      <summary>
            Computes the 2D Convex Hull on XY plane of a set of 3D points.
            </summary>
      <param name="pointsCoords">The 3D points coordinates defined as XYZ tuples</param>
      <returns>The array of the minimum unordered points coordinates defining the 2D Convex Hull.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.IsLine(devDept.Geometry.Entities.IGCurve)">
      <summary>
            Checks if the igCurve is a gLine or a linear nurbs segment (Nurbs and Ultimate editions only).
            </summary>
      <param name="itfIgCurve">The igCurve to be checked</param>
      <returns>True if the igCurve is a <see cref="T:devDept.Geometry.Entities.GLine" /> or a Nurbs igCurve with two control points and degree one</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.RotateAwayFromSeam(devDept.Geometry.Plane,System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},devDept.Geometry.Entities.GSurface,System.Double@)">
      <summary>
            For internal use only.Attempts to rotate the gSurface three times to avoid proximity/ovelap with seam plane.
            </summary>
      <param name="rs">The revolved gSurface</param>
      <param name="trimLoops">The trim loops</param>
      <param name="angle">The rotation angle</param>
            TODO Geo TRS
        </member>
    <member name="M:devDept.Geometry.Utility.Triangulate(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{System.Collections.Generic.IList{devDept.Geometry.Point3D}},System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{devDept.Geometry.Segment3D})">
      <summary>
            Triangulates a set of contours/points.
            </summary>
      <param name="outerLoop">Outer contour</param>
      <param name="innerLoops">A list of inner contours (holes), can be null/Nothing.</param>
      <param name="points">The list of Steiner points, can be null/Nothing.</param>
      <param name="segments">The internal constraint segments, can be null/Nothing.</param>
      <returns>The resulting Mesh, null/Nothing in case of failure.</returns>
      <remarks>
            Please note that this method ignores the points Z coordinates. The provided contours
            should be planar and lie on the XY plane.
            </remarks>
    </member>
    <member name="M:devDept.Geometry.Utility.Triangulate(System.Collections.Generic.IList{devDept.Geometry.Point2D},System.Collections.Generic.IList{System.Collections.Generic.IList{devDept.Geometry.Point2D}},System.Boolean,devDept.Geometry.Point2D[]@,devDept.Geometry.IndexTriangle[]@)">
      <summary>
            Triangulates a set of contours.
            </summary>
      <param name="outerLoop">Outer contour</param>
      <param name="innerLoops">A list of inner contours, can be null/Nothing.</param>
      <param name="checkDir">When true, the contour orientation is fixed automatically.</param>
      <param name="vertices">The resulting triangulation 2D vertices</param>
      <param name="triangles">The resulting triangulation triangles</param>
      <returns>True if the operation succeeds, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.Triangulate(devDept.Geometry.Entities.GRegion,System.Double,System.Int32)">
      <summary>
            Triangulates (meshes) the specified GRegion.
            </summary>
      <param name="region">The region to be meshed</param>
      <param name="elementSize">The desired element size</param>
      <param name="smoothingPasses">The number of smoothing passes</param>
      <returns>The resulting Mesh object, null/Nothing in case of failure.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.Triangulate(System.Collections.Generic.IList{devDept.Geometry.Point3D},devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Triangulate a collection of 2.5D points (terrain like).
            </summary>
      <param name="points">The 3D point collection</param>
      <param name="nature">The desired Mesh nature. Affects only mesh smoothing.</param>
      <returns>The resulting Mesh, null/nothing in case of failure.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.DoOverlapOrTouch(devDept.Geometry.Entities.GMesh,devDept.Geometry.Entities.GMesh)">
      <summary>
            Checks if two <see cref="T:devDept.Geometry.Entities.GMesh" /> objects intersect each other.
            </summary>
      <param name="first">The first mesh object</param>
      <param name="second">The second mesh object</param>
      <returns>True if the two mesh objects intersect.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.DoOverlapOrTouch(devDept.Geometry.Entities.GMesh,devDept.Geometry.Entities.GMesh,System.Collections.Generic.List{devDept.Geometry.Point3D}@)">
      <summary>
            Checks if two <see cref="T:devDept.Geometry.Entities.GMesh" /> objects intersect each other.
            </summary>
      <param name="first">The first mesh object</param>
      <param name="second">The second mesh object</param>
      <param name="intersectionPoints">The first intersection points found to identify the two objects as intersecting</param>
      <returns>True if the two mesh objects intersect.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.DoOverlap(devDept.Geometry.Entities.GMesh,devDept.Geometry.Entities.GMesh)">
      <summary>
            Checks if two <see cref="T:devDept.Geometry.Entities.GMesh" /> objects intersect each other (but don't touch).
            </summary>
      <param name="first">The first mesh object</param>
      <param name="second">The second mesh object</param>
      <returns>True if the two mesh objects intersect.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.DoOverlapOrTouch(devDept.Geometry.Point3D[],devDept.Geometry.Point3D[],devDept.Geometry.IndexTriangle[],devDept.Geometry.IndexTriangle[],System.Collections.Generic.List{devDept.Geometry.Point3D}@)">
      <summary>
            Checks if two Convex Hull intersect each other.
            </summary>
      <param name="verticesF">3D point array of vertices for the first ConvexHull</param>
      <param name="verticesG">3D point array of vertices for the second ConvexHull</param>
      <param name="trianglesF">IndexTriangle array for the first ConvexHull</param>
      <param name="trianglesG">IndexTriangle array for the second ConvexHull</param>
      <param name="intersectionPoints">The first intersection points found to identify the two objects as intersecting</param>
      <returns>True if the two ConvexHulls intersect each other.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.CleanDuplicates(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve})">
      <summary>
            Cleans duplicated igCurves from a contour.
            </summary>
      <param name="contour">The contour to be checked</param>
    </member>
    <member name="M:devDept.Geometry.Utility.GetSignificantPointsOnICurve(devDept.Geometry.Entities.IGCurve)">
      <summary>
            Selects the first and start point of an IGCurve, the vertices of a GLinearPath, and the startPoints of the segments of a GCompositeIgCurve
            </summary>
      <param name="contour">The contour</param>
    </member>
    <member name="M:devDept.Geometry.Utility.EnrichMesh(devDept.Geometry.Point3D[],devDept.Geometry.IndexTriangle[],devDept.Geometry.Entities.GMesh.natureType,System.Single,System.Single,System.Single,System.Single,System.Int32,System.Boolean)">
      <summary>
            For Internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Utility.RefineLoop(devDept.Geometry.Point2D[])">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Utility.GetLinesTangentToTwoCircles(devDept.Geometry.Entities.GCircle,devDept.Geometry.Entities.GCircle)">
      <summary>
            Computes the segments tangent to two given GCircles or arcs.
            </summary>
      <param name="c1">The first GCircle.</param>
      <param name="c2">The first GCircle.</param>
      <returns>The array of gLines tangent to both GCircles. For arcs, it returns only the gLines that touch them.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetLinesTangentToTwoCircles(devDept.Geometry.Entities.GCircle,devDept.Geometry.Entities.GCircle,devDept.Geometry.Entities.GLine[]@)">
      <summary>
            Computes the segments tangent to two given GCircles.
            </summary>
      <param name="c1">The first GCircle.</param>
      <param name="c2">The second GCircle.</param>
      <param name="tangentArray">Array of length 4 containing the tangent gLines.</param>
      <returns>The number of not null gLines in <paramref name="tangentArray" />.</returns>
      <remarks>For arcs, it returns the same result as for GCircles, for a different result use <see cref="M:devDept.Geometry.Utility.GetLinesTangentToTwoCircles(devDept.Geometry.Entities.GCircle,devDept.Geometry.Entities.GCircle)" />.
            All the gLines start from c1 and end on c2, except for the tangent gLines that are perpendicular to the gLine
            connecting the two centers, we will refer to these tangents as vertical or VERT:
            their length is equal to the diameter of the bigger GCircle and they touch the GCircles at the midPoint.
            The position of the gLines in the array is fixed and dependent from the number of solutions:
            <list type="bullet"><item><description>[0] upper external (or outer),</description></item><item><description>[1] lower external (or outer),</description></item><item><description>[2] upper internal (or inner),</description></item><item><description>[3] lower internal (or inner).</description></item></list>
            To define upper we use the positive direction of the Y axis of the plane with axis Z equal to c1.Plane,
            and axis X given by the direction c1.Center-c2.Center.
            Based on the number of solutions, the possibilities are:
            <list type="bullet"><item><description>0 =&gt; [null, null, null, null]: one GCircle is completely inside the other and they don't intersect,</description></item><item><description>1 =&gt; [null, null, null, VERT]: one GCircle is completely inside the other and they are tangent</description></item><item><description>2 =&gt; [LINE, LINE, null, null]: the GCircles intersect in two different points, there are only the external tangents,</description></item><item><description>3 =&gt; [LINE, LINE, VERT, null]: the GCircles intersect in one point, but they aren't one inside the other,
            there are the external tangents and a vertical tangent,</description></item><item><description>4 =&gt; [LINE, LINE, LINE, LINE]: the GCircles don't intersect and they aren't one inside the other,
            there are the external tangents and the internal tangents.</description></item></list></remarks>
    </member>
    <member name="M:devDept.Geometry.Utility.GetCirclesTangentToTwoCircles(devDept.Geometry.Entities.GCircle,devDept.Geometry.Entities.GCircle,System.Double,System.Boolean,System.Boolean)">
      <summary>
             Computes the GCircles tangent to two given GCircles or arcs.
             </summary>
      <param name="c1">The first GCircle.</param>
      <param name="c2">The second GCircle.</param>
      <param name="radius">The radius of the tangent GCircles</param>
      <param name="trim">If true, it trims the tangent GCircle at the tangent points.</param>
      <param name="flip"> It is significant only when trim is true. If false (default) it returns the shortest part of the tangent GCircle, if true it returns the longest part.</param>
      <returns>The array of GCircles tangent to both GCircles. For arcs, it returns only the GCircles that touch them.
            The StartPoint of the output GCircles lie always on c1. If trim is true, the trimmed arc goes from c1 to c2. 
             </returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetLinesTangentToCircleFromPoint(devDept.Geometry.Entities.GCircle,devDept.Geometry.Point3D,devDept.Geometry.Entities.GLine[]@)">
      <summary>
            Computes the tangent gLines from a point to a GCircle. 
            </summary>
      <param name="c">The GCircle.</param>
      <param name="pt">The point on the GCircle's plane and outside it.</param>
      <param name="tangentSegments"> Array containing the not-null tangent gLines. </param>
      <returns> The number of (not-null) gLines in <paramref name="tangentSegments" /></returns>
      <remarks>
            For arcs, it returns only the gLines that touch them.
            The tangent gLines are directed from the point toward the GCircle. 
            </remarks>
    </member>
    <!-- Badly formed XML comment ignored for member "M:devDept.Geometry.Utility.GetLinesTangentToCircleFromPoint(devDept.Geometry.Entities.GCircle,devDept.Geometry.Point3D)" -->
    <member name="M:devDept.Geometry.Utility.MakeFace(devDept.Geometry.Plane,System.Collections.Generic.IList{System.Int32},System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}},System.Collections.Generic.IList{devDept.Geometry.Point3D})">
      <summary>
            Triangulates the specific region.
            </summary>
      <param name="pln">The projection plane</param>
      <param name="outerLoop">The outer loop</param>
      <param name="innerLoops">The inner loops</param>
      <param name="vertexList">The vertex list</param>
      <returns>The list of triangles needed to cover the region.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.MakeFace(devDept.Geometry.Plane,System.Collections.Generic.IList{System.Collections.Generic.IList{System.Int32}},System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Boolean)">
      <summary>
            Triangulates the specific region.
            </summary>
      <param name="pln">The projection plane</param>
      <param name="loops">The loop list, the outer one is the first (needs to be oriented counterclockwise), the inners are the others (need to be oriented clockwise).</param>
      <param name="vertexList">The vertex list</param>
      <param name="checkForOuter">Check if the outer contour is the first in the list and if not reorders the loop list</param>
      <returns>The list of triangles needed to cover the region.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.FitPlane(System.Collections.Generic.IList{devDept.Geometry.Point3D})">
      <summary>
            Planar fitting of 3D points using orthogonal regression.
            </summary>
      <param name="points">The set of points</param>
      <returns>The plane.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.FitLine(System.Collections.Generic.IList{devDept.Geometry.Point3D},devDept.Geometry.Point3D@,devDept.Geometry.Vector3D@)">
      <summary>
            Linear fitting of 3D points using orthogonal regression.
            </summary>
      <param name="points">List of points to be fitted</param>
      <param name="p">The line origin</param>
      <param name="dir">The line direction</param>
    </member>
    <member name="M:devDept.Geometry.Utility.FitCircle(System.Collections.Generic.IList{devDept.Geometry.Point2D},devDept.Geometry.Plane,devDept.Geometry.Point2D@,System.Double@)">
      <summary>
            Least squares circle fit given a set of 2D points.
            </summary>
      <param name="pts2D">List of 2D points to be fitted</param>
      <param name="plane">Plane of the 2D points</param>
      <param name="center">The center of the circle</param>
      <param name="radius">The radius of the circle</param>
    </member>
    <member name="M:devDept.Geometry.Utility.FitCircle(System.Collections.Generic.IList{devDept.Geometry.Point3D},devDept.Geometry.Plane@,System.Double@)">
      <summary>
            Least squares circle fit given a set of 3D points.
            </summary>
      <param name="pts">List of 3D points to be fitted</param>
      <param name="plane">The plane of the circle, whose origin is the center of the circle</param>
      <param name="radius">The radius of the circle</param>
    </member>
    <member name="M:devDept.Geometry.Utility.BoundingRect(System.Collections.Generic.IList{devDept.Geometry.Point2D},devDept.Geometry.Point2D@,devDept.Geometry.Point2D@)">
      <summary>
            Returns the bounding rectangle of a collection of 2D points.
            </summary>
      <param name="pointList">A collection of 2D points.</param>
      <param name="min">The min 2D point</param>
      <param name="max">The max 2D point</param>
    </member>
    <member name="M:devDept.Geometry.Utility.BoundingRect(System.Collections.Generic.IList{devDept.Geometry.Point},devDept.Geometry.Point@,devDept.Geometry.Point@)">
      <summary>
            Returns the bounding rectangle of a collection of 2D points.
            </summary>
      <param name="pointList">A collection of 2D points.</param>
      <param name="min">The min 2D point</param>
      <param name="max">The max 2D point</param>
    </member>
    <member name="M:devDept.Geometry.Utility.BoundingRectOnPlane(System.Collections.Generic.IList{devDept.Geometry.Point2D},devDept.Geometry.Plane,devDept.Geometry.Point2D@,devDept.Geometry.Point2D@)">
      <summary>
            Returns the bounding rectangle of a collection of 2D points by using a fixed plane orientation.
            </summary>
      <param name="pointList">A collection of 2D points lies on Plane XY.</param>
      <param name="min">The min 2D point on the input plane definition</param>
      <param name="max">The max 2D point on the input plane definition</param>
    </member>
    <member name="M:devDept.Geometry.Utility.BoundingBox(System.Collections.Generic.IList{devDept.Geometry.Point3D},devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">
      <summary>
            Returns the bounding box of a collection of 3D points.
            </summary>
      <param name="pointList">A collection of 3D points.</param>
      <param name="min">The min 3D point</param>
      <param name="max">The max 3D point</param>
    </member>
    <member name="M:devDept.Geometry.Utility.ComputeBoundingBox(devDept.Geometry.Transformation,System.Collections.Generic.IList{devDept.Geometry.Point3D},devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">
      <summary>
            Computes the bounding box of the given array of points.
            </summary>
      <param name="transform">The transformation applied to the points</param>
      <param name="points">The set of points</param>
      <param name="boxMin">The minimum point of the bounding box</param>
      <param name="boxMax">The maximum point of the bounding box</param>
    </member>
    <member name="M:devDept.Geometry.Utility.ComputeBoundingBox``1(devDept.Geometry.Transformation,System.Collections.Generic.IList{``0},System.Int32,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">
      <summary>
            Computes the bounding box of the given array of points.
            </summary>
      <param name="transform">The transformation applied to the points</param>
      <param name="points">The set of points</param>
      <param name="count">Number of points</param>
      <param name="boxMin">The minimum point of the bounding box</param>
      <param name="boxMax">The maximum point of the bounding box</param>
    </member>
    <member name="M:devDept.Geometry.Utility.ComputeBoundingRect(System.Collections.Generic.IList{devDept.Geometry.Point2D},devDept.Geometry.Point2D@,devDept.Geometry.Point2D@)">
      <summary>
            Computes the bounding box of the given array of points.
            </summary>
      <param name="points">The set of points</param>
      <param name="boxMin">The minimum point of the bounding box</param>
      <param name="boxMax">The maximum point of the bounding box</param>
    </member>
    <member name="M:devDept.Geometry.Utility.ComputeBoundingRect(System.Double[0:,0:],devDept.Geometry.Point2D@,devDept.Geometry.Point2D@)">
      <summary>
            Computes the bounding box of the given array of points.
            </summary>
      <param name="points">The set of 2D points coordinates</param>
      <param name="boxMin">The minimum point of the bounding box</param>
      <param name="boxMax">The maximum point of the bounding box</param>
    </member>
    <member name="M:devDept.Geometry.Utility.IsPointInsideOrOntoBBox2D(devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            Check if the Point3D is inside or onto the BoundingBox 2D made by boxMin and boxMax
            </summary>
      <param name="pointToCheck">The Point2D to test</param>
      <param name="boxMin"> The bottom left corner of the BoundingBox 2D</param>
      <param name="boxMax">The Top right corner of the BoundingBox 2D</param>
      <returns>
      </returns>
    </member>
    <member name="M:devDept.Geometry.Utility.DoOverlapOrTouch2D(devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
             Check if two bounding boxes overlap or touch.
            </summary>
      <param name="firstMin">First rectangle min 2D point</param>
      <param name="firstMax">First rectangle max 2D point</param>
      <param name="secondMin">Second rectangle min 2D point</param>
      <param name="secondMax">Second rectangle max 2D point</param>
      <returns>True if the two boxes overlap or touch, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.DoOverlapOrTouch2D(devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D,System.Double)">
      <summary>
            Check if two bounding rectangles overlap.
            </summary>
      <param name="firstMin">First rectangle min 2D point</param>
      <param name="firstMax">First rectangle max 2D point</param>
      <param name="secondMin">Second rectangle min 2D point</param>
      <param name="secondMax">Second rectangle max 2D point</param>
      <param name="domainSize">The 2D domain size</param>
      <returns>True if the two rectangle overlap or coincide, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.DoOverlap2D(devDept.Geometry.Point,devDept.Geometry.Point,devDept.Geometry.Point,devDept.Geometry.Point)">
      <summary>
            Check if two bounding rectangles overlap.
            </summary>
      <param name="firstMin">First rectangle min point</param>
      <param name="firstMax">First rectangle max point</param>
      <param name="secondMin">Second rectangle min point</param>
      <param name="secondMax">Second rectangle max point</param>
      <returns>True if the two rectangles overlap, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.DoOverlap2D(devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            Check if two bounding rectangles overlap.
            </summary>
      <param name="firstMin">First rectangle min 2D point</param>
      <param name="firstMax">First rectangle max 2D point</param>
      <param name="secondMin">Second rectangle min 2D point</param>
      <param name="secondMax">Second rectangle max 2D point</param>
      <returns>True if the two rectangles overlap, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.TriangleRectangleOverlap(devDept.Geometry.Point2D[],devDept.Geometry.Point2D[])">
      <summary>
            2D triangle rectangle overlap test.
            </summary>
      <param name="tri">The triangle perimeter as a list of 4 vertices</param>
      <param name="rect">The rectangle perimeter as a list of 5 vertices</param>
      <returns>True if the two polygons overlap, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.DoOverlap(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Check if two bounding boxes overlap.
            </summary>
      <param name="firstMin">First rectangle min 3D point</param>
      <param name="firstMax">First rectangle max 3D point</param>
      <param name="secondMin">Second rectangle min 3D point</param>
      <param name="secondMax">Second rectangle max 3D point</param>
      <returns>True if the two rectangles overlap, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.DoOverlapOrTouch(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
             Check if two bounding boxes overlap or touch.
            </summary>
      <param name="firstMin">First box min 3D point</param>
      <param name="firstMax">First box max 3D point</param>
      <param name="secondMin">Second box min 3D point</param>
      <param name="secondMax">Second box max 3D point</param>
      <returns>True if the two boxes overlap or touch, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.DoOverlapOrTouch(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Double)">
      <summary>
            Check if two bounding boxes overlap or touch.
            </summary>
      <param name="firstMin">First box min 3D point</param>
      <param name="firstMax">First box max 3D point</param>
      <param name="secondMin">Second box min 3D point</param>
      <param name="secondMax">Second box max 3D point</param>
      <param name="domainSize">The domain size</param>
      <returns>True if the two boxes overlap or touch, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.IntersectionRect(devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D@,devDept.Geometry.Point2D@)">
      <summary>
            Computes the intersection rectangle between two axis aligned rectangles. This function assumes that the two rectangles overlap.
            </summary>
      <param name="firstMin">First rectangle min point</param>
      <param name="firstMax">First rectangle max point</param>
      <param name="secondMin">Second rectangle min point</param>
      <param name="secondMax">Second rectangle max point</param>
      <param name="intersMin">Intersection rectangle min point</param>
      <param name="intersMax">Intersection rectangle max point</param>
      <returns>The size of the intersection rectangle</returns>
      <see cref="M:devDept.Geometry.Utility.DoOverlap2D(devDept.Geometry.Point,devDept.Geometry.Point,devDept.Geometry.Point,devDept.Geometry.Point)" />
    </member>
    <member name="M:devDept.Geometry.Utility.DoOverlapOrTouchWithIntersectionBox(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Size3D@)">
      <summary>
            Checks if two Axis-Aligned Bounding-Boxes intersect and computes their intersection boxes size.
            </summary>
      <param name="firstMin">First box min point</param>
      <param name="firstMax">First box max point</param>
      <param name="secondMin">Second box min point</param>
      <param name="secondMax">Second box max point</param>
      <param name="intersectionBox">The size of the intersection box (null if there is not intersection)</param>
      <returns>True if the two AABB intersect.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.IntersectionBox(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">
      <summary>
            Computes the intersection rectangle between two axis aligned boxes. This function assumes that the two boxes overlap.
            </summary>
      <param name="firstMin">First box min point</param>
      <param name="firstMax">First box max point</param>
      <param name="secondMin">Second box min point</param>
      <param name="secondMax">Second box max point</param>
      <param name="intersMin">Intersection box min point</param>
      <param name="intersMax">Intersection box max point</param>
      <returns>The size of the intersection box</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetCornersOnPlane(devDept.Geometry.Plane,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Double)">
      <summary>
            Computes a rect on the plane that encloses the eight projected bounding box corners.
            </summary>
      <param name="pln">The projection plane</param>
      <param name="min">The bounding box min corner</param>
      <param name="max">The bounding box max corner</param>
      <param name="margin">The optional margin</param>
      <returns>An array of four 3D points.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetSizeOnPlane(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Plane,devDept.Geometry.Point2D@,devDept.Geometry.Point2D@)">
      <summary>
            Gets 2D corners of the rectangle enclosing the projection of the 3D bounding box corners.
            </summary>
      <param name="cornerMin">3D bounding box min corner</param>
      <param name="cornerMax">3D bounding box max corner</param>
      <param name="pln">The projection plane</param>
      <param name="min">The resulting 2D min corner</param>
      <param name="max">The resulting 2D max corner</param>
    </member>
    <member name="M:devDept.Geometry.Utility.PointInPolygon(devDept.Geometry.Point2D,System.Collections.Generic.IList{devDept.Geometry.Point2D})">
      <summary>
            Tests if a 2D point is inside a 2D polygon.
            </summary>
      <param name="testPoint">The test 2D point</param>
      <param name="polygon">The polygon</param>
      <returns>True if the 2D point is inside, false if the point is outside. For points on the edges of the polygon, please use <see cref="M:devDept.Geometry.Utility.PointInPolygon(devDept.Geometry.Point2D,System.Collections.Generic.IList{devDept.Geometry.Point2D},System.Double)" /></returns>
      <remarks>The polygon must be closed, so the first and last points of the list must be coincident.</remarks>
    </member>
    <member name="M:devDept.Geometry.Utility.PointInPolygon(devDept.Geometry.Point2D,System.Collections.Generic.IList{devDept.Geometry.Point2D},System.Double)">
      <summary>
            Tests if a 2D point is inside a 2D polygon.
            </summary>
      <param name="testPoint">The test 2D point</param>
      <param name="polygon">The polygon</param>
      <param name="domainSize">The maximum diagonal size of the relevant polygon</param>
      <returns>The point status.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.PointInPolygon(devDept.Geometry.Point2D,System.Collections.Generic.IList{System.Collections.Generic.IList{devDept.Geometry.Point2D}},System.Double)">
      <summary>
            Tests if a 2D point is inside to a region composed by multiple 2D polygons (clockwise/anticlockwise orientation rule).
            </summary>
      <param name="testPoint">The test 2D point</param>
      <param name="polygonList">The region as a collection of properly oriented 2D polygons</param>
      <param name="domainSize">The maximum diagonal size polygon</param>
      <returns>The point status.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.PointInPolygon(devDept.Geometry.Point2D,System.Collections.Generic.IList{devDept.Geometry.Polygon2D})">
      <summary>
            Tests if a 2D point is inside to a region composed by multiple 2D polygons (clockwise/anticlockwise orientation rule).
            </summary>
      <param name="testPoint">The test 2D point</param>
      <param name="polygonList">The region as a collection of properly oriented 2D polygons</param>
      <returns>True if the point is inside the outer loop and outside all the inners loop, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.PointInRectangle(devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            Tests if a 2D point is inside to a 2D rectangle.
            </summary>
      <param name="testPoint">The test 2D point</param>
      <param name="lowerLeft">Rectangle lower left corner</param>
      <param name="upperRight">Rectangle upper right corner</param>
      <returns>The point status.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.PointInRect(devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            2D point in rectangle test.
            </summary>
      <param name="testPoint">The test 2D point</param>
      <param name="lowerLeft">Rectangle lower left corner</param>
      <param name="upperRight">Rectangle upper right corner</param>
      <returns>The point status.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.PointInTriangle(devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            2D point in triangle test.
            </summary>
      <param name="test">The test 2D point</param>
      <param name="a">The first triangle vertex</param>
      <param name="b">The second triangle vertex</param>
      <param name="c">The third triangle vertex</param>
      <returns>Returns true if the point is inside the triangle, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.PointInTriangle(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Point in triangle test.
            </summary>
      <param name="xP">The point's X-coordinate</param>
      <param name="yP">The point's y-coordinate</param>
      <param name="x1">The first triangle vertex's X-coordinate</param>
      <param name="y1">The first triangle vertex's y-coordinate</param>
      <param name="x2">The second triangle vertex's X-coordinate</param>
      <param name="y2">The second triangle vertex's y-coordinate</param>
      <param name="x3">The third triangle vertex's X-coordinate</param>
      <param name="y3">The third triangle vertex's y-coordinate</param>
      <returns>Returns true if the point is inside the triangle, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.IsPolygonConvex``1(System.Collections.Generic.IList{``0})">
      <summary>
            Returns true if the planar closed polygon is convex.
            </summary>
      <param name="vertices">The planar closed polygon vertices</param>
      <returns>True if the polygon is convex, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.IsPolygonSelfIntersecting``1(System.Collections.Generic.IList{``0})">
      <summary>
            Checks if the polygon is self-intersecting.
            </summary>
      <typeparam name="T">The point type</typeparam>
      <param name="vertices">The list of vertices</param>
      <returns>True if the polygon is self intersecting, false otherwise</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.IsPolygonDegenerated``1(System.Collections.Generic.IList{``0})">
      <summary>
            Checks if the polygon is self-intersecting or has T junctions.
            </summary>
      <typeparam name="T">The point type</typeparam>
      <param name="vertices">The list of vertices</param>
      <returns>True if the polygon is self intersecting or has T junctions, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.IsPointInside(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Double,System.Boolean)">
      <summary>
            Checks if the point is inside the specified bounding box.
            </summary>
      <param name="min">Minimum 3D corner</param>
      <param name="max">Maximum 3D corner</param>
      <param name="inflate">Inflate amount</param>
      <param name="testOpenIntervals">If false, for each component, P is tested to see if it satisfies min.X &lt;= P.X &lt;= max.X. If true, P is tested to see if it satisfies min.X &lt; P.X &lt; max.X.</param>
      <returns>True if the 3D point is inside the bounding box, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.CleanQuads(System.Collections.Generic.IList{System.Int32[]},System.Collections.Generic.IList{devDept.Geometry.PointNormalUv},System.Collections.Generic.List{devDept.Geometry.PointNormalUv}@)">
      <summary>
            Cleans a quad list from duplicated vertices.
            </summary>
      <param name="quads">The quad list</param>
      <param name="vertices">The vertices list</param>
      <param name="uniqueVertices">The vertices list without duplicates</param>
      <returns>the vertices conversion indices</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.CleanTriangles(System.Collections.Generic.IList{devDept.Geometry.IndexTriangle},System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.List{devDept.Geometry.IndexTriangle}@,System.Collections.Generic.List{devDept.Geometry.Point3D}@)">
      <summary>
            Cleans a triangles list from duplicated vertices.
            </summary>
      <param name="triangles">The triangles list</param>
      <param name="vertices">The vertices list</param>
      <param name="cleanedTriangles">The triangles list without degenerate triangles</param>
      <param name="uniqueVertices">The vertices list without the duplicated vertices</param>
    </member>
    <member name="M:devDept.Geometry.Utility.CleanTriangles(System.Collections.Generic.IList{devDept.Geometry.IndexTriangle},System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.List{devDept.Geometry.IndexTriangle}@,System.Collections.Generic.List{devDept.Geometry.Point3D}@,System.Int32[]@)">
      <summary>
            Cleans the triangles from duplicated vertices.
            </summary>
      <param name="triangles">The triangles list</param>
      <param name="vertices">The vertices list</param>
      <param name="cleanedTriangles">The triangles list without degenerate triangles</param>
      <param name="uniqueVertices">The vertices list without the duplicated vertices</param>
      <param name="conversionIndices">The vertex index conversion map</param>
    </member>
    <member name="M:devDept.Geometry.Utility.OrderEdges(System.Collections.Generic.List{devDept.Geometry.IndexLine},System.Collections.Generic.List{devDept.Geometry.IndexLine}@)">
      <summary>
            Create an ordered list of edges without duplicates.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Utility.AreEqual(System.Double,System.Double,System.Double)">
      <summary>
            Compares two floating point numbers using the provided domain size.
            </summary>
      <param name="a">First floating point number</param>
      <param name="b">Second floating point number</param>
      <param name="domainSize">The domain size</param>
      <returns>True if the two numbers are equal, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.Compare(System.Double,System.Double)">
      <summary>
            Compares two floating point numbers using a relative error of 1e-8.
            </summary>
      <param name="a">First number</param>
      <param name="b">Second number</param>
      <returns>Returns 
            -1: first &lt; second
             0: first == second
            +1: first &gt; second</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.Compare(System.Double,System.Double,System.Double)">
      <summary>
            Compares two floating point numbers using the given error tolerance.
            </summary>
      <param name="a">First number</param>
      <param name="b">Second number</param>
      <returns>Returns 
            -1: first &lt; second
             0: first == second
            +1: first &gt; second</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.CompareWithoutTolerance(System.Double,System.Double)">
      <summary>
            Compares two floating point numbers witohut using a tolerance (for Sorting methods).
            </summary>
      <param name="a">First number</param>
      <param name="b">Second number</param>
      <returns>Returns 
            -1: first &lt; second
             0: first == second
            +1: first &gt; second</returns>
    </member>
    <member name="F:devDept.Geometry.Utility.TOL3">
      <summary>
            Constant, 1e-3.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Utility.TOL6">
      <summary>
            Constant, 1e-6.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Utility.TOL9">
      <summary>
            Constant, 1e-9.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Utility.PI">
      <summary>
            Constant,  Ï.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Utility.ZERO_TOLERANCE">
      <summary>
            Constant, 1e-12.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Utility.SQRT2">
      <summary>
            Constant, square root of 2, truncated at 30 digits.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Utility.SQRT3">
      <summary>
            Constant, square root of 3, truncated at 30 digits.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Utility.SQRT3_OVER_2">
      <summary>
            Constant, square root of 3 divided by 2, truncated at 30 digits.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Utility.SQRT2_OVER_2">
      <summary>
            Constant, square root of 2 divided by 2, truncated at 30 digits.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Utility.TWO_PI">
      <summary>
            Constant,  Ï * 2.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Utility.PI_2">
      <summary>
            Constant,  Ï / 2.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Utility.PI_6">
      <summary>
            Constant,  Ï / 6.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Utility.QUARTER_PI">
      <summary>
            Constant,  Ï / 4.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Utility.THREE_QUARTER_PI">
      <summary>
            Constant,  Ï * 3 / 4.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Utility.POS_MIN_DBL">
      <summary>
            Constant, minimum positive value equal to 2.2250738585072014e-308.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Utility.EPSILON">
      <summary>
            Constant, small positive value equal to 2.2204460492503131e-16.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Utility.SQRT_EPSILON">
      <summary>
            Constant, square root of EPSILON.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Utility.HDLGRIDSPAN">
      <summary>
            Integer grid span.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Utility.DeepCopyVertices(devDept.Geometry.Point3D[])">
      <summary>
            Point3D array deep copy.
            </summary>
      <param name="toCopy">The array of vertices to be copied</param>
      <returns>The deeply copied array.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetDeviation(devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,devDept.Geometry.Vector3D,System.Double@)">
      <summary>
            Computes the deviation of an arc defined by two 3D points and two 3D tangents.
            </summary>
      <param name="a">The first 3D point</param>
      <param name="aTan">The first 3D tangent</param>
      <param name="b">The second 3D point</param>
      <param name="bTan">The second 3D tangent</param>
      <param name="radius">The resulting arc radius</param>
      <returns>The deviation amount.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetDeviation2D(devDept.Geometry.Point2D,devDept.Geometry.Vector2D,devDept.Geometry.Point2D,devDept.Geometry.Vector2D,System.Double@)">
      <summary>
            Computes the deviation of an arc defined by two 2D points and two 2D tangents.
            </summary>
      <param name="a">The first 2D point</param>
      <param name="aTan">The first 2D tangent</param>
      <param name="b">The second 2D point</param>
      <param name="bTan">The second 2D tangent</param>
      <param name="radius">The resulting arc radius</param>
      <returns>The deviation amount.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.IsImperial(devDept.Geometry.linearUnitsType)">
      <summary>
            Returns true if the specified unit is Inches, Feet or Miles.
            </summary>
      <param name="units">
      </param>
      <returns>True if the specified unit is Inches, Feet or Miles. False otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.IsImperial(devDept.Geometry.massUnitsType)">
      <summary>
            Returns true if the specified unit is Ounces, Pounds, Stones, ShortTons, LongTons.
            </summary>
      <param name="units">
      </param>
      <returns>True if the specified unit is Inches, Feet or Miles. False otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.RadToDeg(System.Double)">
      <summary>
            Converts radians to degrees.
            </summary>
      <param name="radians">The angle in radians</param>
      <returns>The converted angle in degrees.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.DegToRad(System.Double)">
      <summary>
            Converts degrees to radians.
            </summary>
      <param name="degrees">The angle in degrees</param>
      <returns>The converted angle in radians.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.LimitRange``1(``0,``0@,``0)">
      <summary>
            Clamps a value between the specified lower and upper limits.
            </summary>
      <typeparam name="T">The type of the value to clamp</typeparam>
      <param name="low">Lower limit</param>
      <param name="value">The value</param>
      <param name="high">Upper limit</param>
    </member>
    <member name="M:devDept.Geometry.Utility.Min``1(``0,``0,``0)">
      <summary>
            Returns the min of three values.
            </summary>
      <param name="a">First value</param>
      <param name="b">Second value</param>
      <param name="c">Third value</param>
      <returns>The maximum value.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.Max``1(``0,``0,``0)">
      <summary>
            Returns the max of three values.
            </summary>
      <param name="a">First value</param>
      <param name="b">Second value</param>
      <param name="c">Third value</param>
      <returns>The maximum value.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.CircularNext``1(System.Collections.Generic.LinkedListNode{``0})">
      <summary>
            Returns the next 'circular' node in the linked list.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="listNode">Current node</param>
      <returns>The next 'circular' node.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.CircularPrevious``1(System.Collections.Generic.LinkedListNode{``0})">
      <summary>
            Returns the previous 'circular' node in the linked list.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="listNode">Current node</param>
      <returns>The previous 'circular' node.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.IntegerToColorBytes(System.Int32)">
      <summary>
            Converts an integer value representing a color to an array of bytes.
            </summary>
      <param name="argbColor">The integer value representing an ARGB Color.</param>
      <returns>An array of byte representing (B)lue, (G)reen, (R)ed, (A)lpha components of a color.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.ColorBytesToInteger(System.Byte,System.Byte,System.Byte,System.Byte)">
      <summary>
            Converts an an array of bytes representing a color to integer value.
            </summary>
      <param name="a">byte representing alpha component of a color.</param>
      <param name="r">byte representing red component of a color.</param>
      <param name="g">byte representing green component of a color.</param>
      <param name="b">byte representing blue component of a color.</param>
      <returns>An integer value representing a color.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.MmToInches(System.Double)">
      <summary>
            Converts Millimeters to Inches.
            </summary>
      <param name="mm">The distance in Millimeters</param>
      <returns>The distance in inches.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.InchesToMm(System.Double)">
      <summary>
            Converts Inches to Millimeters.
            </summary>
      <param name="inches">The distance in Inches</param>
      <returns>The distance in Millimeters.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.EvaluateCurvature(devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D@,devDept.Geometry.Vector3D@)">
      <summary>
        <para>Evaluates unit tangent and curvature from first and second derivatives.</para>
        <para>T = D1 / |D1|</para>
        <para>K = ( D2 - (D2 o T)*T )/( D1 o D1)</para>
      </summary>
      <param name="D1">First derivative</param>
      <param name="D2">Second derivative</param>
      <param name="T">Unit tangent returned here</param>
      <param name="K">Curvature returned here</param>
    </member>
    <member name="M:devDept.Geometry.Utility.ReverseArray``1(System.Collections.Generic.IList{``0})">
      <summary>
            Reverses the order of the elements in the array.
            </summary>
      <typeparam name="T">Items type</typeparam>
      <param name="array">The one-dimensional array to reverse</param>
    </member>
    <member name="M:devDept.Geometry.Utility.DoublesToPointArray2D(System.Double[])">
      <summary>
            Convert a list of double values to a 2D point array.
            </summary>
      <param name="listOfDoubles">An array of double values</param>
      <returns>A list of 3D points.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.DoublesToPointArray3D(System.Double[])">
      <summary>
            Converts an array of doubles to a an array of 3D points.
            </summary>
      <param name="listOfDoubles">An array of doubles</param>
      <returns>The 3D point array.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.DoublesToPointArray4D(System.Double[])">
      <summary>
            Converts an array of doubles to a an array of 4D points (only the XYZ members are converted). 
            </summary>
      <param name="listOfDoubles">An array of doubles</param>
      <returns>The 4D point array.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.Append(System.Double[0:,0:],System.Double[0:,0:])">
      <summary>
            Appends the second array at the end of first one.
            </summary>
      <param name="first">First rectangular array</param>
      <param name="second">Second rectangular array</param>
      <returns>A single array containing first and second.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.InvertMatrixd(System.Double[],System.Double[])">
      <summary>
            Inverts a matrix.
            </summary>
      <param name="m">The matrix to invert</param>
      <param name="invOut">The inverted matrix</param>
      <returns>True if successful, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetPointsOnPlane(devDept.Geometry.Plane,System.Collections.Generic.IList{devDept.Geometry.Point2D})">
      <summary>
            Gets the array of Point3D from a 2D profile.
            </summary>
      <param name="sketchPlane">The sketch plane</param>
      <param name="contour">the 2D contour</param>
      <returns>The Point3D array.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetTrianglesPlane(System.Collections.Generic.IList{devDept.Geometry.IndexTriangle},System.Collections.Generic.IList{devDept.Geometry.Point3D})">
      <summary>
            Gets the first valid plane found from a collection of triangles. 
            </summary>
      <param name="triangles">The collection of triangles</param>
      <param name="vertices">The collection of vertices</param>
      <returns>The first valid plane found.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.PolygonArea``1(System.Collections.Generic.IList{``0})">
      <summary>
            Computes the signed area of a polygon (the points are always projected on XY plane).
            </summary>
      <param name="polygon">The list of 2D points</param>
      <returns>Depending on the polygon direction will return a positive or negative area.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.PolygonArea(System.Double[0:,0:])">
      <summary>
            Computes the signed area of a polygon (the points are always projected on XY plane).
            </summary>
      <param name="polygon">The list of 2D points coordinates</param>
      <returns>Depending on the polygon direction will return a positive or negative area.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.NumberOfSegments(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Computes the number of arc subdivisions according to specified chordal error and maximum angle between tangents.
            </summary>
      <param name="radius">Arc radius</param>
      <param name="deltaInRadians">Arc span angle (in radians)</param>
      <param name="deviation">The maximum deviation</param>
      <param name="angle">The maximum angular deflection</param>
      <returns>The number of segments.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.NumberOfSegmentsByLength(System.Double,System.Double,System.Double)">
      <summary>
            Computes the number of arc subdivisions according to specified maximum segment length.
            </summary>
      <param name="radius">Arc radius</param>
      <param name="deltaInRadians">Arc span angle (in radians)</param>
      <param name="length">The maximum segment length</param>
      <returns>The number of segments.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.Swap``1(``0@,``0@)">
      <summary>
            Swaps two values.
            </summary>
      <typeparam name="T">The type of values to swap</typeparam>
      <param name="first">First value</param>
      <param name="second">Second value</param>
    </member>
    <member name="M:devDept.Geometry.Utility.GetBoundingBoxTransformed(devDept.Geometry.Transformation,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">
      <summary>
            Transforms the eight corners of a world-aligned bounding box and returns the minimum and maximum corners.
            </summary>
      <param name="transform">The transformation to apply to the bounding box</param>
      <param name="min">The minimum point of the bounding box</param>
      <param name="max">The maximum point of the bounding box</param>
      <param name="boxMin">The transformed minimum point</param>
      <param name="boxMax">The transformed maximum point</param>
    </member>
    <member name="M:devDept.Geometry.Utility.VectorsAngle(devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D)">
      <summary>
            Returns the angle in degrees between two vectors.
            </summary>
      <param name="v1">First Vector</param>
      <param name="v2">Second Vector</param>
      <param name="rotAxis">Rotation Axis</param>
      <returns>The angle in degrees between the vectors, measured in clockwise direction.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.IsInFrustum(devDept.Geometry.PlaneEquation[],devDept.Geometry.Point3D,System.Double)">
      <summary>
            Tells if a hypothetical sphere with the specified center and radius is inside the given frustum planes.
            </summary>
      <param name="frustum">Frustum planes</param>
      <param name="center">Center of the sphere</param>
      <param name="radius">Radius of the sphere</param>
      <returns>True if the hypothetical sphere is inside the planes.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.IsInFrustum(devDept.Geometry.PlaneEquation[],devDept.Geometry.Point3D,System.Double,System.Boolean@)">
      <summary>
            Tells if a hypothetical sphere with the specified center and radius is inside the given frustum planes.
            </summary>
      <param name="frustum">Frustum planes</param>
      <param name="center">Center of the sphere</param>
      <param name="radius">Radius of the sphere</param>
      <param name="intersect">When true, frustum and sphere intersect.</param>
      <returns>True if the hypothetical sphere is inside the planes.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.IsInFrustum(devDept.Geometry.PlaneEquation[],devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Tells if a hypothetical sphere with the specified center and radius is inside the given frustum planes.
            </summary>
      <param name="frustum">Frustum planes</param>
      <param name="min">Min bounding box 3D point</param>
      <param name="max">Max bounding box 3D point</param>
      <returns>True if the hypothetical sphere is inside the planes.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.IsPointOnSegment(devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D,System.Double)">
      <summary>
            Determines if a point in on a segment. First it checks if the parameter t for the 
            projected point is between 0 and 1, then it checks if the test point is close enough
            to the segment. 
            </summary>
    </member>
    <member name="M:devDept.Geometry.Utility.GetEdgesWithoutDuplicates(System.Collections.Generic.IList{devDept.Geometry.IndexTriangle},System.Int32)">
      <summary>
            Gets a list of edges without duplicates from a mesh of triangles.
            </summary>
      <param name="polygons">Polygon list definition, each row can have independently 3 or 4 indices.</param>
      <param name="numVerts">Number of vertices in the mesh</param>
      <returns>The rectangular array of the resulting - unique - edges. First and second 
            indices are the edge vertex indices, third and fourth are the parent triangle indices. Fourth 
            index can be -1 for edges with only one parent triangle.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetEdgesWithoutDuplicates(System.Collections.Generic.IList{devDept.Geometry.IndexTriangle},System.Int32,System.Collections.Generic.LinkedList{devDept.Geometry.SharedEdge}[]@)">
      <summary>
            Gets a list of edges without duplicates from a mesh of triangles.
            </summary>
      <param name="polygons">Polygon list definition, each row can have independently 3 or 4 indices.</param>
      <param name="numVerts">Number of vertices in the mesh</param>
      <param name="edgesPerVertex">The edges per each vertex</param>
      <returns>The number of edges.</returns>
      <remarks> The entry 'i' of the <paramref name="edgesPerVertex" /> array is a <see cref="T:System.Collections.Generic.LinkedList`1" /> of <see cref="T:devDept.Geometry.SharedEdge" /> for all vertices connected to 'i'
            whose index is greater than 'i'.
            The <see cref="F:devDept.Geometry.SharedEdge.Dad" /> is -1 if the edge has only one adjacent triangle (that is stored in <see cref="F:devDept.Geometry.SharedEdge.Mum" />).</remarks>
    </member>
    <member name="M:devDept.Geometry.Utility.GetEdgesWithoutDuplicates(System.Int32[][],System.Int32,System.Collections.Generic.LinkedList{devDept.Geometry.SharedEdge}[]@)">
      <summary>
            Gets a list of edges without duplicates from a mesh of polygons (3 or 4 sided mixed).
            </summary>
      <param name="polygons">Polygon list definition, each row can have independently 3 or 4 indices.</param>
      <param name="numVerts">Number of vertices in the mesh</param>
      <param name="edgesPerVertex">An array of linked list of - unique - edges propagating from the same vertex.
            This is an intermediate result.</param>
      <returns>The rectangular array of the resulting - unique - edges. First and second 
            indices are the edge vertex indices, third and fourth are the parent triangle indices. Fourth 
            index can be -1 for edges with only one parent triangle.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetEdgesWithoutDuplicates(System.Int32[0:,0:],System.Int32)">
      <summary>
            Gets a list of edges without duplicates from a mesh of triangles or quads.
            </summary>
      <param name="polygons">Polygon list definition, dimensions can be [n,3] or [n,4].</param>
      <param name="numVerts">Number of vertices in the mesh</param>
      <returns>The rectangular array of the resulting - unique - edges. First and second 
            indices are the edge vertex indices, third and fourth are the parent triangle indices. Fourth 
            index can be -1 for edges with only one parent triangle.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetEdgesWithoutDuplicates(System.Int32[0:,0:],System.Int32,System.Collections.Generic.LinkedList{devDept.Geometry.SharedEdge}[]@)">
      <summary>
            Gets a list of edges without duplicates from a mesh of triangles or quads.
            </summary>
      <param name="polygons">Polygon list definition, dimensions can be [n,3] or [n,4].</param>
      <param name="numVerts">Number of vertices in the mesh</param>
      <param name="edgesPerVertex">An array of linked list of - unique - edges propagating from the same vertex.
            This is an intermediate result.</param>
      <returns>The rectangular array of the resulting - unique - edges. First and second 
            indices are the edge vertex indices, third and fourth are the parent triangle indices. Fourth 
            index can be -1 for edges with only one parent triangle.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetEdgesWithoutDuplicates(devDept.Geometry.SilhoPolyRegion[],System.Int32,System.Collections.Generic.LinkedList{devDept.Geometry.SharedEdge}[]@,System.Boolean)">
      <summary>
            Gets a list of edges without duplicates from a mesh of triangles or quads.
            </summary>
      <param name="polygons">Polygon list definition, dimensions can be [n,3] or [n,4].</param>
      <param name="numVerts">Number of vertices in the mesh</param>
      <param name="skipBorderEdges">If true, the edges with just one adjacent triangle are skipped</param>
      <param name="edgesPerVertex">An array of linked list of - unique - edges propagating from the same vertex.
            This is an intermediate result.</param>
      <returns>The rectangular array of the resulting - unique - edges. First and second 
            indices are the edge vertex indices, third and fourth are the parent triangle indices. Fourth 
            index can be -1 for edges with only one parent triangle.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetSkinFaces(System.Int32[][],System.Int32,System.Collections.Generic.LinkedList{devDept.Geometry.SharedFace}[]@)">
      <summary>
            Gets a list of faces without duplicates from a mesh of triangles or quads.
            </summary>
      <param name="faces">Polygon list definition, dimensions can be [n,3] or [n,4].</param>
      <param name="numVerts">Number of vertices in the mesh</param>
      <param name="facesPerVertex">An array of linked list of - unique - faces propagating from the same vertex.
            This is an intermediate result.</param>
      <returns>The rectangular array of the resulting - unique - faces. First, second and third
            indices are the face vertex indices, third and fourth are the parent objects indices. Fourth 
            index can be -1 for faces with only one parent object.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.TriangleTriangleIntersection(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Boolean@)">
      <summary>
            Fast Triangle-Triangle intersection between ccw T1[p1,q1,r1] and ccw T2[p2,q1,r2] (From the Devillers and Guigue algorithm).
            </summary>
      <param name="p1">First point3D of triangle 1</param>
      <param name="q1">Second point3D of triangle 1</param>
      <param name="r1">Third point3D of triangle 1</param>
      <param name="p2">First point3D of triangle 2</param>
      <param name="q2">Second point3D of triangle 2</param>
      <param name="r2">Third point3D of triangle 2</param>
      <param name="touch">True when a vertex or edge of one triangle lies on the plane of other</param>
      <returns>True if the Triangles intersects each other, false otherwise</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.TriangleTriangleIntersection(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[],System.Double[],System.Boolean@)">
      <summary>
            Fast Triangle-Triangle intersection between ccw T1[p1,q1,r1] and ccw T2[p2,q1,r2] (From the Devillers and Guigue algorithm).
            </summary>
      <param name="p1">coordinates of the first point3D of triangle 1</param>
      <param name="q1">coordinates of the second point3D of triangle 1</param>
      <param name="r1">coordinates of the third point3D of triangle 1</param>
      <param name="p2">coordinates of the first point3D of triangle 2</param>
      <param name="q2">coordinates of the second point3D of triangle 2</param>
      <param name="r2">coordinates of the third point3D of triangle 2</param>
      <param name="touch">True when a vertex or edge of one triangle lies on the plane of other</param>
      <returns>True if the Triangles intersects each other, false otherwise</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.TriangleTriangleIntersection2D(devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            Fast Triangle-Triangle 2D intersection between ccw T1[p1,q1,r1] and ccw T2[p2,q1,r2] (From the Devillers and Guigue algorithm).
            </summary>
      <param name="p1">First point2D of triangle 1</param>
      <param name="q1">Second point2D of triangle 1</param>
      <param name="r1">Third point2D of triangle 1</param>
      <param name="p2">First point2D of triangle 2</param>
      <param name="q2">Second point2D of triangle 2</param>
      <param name="r2">Third point2D of triangle 2</param>
      <returns>True if the Triangles intersects each other, false otherwise</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.TriangleTriangleIntersection2D(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[],System.Double[])">
      <summary>
            Fast Triangle-Triangle 2D intersection between ccw T1[p1,q1,r1] and ccw T2[p2,q1,r2] (From the Devillers and Guigue algorithm).
            </summary>
      <param name="p1">coordinates of the first point2D of triangle 1</param>
      <param name="q1">coordinates of the second point2D of triangle 1</param>
      <param name="r1">coordinates of the third point2D of triangle 1</param>
      <param name="p2">coordinates of the first point2D of triangle 2</param>
      <param name="q2">coordinates of the second point2D of triangle 2</param>
      <param name="r2">coordinates of the third point2D of triangle 2</param>
      <returns>True if the Triangles intersects each other, false otherwise</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.LinePlaneIntersection(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.PlaneEquation,devDept.Geometry.Point3D@)">
      <summary>
            Intersects the infinite line with a plane.
            </summary>
      <param name="p0">First point of the line</param>
      <param name="p1">Second point of the line</param>
      <param name="pe">The plane equation</param>
      <param name="intPoint">The intersection point (if exists)</param>
      <returns>True if the intersection was found, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.MultMatrixd(System.Double[],System.Double[])">
      <summary>
            Multiplies two matrices.
            </summary>
      <param name="a">first matrix</param>
      <param name="b">second matrix</param>
      <returns>The matrix a x b.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.MultMatrixf(System.Single[],System.Single[])">
      <summary>
            Multiplies two matrices.
            </summary>
      <param name="a">first matrix</param>
      <param name="b">second matrix</param>
      <returns>The matrix a x b.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.MultMatrixVecd(System.Double[],System.Double[])">
      <summary>
            Multiplies a matrix by a vector.
            </summary>
      <param name="matrix">The matrix</param>
      <param name="vector">The vector</param>
      <returns>The vector "matrix x vect"</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.FindLoops(devDept.Geometry.Point2D[][],devDept.Geometry.Point2D[][]@,devDept.Geometry.Point2D[][][]@)">
      <summary>
            Finds the outers and inners contours from a collection of 2d contours.
            </summary>
      <param name="loops">The collection of 2d contours</param>
      <param name="outers">The collection of outer contours</param>
      <param name="inners">The collection of inner contours for each contour of the <paramref name="outers" /> collection</param>
    </member>
    <member name="M:devDept.Geometry.Utility.RemoveDuplicates``1(System.Collections.Generic.IList{``0})">
      <summary>
            Removes contiguous duplicated points from the list.
            </summary>
      <typeparam name="T">A point type</typeparam>
      <param name="pointList">The list of points to be analyzed</param>
      <returns>The cleaned array of points.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.RemoveDuplicates``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{System.Int32}@)">
      <summary>
            Removes contiguous duplicated points from the list.
            </summary>
      <typeparam name="T">A point type</typeparam>
      <param name="pointList">The list of points to be analyzed</param>
      <param name="indices">The indices in the <paramref name="pointList" /> list of the returned points</param>
      <returns>The cleaned array of points.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.RemoveDuplicates``1(System.Collections.Generic.IList{``0},System.Double)">
      <summary>
            Removes contiguous duplicated points from the list.
            </summary>
      <typeparam name="T">A point type</typeparam>
      <param name="pointList">The list of points to be analyzed</param>
      <param name="tol">The tolerance that, multiplied for the curve length, determines the distance between two points to be considered NOT duplicated.</param>
      <returns>The cleaned array of points.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetOrientationTransformation(devDept.Geometry.Point3D,devDept.Geometry.Vector3D)">
      <summary>
            Gets the transformation to orient an entity built on the X-Axis on the given direction.
            </summary>
      <param name="position">The point where the entity must be positioned</param>
      <param name="direction">The orientation desired</param>
      <returns>The transformation to orient the entity.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.InsideOrCrossingFrustum(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.PlaneEquation[])">
      <summary>
            Checks whether the triangle is inside or crossing the frustum defined by the given planes.
            </summary>
      <param name="pt1">The first  triangle vertex</param>
      <param name="pt2">The second triangle vertex</param>
      <param name="pt3">The third triangle vertex </param>
      <param name="frustum">The frustum planes equations</param>
      <returns>True if the triangle is inside or is crossing the frustum.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.InsideOrCrossingFrustumQuad(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.PlaneEquation[])">
      <summary>
            Checks whether the quad is inside or crossing the frustum defined by the given planes.
            </summary>
      <param name="pt1">The first quad vertex</param>
      <param name="pt2">The second quad vertex</param>
      <param name="pt3">The third quad vertex </param>
      <param name="pt4">The fourth quad vertex </param>
      <param name="frustum">The frustum planes equations</param>
      <returns>True if the quad is inside or is crossing the frustum.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.IsSegmentInsideOrCrossing(devDept.Geometry.PlaneEquation[],devDept.Geometry.Segment3D)">
      <summary>
            Tells if a segment is inside or crossing the camera frustum.
            </summary>
      <param name="frustum">The camera frustum</param>
      <param name="segment">The segment</param>
      <returns>True if the segment intersects or is inside the camera frustum.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.IsPointInsideOrCrossing(devDept.Geometry.PlaneEquation[],devDept.Geometry.Point3D)">
      <summary>
            Tells if a point is inside the camera frustum.
            </summary>
      <param name="frustum">The camera frustum</param>
      <param name="point">The point</param>
      <returns>True if the point is inside the camera frustum.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.TransformNormals(devDept.Geometry.Transformation,devDept.Geometry.Vector3D[])">
      <summary>
            Transforms the collection of normals with the given transformation.
            </summary>
      <param name="t">The transformation</param>
      <param name="normals">The collection of normals vectors</param>
      <remarks>The normals are transformed by the inverse transpose of the upper 3x3 matrix.</remarks>
    </member>
    <member name="M:devDept.Geometry.Utility.GetMatrixForNormals(devDept.Geometry.Transformation)">
      <summary>
            Gets the matrix needed for normals transformation.
            </summary>
      <param name="transform">The transformation</param>
      <returns>The inverse transpose of the upper 3x3 matrix.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.Translated(System.Double,System.Double,System.Double,System.Double[]@)">
      <summary>
            Craetes a translation matrix and muliplies the original matrix by it.
            </summary>
      <param name="dx">The X translation coefficient</param>
      <param name="dy">The Y translation coefficient</param>
      <param name="dz">The Z translation coefficient</param>
      <param name="original">The matrix to multiply</param>
    </member>
    <member name="M:devDept.Geometry.Utility.Scaled(System.Double,System.Double,System.Double,System.Double[]@)">
      <summary>
            Craetes a scaling matrix and muliplies the original matrix by it.
            </summary>
      <param name="sx">The X scaling coefficient</param>
      <param name="sy">The Y scaling coefficient</param>
      <param name="sz">The Z scaling coefficient</param>
      <param name="original">The matrix to multiply</param>
    </member>
    <member name="M:devDept.Geometry.Utility.PrevItem``1(System.Collections.Generic.IList{``0},System.Int32)">
      <summary>
            Return the cyclic previous item in a list.
            </summary>
      <typeparam name="T">The item type</typeparam>
      <param name="list">The list</param>
      <param name="itemIndex">The item index</param>
      <returns>The previous item or the last item of the list in the case that itemIndex is equal to zero.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.NextItem``1(System.Collections.Generic.IList{``0},System.Int32)">
      <summary>
            Return the cyclic next item in a list.
            </summary>
      <typeparam name="T">The item type</typeparam>
      <param name="list">The list</param>
      <param name="itemIndex">The item index</param>
      <returns>The next item or the first item of the list in the case that itemIndex is equal to the list length less one.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.NormalInterpolation(devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Point3D)">
      <summary>
            Returns the interpolated normal at the point p somewhere in the middle of the 3D segment defined by the points p1 and p2.
            </summary>
      <param name="p1">The segment start point</param>
      <param name="n1">The segment start normal (unit length)</param>
      <param name="p2">The segment end point</param>
      <param name="n2">The segment end normal (unit length)</param>
      <param name="p">The point</param>
      <returns>The 3D normal vector.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.NormalInterpolation(devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,devDept.Geometry.Vector3D)">
      <summary>
            Returns the interpolated normal at the point p somewhere in the middle of the 3D rectangular face defined by the points p1, p2, p3 and p4.
            </summary>
      <param name="p1">The face first corner point</param>
      <param name="n1">The face first corner normal (unit length)</param>
      <param name="p2">The face second corner point</param>
      <param name="n2">The face second corner (unit length)</param>
      <param name="p3">The face third corner point</param>
      <param name="n3">The face third corner (unit length)</param>
      <param name="p4">The face fourth corner point</param>
      <param name="n4">The face fourth corner (unit length)</param>
      <param name="p">The point</param>
      <param name="splittingPlaneNormal">A 3D vector used for face splitting. A 3D vector perpendicular to the 3D face is not allowed.</param>
      <returns>The 3D normal vector.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.ComputeTolerance(System.Double)">
      <summary>
            Computes visual refinement tolerance.
            </summary>
      <param name="sceneDiagonal">The length of the scene bounding box diagonal</param>
      <returns>The resulting visual refinement tolerance.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.IsClosedProfile(System.Collections.Generic.IList{devDept.Geometry.Point2D})">
      <summary>
            Tells if a profile is closed, depending on a tolerance computed from its size.
            </summary>
      <param name="profile">The list of vertices of the profile</param>
      <returns>
      </returns>
    </member>
    <member name="M:devDept.Geometry.Utility.IsClosedProfile(System.Collections.Generic.IList{devDept.Geometry.Point3D})">
      <summary>
            Tells if a profile is closed, depending on a tolerance computed from its size.
            </summary>
      <param name="profile">The list of vertices of the profile</param>
      <returns>
      </returns>
    </member>
    <member name="M:devDept.Geometry.Utility.HermiteSpline(devDept.Geometry.Point2D,devDept.Geometry.Vector2D,devDept.Geometry.Point2D,devDept.Geometry.Vector2D,System.Double)">
      <summary>
            Computes a point on the Hermite Spline.
            </summary>
      <param name="p0">Start point</param>
      <param name="m0">Start tangent</param>
      <param name="p1">End point</param>
      <param name="m1">End tangent</param>
      <param name="t">Evaluation parameter</param>
      <returns>The 2D point on the curve.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetSliceVerticesAndNormals(System.Int32,System.Double,System.Int32,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D[],devDept.Geometry.Point3D@,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@,devDept.Geometry.Vector3D@,devDept.Geometry.Vector3D@,devDept.Geometry.Vector3D@,devDept.Geometry.Vector3D@)">
      <summary>
            Quad strip generation for Bar entity. Born for Bar entity, now used also for Fem Truss elements
            </summary>
    </member>
    <member name="M:devDept.Geometry.Utility.InvalidOGLPoint(devDept.Geometry.Point3D)">
      <summary>
            Tells if the point has valid coordinates for the OpenGL flaot precision.
            </summary>
      <param name="pt">The point</param>
      <returns>True if the point is within the OpenGL float precision, else otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.IsOrientedClockwise``1(System.Collections.Generic.IList{``0})">
      <summary>
            Detects polygon orientation (the points are always projected on XY plane).
            </summary>
      <param name="polygon">The polygon to check</param>
      <returns>True if the polygon orientation is clockwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.PolygonOrientation``1(System.Collections.Generic.IList{``0})">
      <summary>
            Computes the signed area of a polygon (the points are always projected on XY plane).
            </summary>
      <param name="polygon">The list of points</param>
      <returns>&gt;0 for counterclockwise 
            =0 for none (degenerate)
            lt;0 for clockwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.RotateLeft``1(``0[])">
      <summary>
            Rotates the array left.
            </summary>
      <typeparam name="T">The array items type</typeparam>
      <param name="array">The array</param>
    </member>
    <member name="M:devDept.Geometry.Utility.RotateRight``1(``0[])">
      <summary>
            Rotates the array right.
            </summary>
      <typeparam name="T">The array items type</typeparam>
      <param name="array">The array</param>
    </member>
    <member name="M:devDept.Geometry.Utility.GetRotationAxisAndAngle(devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D@,System.Double@)">
      <summary>
            Returns the rotation axis and the angle to rotate from one vector to another. 
            </summary>
      <param name="vector1">First vector</param>
      <param name="vector2">Second vector</param>
      <param name="rotAxis">The rotation axis</param>
      <param name="angleInDegrees">The angle in degrees, measured in clockwise direction.</param>
    </member>
    <member name="M:devDept.Geometry.Utility.AreEqual(System.Collections.IList,System.Collections.IList)">
      <summary>
            Checks if two generic lists contain the same elements.
            </summary>
      <param name="first">The first generic list</param>
      <param name="second">The second generic list</param>
      <returns>True if the elements of the two generic lists are the same.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.AreEqual2D(System.Double[],System.Double[],System.Double)">
      <summary>
            Compares two 2D points in the given domain.
            </summary>
      <param name="p1">First point</param>
      <param name="p2">Second point</param>
      <param name="domainSize">The 2D diagonal length of your model.</param>
      <returns>True if the two point are coincident, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.Intersect3DLines(devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,devDept.Geometry.Vector3D,System.Double@,System.Double@,devDept.Geometry.Point3D@)">
      <summary>
            Traces two lines in 3D.
            x0(s) = p0 + s * t0
            x1(t) = p1 + t * t1
            </summary>
      <param name="p0">Point on the first line</param>
      <param name="t0">First line direction</param>
      <param name="p1">Point on the second line</param>
      <param name="t1">Second line direction</param>
      <param name="s">Value of s at the intersection</param>
      <param name="t">Value of t at the intersection</param>
      <param name="i">Intersection point, x0(s) = i = x1(t)</param>
    </member>
    <member name="M:devDept.Geometry.Utility.ArcTanProblem(System.Double,System.Double)">
      <summary>
            See: http://hyperphysics.phy-astr.gsu.edu/hbase/ttrig.html
            </summary>
      <param name="x">
      </param>
      <param name="y">
      </param>
      <returns>The angle in radians</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.Compact(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{devDept.Geometry.IndexTriangle},devDept.Geometry.Point3D[]@)">
      <summary>
            Removes orphan vertices.
            </summary>
      <param name="original">The list of original vertices</param>
      <param name="triangles">The list of triangles</param>
      <param name="compacted">The list of compacted vertices</param>
      <returns>The number of orphan vertices removed.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.CompactNormals(System.Collections.Generic.IList{devDept.Geometry.Vector3D},System.Collections.Generic.IList{devDept.Geometry.IndexTriangle},devDept.Geometry.Vector3D[]@)">
      <summary>
            Removes orphan normals.
            </summary>
      <param name="original">The list of original normals</param>
      <param name="triangles">The list of triangles</param>
      <param name="compacted">The list of compacted normals</param>
      <returns>The number of orphan normals removed.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetProgress(System.Int32[],System.Int32[],System.Int32)">
      <summary>
            Gets progress value from parallel tasks.
            </summary>
      <param name="index">Current task index</param>
      <param name="startIndex">Current task start index</param>
      <param name="cpuCount">The number of logical processors</param>
      <returns>The progress value.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.KahanSum(System.Double[])">
      <summary>
            Kahan summation.
            </summary>
      <param name="input">The array of values to be summed.</param>
      <returns>The accurate summation.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.DoubleParseIges(System.String)">
      <summary>
        <para>Converts the string representation of a number to its double-precision
            equivalent in a culture invariant way. Before converting the number ending
            decimal dot is removed.</para>
        <para>Examples:</para>
        <list type="bullet">
          <item>
            <description>TheÂ ending dot of the string "1." is
            removed</description>
          </item>
          <item>
            <description>
            TheÂ ending dot of the string "2E-012." is removed</description>
          </item>
        </list>
      </summary>
      <param name="value">The string to convert</param>
      <returns>
            The converted value.
            </returns>
    </member>
    <member name="M:devDept.Geometry.Utility.DoubleParse(System.String)">
      <summary>
            Converts the string representation of a number to its double-precision equivalent in a culture invariant way.
            </summary>
      <param name="value">The string to convert</param>
      <returns>The converted value.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.FloatParse(System.String)">
      <summary>
            Converts the string representation of a number to its single-precision equivalent in a culture invariant way.
            </summary>
      <param name="value">The string to convert</param>
      <returns>The converted value.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.DoubleTryParse(System.String,System.Double@)">
      <summary>
            Converts the string representation of a number to its double-precision equivalent in a culture invariant way.
            </summary>
      <param name="value">The string to read</param>
      <param name="result">The converted value, if the method succeeded, 0 otherwise</param>
      <returns>True if the conversion succeeded, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetSupportedLinearUnits(devDept.Geometry.linearUnitsType)">
      <summary>
            Converts <see cref="T:devDept.Geometry.linearUnitsType" /> to <seealso cref="T:devDept.Geometry.supportedLinearUnitsType" /></summary>
      <param name="units">The <see cref="T:devDept.Geometry.linearUnitsType" /></param>
      <returns>The <see cref="T:devDept.Geometry.supportedLinearUnitsType" /></returns>
    </member>
    <member name="F:devDept.Geometry.Utility.LinearConversionFactors">
      <summary>
            Gets linear conversion factor between two <see cref="T:devDept.Geometry.linearUnitsType">units</see>.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Utility.GetLinearUnitsConversionFactor(devDept.Geometry.linearUnitsType,devDept.Geometry.linearUnitsType)">
      <summary>
            Gets the scale factor to use for the conversion between <see cref="T:devDept.Geometry.linearUnitsType" />s
            </summary>
      <param name="fromUnits">Initial unit</param>
      <param name="toUnits">Target unit</param>
      <returns>The conversion factor</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.GetSupportedMassUnits(devDept.Geometry.massUnitsType)">
      <summary>
            Converts <see cref="T:devDept.Geometry.massUnitsType" /> to <seealso cref="T:devDept.Geometry.supportedMassUnitsType" /></summary>
      <param name="units">The <see cref="T:devDept.Geometry.massUnitsType" /></param>
      <returns>The <see cref="T:devDept.Geometry.supportedMassUnitsType" /></returns>
    </member>
    <member name="F:devDept.Geometry.Utility.MassConversionFactors">
      <summary>
            Gets mass conversion factor between two <see cref="T:devDept.Geometry.massUnitsType">units</see>.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Utility.GetMassUnitsConversionFactor(devDept.Geometry.massUnitsType,devDept.Geometry.massUnitsType)">
      <summary>
            Gets the scale factor to use for the conversion between <see cref="T:devDept.Geometry.massUnitsType" />s
            </summary>
      <param name="fromUnits">Initial unit.</param>
      <param name="toUnits">Target unit.</param>
      <returns>The conversion factor.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.Simplify``1(System.Collections.Generic.IList{``0},System.Double)">
      <summary>
            Uses the Douglas Peucker algorithm to reduce the number of points.
            </summary>
      <param name="points">The list of 2D or 3D points</param>
      <param name="deviation">The maximum acceptable deviation value</param>
      <returns>The resulting array of 3D points</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.Intersection2D(devDept.Geometry.Point3D[],devDept.Geometry.Segment2D,System.Boolean)">
      <summary>
            Seek intersections between a polygonal chain and a segment.
            </summary>
      <param name="chain">The polygonal chain</param>
      <param name="segment">The segment</param>
      <param name="tIntersections">
            If true, T-intersections are considered; otherwise, they are ignored
            </param>
      <returns>True if at least one intersection is found, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Utility.Intersection2D(devDept.Geometry.Point3D[],devDept.Geometry.Point3D[],System.Boolean)">
      <summary>
            Seek intersections between two polygonal chains.
            </summary>
      <param name="chainA">The first polygonal chain</param>
      <param name="chainB">The second polygonal chain</param>
      <param name="tIntersections">
            If true, T-intersections are considered; otherwise, they are ignored
            </param>
      <returns>True if at least one intersection is found, false otherwise.</returns>
    </member>
    <member name="T:devDept.Geometry.PointExtender">
      <summary>Point3D Extender.</summary>
    </member>
    <member name="M:devDept.Geometry.PointExtender.IsOnCurve(devDept.Geometry.Point3D,devDept.Geometry.Entities.IGCurve,System.Double)">
      <summary>
            Checks if the point is on the specified IGCurve.
            </summary>
      <param name="igCurve">The igCurve to test</param>
      <param name="maxGap">The maximum accepted distance to consider the point on the igCurve</param>
      <returns>True if the distance between the point and the igCurve is smaller than maxGap, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.PointExtender.IsOnCurve(devDept.Geometry.Point3D,devDept.Geometry.Entities.IGCurve,System.Double,devDept.Geometry.Point3D@,System.Double@)">
      <summary>
            Checks if the point is on the specified IGCurve.
            </summary>
      <param name="igCurve">The igCurve to test</param>
      <param name="maxGap">The maximum accepted distance to consider the point on the igCurve</param>
      <param name="closestPt">Outputs the closest point on the igCurve</param>
      <param name="closestParam">Outputs the parameter along the igCurve corresponding to the closest point</param>
      <returns>True if the distance between the point and the igCurve is smaller than maxGap, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.PointExtender.EqualsExact(devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Performs an exact double comparison between the XYZ coordinates of two points.
            </summary>
      <param name="point">The first point to compare</param>
      <param name="other">The second point to compare</param>
      <returns>
            True if the X, Y, Z coordinates of the two points are exactly
            equal (evaluated using the equality operator '==').
            </returns>
    </member>
    <member name="T:devDept.Geometry.ClipperUtility">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="T:devDept.Geometry.booleanFailureType">
      <summary>
            Result for a boolean operation.
            </summary>
    </member>
    <member name="F:devDept.Geometry.booleanFailureType.NotIntersecting">
      <summary>
            The entities don't intersect.
            </summary>
    </member>
    <member name="F:devDept.Geometry.booleanFailureType.Failed">
      <summary>
            The operation failed.
            </summary>
    </member>
    <member name="F:devDept.Geometry.booleanFailureType.Success">
      <summary>
            The operation was successful.
            </summary>
    </member>
    <member name="T:devDept.Geometry.textureMappingType">
      <summary>Texture mapping type.</summary>
    </member>
    <member name="F:devDept.Geometry.textureMappingType.Plate">
      <summary>
            Applies material's texture only on top and bottom face with the same XY orientation
            </summary>
      <remarks>The texture is scaled to fit the smallest square containing the entity</remarks>
    </member>
    <member name="F:devDept.Geometry.textureMappingType.Cubic">
      <summary>
            Applies material's texture using cubic mapping
            </summary>
      <remarks>The texture is scaled to fit the smallest cube containing the entity</remarks>
    </member>
    <member name="F:devDept.Geometry.textureMappingType.Cylindrical">
      <summary>
            Applies material's texture using cylindrical mapping
            </summary>
      <remarks>The texture is is scaled to fit the side of the cylinder</remarks>
    </member>
    <member name="F:devDept.Geometry.textureMappingType.Spherical">
      <summary>
            Applies material's texture using spherical mapping
            </summary>
      <remarks>The texture is scaled to fit the smallest sphere containing the entity</remarks>
    </member>
    <member name="T:devDept.Geometry.IRegenParams">
      <summary>
            Common properties of ComputeTessellation() methods.
            </summary>
    </member>
    <member name="P:devDept.Geometry.IRegenParams.Deviation">
      <summary>
            Gets or sets the maximum deviation. Determines the value between the analytical gSurface and its triangulation. The lower is the deviation value, the more accurate is the result.
            </summary>
    </member>
    <member name="P:devDept.Geometry.IRegenParams.Angle">
      <summary>
            Gets or sets the maximum angular deflection in radians, ignored when zero.
            </summary>
      <remarks>This setting dictates the minimum number of facets around a smaller circle or cylinder regardless of the <see cref="P:devDept.Geometry.IRegenParams.Deviation" /> setting, and gives you added control over faces with very small radii. Lower values result in finer tessellations, while higher values give coarser tessellations.</remarks>
    </member>
    <member name="P:devDept.Geometry.IRegenParams.MaxLength">
      <summary>
            Gets or sets the maximum segment or triangle side length, ignored when zero.
            </summary>
    </member>
    <member name="T:devDept.Geometry.ComputeTessellationParams">
      <summary>
            Data for <see cref="M:devDept.Geometry.Entities.IGCurve.ComputeTessellation(devDept.Geometry.IRegenParams,devDept.Geometry.Point3D[]@)" /> and <see cref="M:devDept.Geometry.Entities.IGFace.ComputeTessellation(System.Double,devDept.Geometry.TessellationData@)" /> methods.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ComputeTessellationParams.#ctor(System.Double)">
      <summary>
            Deviation constructor.
            </summary>
      <param name="deviation">The maximum deviation.</param>
    </member>
    <member name="M:devDept.Geometry.ComputeTessellationParams.#ctor(System.Double,System.Double)">
      <summary>
            Deviation and angle constructor.
            </summary>
      <param name="deviation">The maximum deviation</param>
      <param name="angle">The maximum angular deflection in radians. Ignored when zero.</param>
    </member>
    <member name="M:devDept.Geometry.ComputeTessellationParams.#ctor(System.Double,System.Double,System.Double)">
      <summary>
            Deviation and angle constructor.
            </summary>
      <param name="deviation">The maximum deviation</param>
      <param name="angle">The maximum angular deflection in radians. Ignored when zero.</param>
    </member>
    <member name="P:devDept.Geometry.ComputeTessellationParams.Deviation">
      <summary>
            Gets or sets the maximum deviation. Determines the value between the analytical gSurface and its triangulation. The lower is the deviation value, the more accurate is the result.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ComputeTessellationParams.Angle">
      <summary>
            Gets or sets the maximum angular deflection in radians, ignored when zero.
            </summary>
      <remarks>This setting dictates the minimum number of facets around a smaller circle or cylinder regardless of the <see cref="P:devDept.Geometry.ComputeTessellationParams.Deviation" /> setting, and gives you added control over faces with very small radii. Lower values result in finer tessellations, while higher values give coarser tessellations.</remarks>
    </member>
    <member name="P:devDept.Geometry.ComputeTessellationParams.MaxLength">
      <summary>
            Gets or sets the maximum segment or triangle side length, ignored when zero.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ComputeTessellationParams.CloneVertices">
      <summary>
            Clone vertices if needed (for <see cref="T:devDept.Geometry.Entities.IGCurve" /> only).
            </summary>
    </member>
    <member name="T:devDept.Geometry.TessellationData">
      <summary>
            Class that holds the tessellation data of an IFace Entity.
            </summary>
    </member>
    <member name="P:devDept.Geometry.TessellationData.Tessellation">
      <summary>
            Gets or sets the vertices and triangles
            </summary>
    </member>
    <member name="P:devDept.Geometry.TessellationData.Edges">
      <summary>
            Gets or sets the edges vertices
            </summary>
    </member>
    <member name="P:devDept.Geometry.TessellationData.IsoCurves">
      <summary>
            Gets or sets the iso curves vertices
            </summary>
    </member>
    <member name="T:devDept.Geometry.Triangulation.Delaunay">
      <summary>
            Triangulation by Delaunay method.
            </summary>
      <seealso cref="T:devDept.Geometry.Triangulation.EarClipping">EarClipping Class</seealso>
      <seealso cref="T:devDept.Geometry.Triangulation.Mesher">Mesher Class</seealso>
    </member>
    <member name="P:devDept.Geometry.Triangulation.Delaunay.TriangulatingText">
      <summary>
            Gets or sets the progress bar text displayed when executed asynchronously.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Triangulation.Delaunay.brMin">
      <summary>
            Min corner of the problem bounding rectangle.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Triangulation.Delaunay.brRange">
      <summary>
            Size of the bounding rectangle.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Triangulation.Delaunay.Result">
      <summary>
            Gets the resulting mesh.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Triangulation.Delaunay.OutputType">
      <summary>
            Gets or sets the triangulation output type.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Triangulation.Delaunay.#ctor(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{System.Collections.Generic.IList{devDept.Geometry.Point3D}})">
      <summary>
            Loops only constructor.
            </summary>
      <param name="outer">The outer loop (oriented counter-clockwise), can be null/Nothing.</param>
      <param name="inners">The inner loops (oriented clockwise), can be null/Nothing.</param>
    </member>
    <member name="M:devDept.Geometry.Triangulation.Delaunay.#ctor(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{System.Collections.Generic.IList{devDept.Geometry.Point3D}})">
      <summary>
            Points/loops constructor.
            </summary>
      <param name="points">The list of point to be triangulated, can be null/Nothing.</param>
      <param name="outer">The outer loop (oriented counter-clockwise). Must be closed. Can be null/Nothing.</param>
      <param name="inners">The inner loops list  (oriented clockwise). Must be closed. Can be null/Nothing.</param>
    </member>
    <member name="M:devDept.Geometry.Triangulation.Delaunay.#ctor(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{System.Collections.Generic.IList{devDept.Geometry.Point3D}},System.Collections.Generic.IList{System.Collections.Generic.IList{devDept.Geometry.Point3D}})">
      <summary>
            Points/loops constructor.
            </summary>
      <param name="points">The list of point to be triangulated, can be null/Nothing.</param>
      <param name="outer">The outer loop (oriented counter-clockwise). Must be closed. Can be null/Nothing.</param>
      <param name="inners">The inner loops list  (oriented clockwise). Must be closed. Can be null/Nothing.</param>
      <param name="internals">The internal curve list. Can be open. Can be null/Nothing.</param>
    </member>
    <member name="M:devDept.Geometry.Triangulation.Delaunay.#ctor(System.Collections.Generic.IList{devDept.Geometry.Point3D})">
      <summary>
            Points only constructor.
            </summary>
      <param name="points">The list of point to be triangulated</param>
    </member>
    <member name="M:devDept.Geometry.Triangulation.Delaunay.Triangulate(devDept.Geometry.Point3D[]@,devDept.Geometry.IndexTriangle[]@)">
      <summary>
            Performs triangulation.
            </summary>
      <param name="ecVertices">Resulting vertices</param>
      <param name="ecTriangles">Resulting triangles</param>
    </member>
    <member name="M:devDept.Geometry.Triangulation.Delaunay.ProcessTriangulation(System.Int32,System.Int32,System.String,System.Boolean,System.ComponentModel.BackgroundWorker,System.ComponentModel.DoWorkEventArgs)">
      <summary>
            Triangulate the points with indices between startFrom and endAt indices.
            </summary>
      <param name="startFrom">Start index</param>
      <param name="endAt">End index</param>
      <param name="title">Update progress message</param>
      <param name="checkInside">Checks if cavity triangles to be added are inside the loops</param>
      <param name="worker">Worker thread</param>
      <param name="doWorkEventArgs">Worker thread do work event arguments</param>
      <returns>True if the triangulation is successful.</returns>
    </member>
    <member name="T:devDept.Geometry.Triangulation.EarClipping">
      <summary>
            2D triangulation by Ear Clipping method.
            </summary>
      <seealso cref="T:devDept.Geometry.Triangulation.Delaunay">Delaunay Class</seealso>
      <seealso cref="T:devDept.Geometry.Triangulation.Mesher">Mesher Class</seealso>
    </member>
    <member name="M:devDept.Geometry.Triangulation.EarClipping.#ctor(System.Collections.Generic.IList{devDept.Geometry.Point2D},System.Collections.Generic.IList{System.Collections.Generic.IList{devDept.Geometry.Point2D}},System.Boolean)">
      <summary>
            Point2D loops constructor.
            </summary>
      <param name="outerLoop">The outer loop (oriented counter-clockwise)</param>
      <param name="innerLoops">The inner loops list (oriented clockwise). Can be null/Nothing.</param>
      <param name="checkDir">If true, loops orientation is checked and reversed if necessary.</param>
    </member>
    <member name="M:devDept.Geometry.Triangulation.EarClipping.Triangulate(devDept.Geometry.Point2D[]@,devDept.Geometry.IndexTriangle[]@)">
      <summary>
            Performs triangulation and output result in the <paramref name="ecVertices" /> and <paramref name="ecTriangles" /> arrays.
            </summary>
      <param name="ecVertices">The vertices array</param>
      <param name="ecTriangles">The triangles array</param>
    </member>
    <member name="M:devDept.Geometry.Triangulation.EarClipping.Triangulate(devDept.Geometry.Entities.GMesh.natureType)">
      <summary>
            Performs triangulation and output result in a ready to use <see cref="T:devDept.Geometry.Entities.GMesh" /> entity.
            </summary>
      <param name="meshNature">The desired mesh nature</param>
      <returns>The mesh object.</returns>
    </member>
    <member name="M:devDept.Geometry.Triangulation.EarClipping.WriteXML(System.String,System.Collections.Generic.IList{devDept.Geometry.Point2D},System.Collections.Generic.IList{System.Collections.Generic.IList{devDept.Geometry.Point2D}})">
      <summary>
            Write the EarClipping contours to an XML file for debugging purpose.
            </summary>
      <param name="fileName">The file name</param>
      <param name="outer">The outer contour</param>
      <param name="inners">The inner contours</param>
    </member>
    <member name="M:devDept.Geometry.Triangulation.EarClipping.#ctor(System.String)">
      <summary>
            Loops contructor that loads the contours from a XML file generated by <see cref="M:devDept.Geometry.Triangulation.EarClipping.WriteXML(System.String,System.Collections.Generic.IList{devDept.Geometry.Point2D},System.Collections.Generic.IList{System.Collections.Generic.IList{devDept.Geometry.Point2D}})" /> method, for debugging purpose.
            </summary>
      <param name="fileName">The file name</param>
    </member>
    <member name="T:devDept.Geometry.Triangulation.mesherSmoothingType">
      <summary>
            GMesh smoothing type.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Triangulation.mesherSmoothingType.Laplacian">
      <summary>
            Laplacian
            </summary>
    </member>
    <member name="F:devDept.Geometry.Triangulation.mesherSmoothingType.AreaCentroidWeighted">
      <summary>
            Area centroid weighted
            </summary>
    </member>
    <member name="T:devDept.Geometry.Triangulation.Mesher">
      <summary>
        <para>2D meshing.</para>
        <para>Mesher class is deprecated, please use <see cref="!:UtilityEx.Triangulate(IList&lt;Point3D&gt;, IList&lt;IList&lt;Point3D&gt;&gt;, IList&lt;Point3D&gt;, IList&lt;Segment3D&gt;)" /> method instead.</para>
      </summary>
      <seealso cref="T:devDept.Geometry.Triangulation.EarClipping">EarClipping Class</seealso>
      <seealso cref="T:devDept.Geometry.Triangulation.Delaunay">Delaunay Class</seealso>
      <example>
            The following sample summarizes the steps needed to perform an asynchronous composite curve meshing.
            <code lang="CS">
            public partial class Form1 : Form
             {
             
                 public Form1()
                 {	
                     InitializeComponent();
                     // adds event handler for WorkCompleted event
                     viewport1.WorkCompleted += new Viewport.WorkCompletedEventHandler(viewport1_WorkCompleted);
                 }
              
                 protected override void OnShown(EventArgs e)
                 {
              
                     viewport1.DisplayMode = displayType.Shaded;
              
                     CompositeCurve outer = new CompositeCurve();
              
                     outer.CurveList.Add(new Line(0, 0, 10, 0));
                     outer.CurveList.Add(new Line(10, 0, 10, 6));
                     outer.CurveList.Add(new Line(10, 6, 0, 6));
                     outer.CurveList.Add(new Line(0, 6, 0, 0));
              
                     CompositeCurve inner1 = new CompositeCurve();
              
                     inner1.CurveList.Add(new Line(2, 2, 6, 2));
                     inner1.CurveList.Add(new Line(6, 2, 2, 3));
                     inner1.CurveList.Add(new Line(2, 3, 2, 2));
              
                     CompositeCurve inner2 = new CompositeCurve();
              
                     inner2.CurveList.Add(new Circle(8, 4, 0, 1));
              
                     CompositeCurve inner3 = new CompositeCurve();
              
                     inner3.CurveList.Add(new Circle(6, 4, 0, .75));
              
                     Mesher me = new Mesher(outer, new CompositeCurve[] { inner1, inner2, inner3 }, .15, mesherSmoothingType.AreaCentroidWeighted, 2);
              
                     viewport1.StartWork(me);
              
                     base.OnShown(e);
              
                 }
              
                 public void viewport1_WorkCompleted(object sender, WorkCompletedEventArgs e)
                 {
              
                     // checks the WorkUnit type, more than one can be present in the same application 
                     if (e.WorkUnit is Mesher)
                     {
              
                         Mesher me = (Mesher)e.WorkUnit;
              
                         GMesh m = me.Result;
              
                         // adds the mesh to the viewport
                         viewport1.Entities.Add(m, 0, Color.Coral);
            
                         viewport1.SetView(viewType.Trimetric);
                         viewport1.ZoomFit();
                         viewport1.Invalidate();
              
                     }
              
                 }
              
             }</code><code lang="VB.NET">
            Public Partial Class Form1
             	Inherits Form
              
            	Public Sub New()
             
            		InitializeComponent()
             
            		' adds event handler for WorkCompleted event
            		Viewport1.WorkCompleted += New Viewport.WorkCompletedEventHandler(Viewport1_WorkCompleted)
             
            	End Sub
              
             	Protected Overrides Sub OnShown(e As EventArgs)
              
             		Viewport1.DisplayMode = displayType.Shaded
              
             		Dim outer As New CompositeCurve()
              
             		outer.CurveList.Add(New Line(0, 0, 10, 0))
             		outer.CurveList.Add(New Line(10, 0, 10, 6))
             		outer.CurveList.Add(New Line(10, 6, 0, 6))
             		outer.CurveList.Add(New Line(0, 6, 0, 0))
              
             		Dim inner1 As New CompositeCurve()
              
             		inner1.CurveList.Add(New Line(2, 2, 6, 2))
             		inner1.CurveList.Add(New Line(6, 2, 2, 3))
             		inner1.CurveList.Add(New Line(2, 3, 2, 2))
              
             		Dim inner2 As New CompositeCurve()
              
             		inner2.CurveList.Add(New Circle(8, 4, 0, 1))
              
             		Dim inner3 As New CompositeCurve()
              
             		inner3.CurveList.Add(New Circle(6, 4, 0, 0.75))
              
             		Dim [me] As New Mesher(outer, New CompositeCurve() {inner1, inner2, inner3}, 0.15, mesherSmoothingType.AreaCentroidWeighted, 2)
              
             		Viewport1.StartWork([me])
              
             		MyBase.OnShown(e)
              
             	End Sub
              
             	Public Sub Viewport1_WorkCompleted(sender As Object, e As WorkCompletedEventArgs)
              
             		' checks the WorkUnit type, more than one can be present in the same application 
             		If TypeOf e.WorkUnit Is Mesher Then
              
             			Dim [me] As Mesher = DirectCast(e.WorkUnit, Mesher)
              
             			Dim m As GMesh = [me].Result
              
             			' adds the mesh to the viewport
              
             			Viewport1.Entities.Add(m, 0, Color.Coral)
            
                        Viewport1.SetView(viewType.Trimetric)
                        Viewport1.ZoomFit()
                        Viewport1.Invalidate()
            
             		End If
              
             	End Sub
              
             End Class</code></example>
    </member>
    <member name="P:devDept.Geometry.Triangulation.Mesher.SmoothingText">
      <summary>
            Gets or sets the progress bar text displayed when executed asynchronously.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Triangulation.Mesher.ComputeMeshQuality">
      <summary>
            If <b>true</b>, mesh quality will be computed.
            </summary>
      <remarks>GMesh quality computation will increase meshing time.</remarks>
    </member>
    <member name="M:devDept.Geometry.Triangulation.Mesher.#ctor(devDept.Geometry.Entities.IGCurve,System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Double)">
      <summary>
            Element size constructor.
            </summary>
      <param name="outer">The outer loop. Must be closed.</param>
      <param name="inners">The inner loops list. Can contain open loops (after closed ones). Can be null/Nothing.</param>
      <param name="elementSize">The element size</param>
    </member>
    <member name="M:devDept.Geometry.Triangulation.Mesher.#ctor(devDept.Geometry.Entities.GRegion,System.Double)">
      <summary>
            Element size constructor.
            </summary>
      <param name="region">The region to triangulate</param>
      <param name="elementSize">The element size</param>
    </member>
    <member name="M:devDept.Geometry.Triangulation.Mesher.#ctor(devDept.Geometry.Entities.IGCurve,System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Double)">
      <summary>
            Element size and internal curves constructor.
            </summary>
      <param name="outer">The outer loop. Must be closed.</param>
      <param name="inners">The inner loops list. Must be closed. Can be null/Nothing.</param>
      <param name="internals">The internal curve list. Can be open. Can be null/Nothing.</param>
      <param name="elementSize">The element size</param>
    </member>
    <member name="M:devDept.Geometry.Triangulation.Mesher.#ctor(devDept.Geometry.Entities.IGCurve,System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Double,devDept.Geometry.Triangulation.mesherSmoothingType,System.Int32)">
      <summary>
            Element size and smoothing control constructor.
            </summary>
      <param name="outer">The outer loop. Must be closed.</param>
      <param name="inners">The inner loops list. Must be closed. Can be null/Nothing.</param>
      <param name="elementSize">The element size</param>
      <param name="smoothingMode">The smoothing mode</param>
      <param name="smoothingPasses">Number of smoothing passes</param>
    </member>
    <member name="M:devDept.Geometry.Triangulation.Mesher.#ctor(devDept.Geometry.Entities.GRegion,System.Double,devDept.Geometry.Triangulation.mesherSmoothingType,System.Int32)">
      <summary>
            Element size and smoothing control constructor.
            </summary>
      <param name="region">The region to triangulate</param>
      <param name="elementSize">The element size</param>
      <param name="smoothingMode">The smoothing mode</param>
      <param name="smoothingPasses">Number of smoothing passes</param>
    </member>
    <member name="M:devDept.Geometry.Triangulation.Mesher.#ctor(devDept.Geometry.Entities.IGCurve,System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Double,devDept.Geometry.Triangulation.mesherSmoothingType,System.Int32)">
      <summary>
            Smoothing control constructor.
            </summary>
      <param name="outer">The outer loop. Must be closed.</param>
      <param name="inners">The inner loops list. Must be closed. Can be null/Nothing.</param>
      <param name="internals">The internal curve list. Can be open. Can be null/Nothing.</param>
      <param name="elementSize">The element size</param>
      <param name="smoothingMode">The smoothing mode</param>
      <param name="smoothingPasses">Number of smoothing passes</param>
    </member>
    <member name="M:devDept.Geometry.Triangulation.Mesher.AddPointsAlongEdge(devDept.Geometry.IndexLine,System.Int32@)">
      <summary>
            Adds points along the edge if possible (not too close to the others).
            </summary>
    </member>
    <member name="T:devDept.Geometry.QuadraticTriangle">
      <summary>
            Six-noded triangle class definition.
            </summary>
    </member>
    <member name="F:devDept.Geometry.QuadraticTriangle.V4">
      <summary>
            The first mid-side vertex (between <see cref="F:devDept.Geometry.IndexLine.V1" /> and <see cref="F:devDept.Geometry.IndexLine.V2" />)
            </summary>
    </member>
    <member name="F:devDept.Geometry.QuadraticTriangle.V5">
      <summary>
            The second mid-side vertex (between <see cref="F:devDept.Geometry.IndexLine.V2" /> and <see cref="F:devDept.Geometry.IndexTriangle.V3" />)
            </summary>
    </member>
    <member name="F:devDept.Geometry.QuadraticTriangle.V6">
      <summary>
            The third mid-side vertex (between <see cref="F:devDept.Geometry.IndexTriangle.V3" /> and <see cref="F:devDept.Geometry.IndexLine.V1" />)
            </summary>
    </member>
    <member name="M:devDept.Geometry.QuadraticTriangle.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Standard constructor.
            </summary>
      <param name="v1">Index of the first triangle vertex</param>
      <param name="v2">Index of the second triangle vertex</param>
      <param name="v3">Index of the third triangle vertex</param>
      <param name="v4">Index of the first mid-side vertex (between <paramref name="v1" /> and <paramref name="v2" />)</param>
      <param name="v5">Index of the second mid-side vertex (between <paramref name="v2" /> and <paramref name="v3" />)</param>
      <param name="v6">Index of the third mid-side vertex (between <paramref name="v3" /> and <paramref name="v1" />)</param>
    </member>
    <member name="T:devDept.Geometry.Converters.IndexTriangleConverter">
      <exclude />
      <excludetoc />
    </member>
    <member name="M:devDept.Geometry.Converters.IndexTriangleConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
      <exclude />
    </member>
    <member name="T:devDept.Geometry.Converters.ushortHexTypeConverter">
      <exclude />
      <excludetoc />
    </member>
    <member name="T:devDept.Geometry.Converters.Point3DConverter">
      <exclude />
      <excludetoc />
    </member>
    <member name="M:devDept.Geometry.Converters.Point3DConverter.CanConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Type)">
      <exclude />
    </member>
    <member name="M:devDept.Geometry.Converters.Point3DConverter.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
      <exclude />
    </member>
    <member name="M:devDept.Geometry.Converters.Point3DConverter.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
      <exclude />
    </member>
    <member name="M:devDept.Geometry.Converters.Point3DConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
      <exclude />
    </member>
    <member name="T:devDept.Geometry.Converters.Point2DConverter">
      <exclude />
      <excludetoc />
    </member>
    <member name="T:devDept.Geometry.Converters.Point4DConverter">
      <exclude />
      <excludetoc />
    </member>
    <member name="M:devDept.Geometry.Converters.Point4DConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
      <exclude />
    </member>
    <member name="T:devDept.Geometry.Converters.QuaternionConverter">
      <exclude />
      <excludetoc />
    </member>
    <member name="T:devDept.Geometry.Converters.PlaneConverter">
      <exclude />
      <excludetoc />
    </member>
    <member name="T:devDept.Geometry.Converters.Vector2DConverter">
      <exclude />
      <excludetoc />
    </member>
    <member name="T:devDept.Geometry.Converters.Vector3DConverter">
      <exclude />
      <excludetoc />
    </member>
    <member name="M:devDept.Geometry.Converters.Vector3DConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
      <exclude />
    </member>
    <member name="T:devDept.Geometry.Converters.PlaneEquationConverter">
      <exclude />
      <excludetoc />
    </member>
    <member name="M:devDept.Geometry.Converters.PlaneEquationConverter.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
      <exclude />
    </member>
    <member name="T:devDept.Geometry.UtilityMacros">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.UtilityMacros.CROSS(System.Double[]@,System.Double[],System.Double[])">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.UtilityMacros.DOT(System.Double[],System.Double[])">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.UtilityMacros.SUB(System.Double[]@,System.Double[],System.Double[])">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.UtilityMacros.TRANSFORM(System.Double[]@,devDept.Geometry.Transformation)">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.UtilityMacros.NORMALIZE(System.Double[]@)">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="T:devDept.Geometry.PointNormalUv">
      <summary>
            Surface point definition.
            </summary>
    </member>
    <member name="F:devDept.Geometry.PointNormalUv.Nx">
      <summary>
            Normal X component. 
            </summary>
    </member>
    <member name="F:devDept.Geometry.PointNormalUv.Ny">
      <summary>
            Normal Y component.
            </summary>
    </member>
    <member name="F:devDept.Geometry.PointNormalUv.Nz">
      <summary>
            Normal Z component.
            </summary>
    </member>
    <member name="F:devDept.Geometry.PointNormalUv.PlotValue">
      <summary>
            Plot value.
            </summary>
    </member>
    <member name="F:devDept.Geometry.PointNormalUv.ColorIndex">
      <summary>
            Color index.
            </summary>
    </member>
    <member name="F:devDept.Geometry.PointNormalUv.Index">
      <summary>
            Nurbs surface triangulation Steiner point index.
            </summary>
    </member>
    <member name="M:devDept.Geometry.PointNormalUv.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            3D position and parametric values constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.PointNormalUv.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            3D position and normal constructor.
            </summary>
    </member>
    <member name="P:devDept.Geometry.PointNormalUv.Normal">
      <summary>
            Get surface normal.
            </summary>
    </member>
    <member name="T:devDept.Geometry.MomentOfInertia">
      <summary>
            Moment of inertia and radii of gyration values.
            </summary>
    </member>
    <member name="F:devDept.Geometry.MomentOfInertia.Ix">
      <summary>
            Moments of inertia about X coordinate axis.
            </summary>
    </member>
    <member name="F:devDept.Geometry.MomentOfInertia.Iy">
      <summary>
            Moments of inertia about Y coordinate axis.
            </summary>
    </member>
    <member name="F:devDept.Geometry.MomentOfInertia.Iz">
      <summary>
            Moments of inertia about Z coordinate axis.
            </summary>
    </member>
    <member name="F:devDept.Geometry.MomentOfInertia.Rx">
      <summary>
            Radii of gyration about X coordinate axis.
            </summary>
    </member>
    <member name="F:devDept.Geometry.MomentOfInertia.Ry">
      <summary>
            Radii of gyration about Y coordinate axis.
            </summary>
    </member>
    <member name="F:devDept.Geometry.MomentOfInertia.Rz">
      <summary>
            Radii of gyration about Z coordinate axis.
            </summary>
    </member>
    <member name="T:devDept.Geometry.AreaAndVolume">
      <summary>
            Base class for area and volume properties calculation.
            </summary>
    </member>
    <member name="P:devDept.Geometry.AreaAndVolume.Centroid">
      <summary>
            Gets centroid.
            </summary>
    </member>
    <member name="M:devDept.Geometry.AreaAndVolume.GetResultsAboutWorld(System.Double,System.Double)">
      <summary>
            This method is called to obtain the results.
            </summary>
      <param name="m">Mass</param>
    </member>
    <member name="M:devDept.Geometry.AreaAndVolume.GetResultsAboutCentroid(System.Double,devDept.Geometry.Point3D,System.Double)">
      <summary>
            This method is called to obtain the results.
            </summary>
      <param name="m">Mass</param>
      <param name="C">3D centroid</param>
    </member>
    <member name="T:devDept.Geometry.AreaProperties">
      <summary>
            Area properties of a 2D polygon or area properties of a solid defined by a triangle mesh.
            </summary>
    </member>
    <member name="P:devDept.Geometry.AreaProperties.Area">
      <summary>
            Gets area.
            </summary>
    </member>
    <member name="P:devDept.Geometry.AreaProperties.Centroid">
      <summary>
            Gets centroid.
            </summary>
    </member>
    <member name="M:devDept.Geometry.AreaProperties.#ctor">
      <summary>
            Empy constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.AreaProperties.#ctor(System.Collections.Generic.IList{devDept.Geometry.Point3D})">
      <summary>
            2D polygon constructor.
            </summary>
      <param name="vList">Polygon 2D vertices</param>
    </member>
    <member name="M:devDept.Geometry.AreaProperties.#ctor(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{devDept.Geometry.IndexTriangle})">
      <summary>
            3D face constructor.
            </summary>
      <param name="vList">Vertices</param>
      <param name="tList">Triangles</param>
    </member>
    <member name="M:devDept.Geometry.AreaProperties.Add(System.Collections.Generic.IList{devDept.Geometry.Point3D})">
      <summary>
            Accumulates additional 2D segments.
            </summary>
      <param name="vList">Polygon 2D vertices</param>
    </member>
    <member name="M:devDept.Geometry.AreaProperties.Add(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{devDept.Geometry.IndexTriangle})">
      <summary>
            Accumulate additional triangles.
            </summary>
      <param name="vList">Vertices</param>
      <param name="tList">Triangles</param>
    </member>
    <member name="M:devDept.Geometry.AreaProperties.GetResults(System.Double,devDept.Geometry.Point3D,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,devDept.Geometry.MomentOfInertia@,devDept.Geometry.MomentOfInertia@)">
      <summary>
            This method is called to obtain the results.
            </summary>
      <param name="a">Area</param>
      <param name="C">Centroid</param>
      <param name="X">First moment X</param>
      <param name="Y">First moment Y</param>
      <param name="Z">First moment Z</param>
      <param name="XX">Second moment X</param>
      <param name="YY">Second moment Y</param>
      <param name="ZZ">Second moment Z</param>
      <param name="XY">Product moment XY</param>
      <param name="ZX">Product moment ZX</param>
      <param name="YZ">Product moment YZ</param>
      <param name="world">Moments of Inertia about world coordinate axes</param>
      <param name="centroid">Area Moments of Inertia about centroid coordinate axes</param>
    </member>
    <member name="T:devDept.Geometry.VolumeProperties">
      <summary>
            Volume properties of a solid defined by a triangle mesh.
            </summary>
    </member>
    <member name="P:devDept.Geometry.VolumeProperties.Volume">
      <summary>
            Gets solid mass.
            </summary>
    </member>
    <member name="P:devDept.Geometry.VolumeProperties.Centroid">
      <summary>
            Gets solid centroid.
            </summary>
    </member>
    <member name="M:devDept.Geometry.VolumeProperties.#ctor">
      <summary>
            Empty constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.VolumeProperties.#ctor(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{devDept.Geometry.IndexTriangle})">
      <summary>
            Triangle list constructor.
            </summary>
      <param name="vList">Vertices</param>
      <param name="tList">Triangles</param>
    </member>
    <member name="M:devDept.Geometry.VolumeProperties.Add(System.Collections.Generic.IList{devDept.Geometry.Point3D},System.Collections.Generic.IList{devDept.Geometry.IndexTriangle})">
      <summary>
            Accumulates additional triangles.
            </summary>
      <param name="vList">Vertices</param>
      <param name="tList">Triangles</param>
    </member>
    <member name="M:devDept.Geometry.VolumeProperties.GetResults(System.Double,devDept.Geometry.Point3D,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,devDept.Geometry.MomentOfInertia@,devDept.Geometry.MomentOfInertia@)">
      <summary>
            This method is called to obtain the results.
            </summary>
      <param name="m">Mass</param>
      <param name="C">Centroid</param>
      <param name="X">First moment X</param>
      <param name="Y">First moment Y</param>
      <param name="Z">First moment Z</param>
      <param name="XX">Second moment X</param>
      <param name="YY">Second moment Y</param>
      <param name="ZZ">Second moment Z</param>
      <param name="XY">Product moment XY</param>
      <param name="ZX">Product moment ZX</param>
      <param name="YZ">Product moment YZ</param>
      <param name="world">Moments of Inertia about world coordinate axes</param>
      <param name="centroid">Area Moments of Inertia about centroid coordinate axes</param>
    </member>
    <member name="T:devDept.Geometry.IndexLineComparer">
      <summary>
            Compares two <see cref="T:devDept.Geometry.IndexLine" /> objects. 
            </summary>
    </member>
    <member name="T:devDept.Geometry.Equation">
      <summary>
            System of equations, equation definition.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Equation.Coefficients">
      <summary>
            Non zero coefficients.
            </summary>
    </member>
    <member name="T:devDept.Geometry.Coefficient">
      <summary>
            System of equations, equation non zero term definition.
            </summary>
    </member>
    <member name="T:devDept.Geometry.PointUv">
      <summary>
            Surface point definition.
            </summary>
    </member>
    <member name="F:devDept.Geometry.PointUv.V">
      <summary>
            Parametric V value
            </summary>
    </member>
    <member name="M:devDept.Geometry.PointUv.ToString">
      <summary>
            Converts this 3D point to a human readable string.
            </summary>
      <returns>A string that represents this 3D point.</returns>
    </member>
    <member name="T:devDept.Geometry.PointTangent">
      <summary>
            3D point and tangent definition.
            </summary>
    </member>
    <member name="F:devDept.Geometry.PointTangent.Tx">
      <summary>
            Tangent's X component. 
            </summary>
    </member>
    <member name="F:devDept.Geometry.PointTangent.Ty">
      <summary>
            Tangent's Y component.
            </summary>
    </member>
    <member name="F:devDept.Geometry.PointTangent.Tz">
      <summary>
            Tangent's Z component
            </summary>
    </member>
    <member name="M:devDept.Geometry.PointTangent.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.PointTangent.Clone">
      <summary>
            Creates a deep copy of this point.
            </summary>
      <returns>The new intersection point object.</returns>
    </member>
    <member name="P:devDept.Geometry.PointTangent.Tangent">
      <summary>
            Gets or sets the 3D tangent associated to this 3D point.
            </summary>
    </member>
    <member name="T:devDept.Geometry.PointTangentU">
      <summary>
            3D point, tangent and U definition.
            </summary>
    </member>
    <member name="F:devDept.Geometry.PointTangentU.U">
      <summary>
            Parametric U value
            </summary>
    </member>
    <member name="M:devDept.Geometry.PointTangentU.Clone">
      <summary>
            Creates a deep copy of this point.
            </summary>
      <returns>The new intersection point object.</returns>
    </member>
    <member name="T:devDept.Geometry.PointNormal">
      <summary>
            Point cloud point definition.
            </summary>
    </member>
    <member name="F:devDept.Geometry.PointNormal.Nx">
      <summary>
            Normal's X component. 
            </summary>
    </member>
    <member name="F:devDept.Geometry.PointNormal.Ny">
      <summary>
            Normal's Y component.
            </summary>
    </member>
    <member name="F:devDept.Geometry.PointNormal.Nz">
      <summary>
            Normal's Z component
            </summary>
    </member>
    <member name="M:devDept.Geometry.PointNormal.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="P:devDept.Geometry.PointNormal.Normal">
      <summary>
            Gets or sets the 3D normal associated to this 3D point.
            </summary>
    </member>
    <member name="T:devDept.Geometry.SharedEdge">
      <summary>
            Shared edge definition.
            </summary>
      <seealso cref="M:devDept.Geometry.Utility.GetEdgesWithoutDuplicates(System.Collections.Generic.IList{devDept.Geometry.IndexTriangle},System.Int32)" />
    </member>
    <member name="F:devDept.Geometry.SharedEdge.V2">
      <summary>
            Other edge vertex index.
            </summary>
    </member>
    <member name="F:devDept.Geometry.SharedEdge.Mum">
      <summary>
            Index of the first triangle that shares this edge.
            </summary>
    </member>
    <member name="F:devDept.Geometry.SharedEdge.Dad">
      <summary>
            Index of the second triangle that shares this edge.
            </summary>
    </member>
    <member name="T:devDept.Geometry.SharedFace">
      <summary>
            Shared face definition.
            </summary>
      <seealso cref="M:devDept.Geometry.Utility.GetEdgesWithoutDuplicates(System.Int32[0:,0:],System.Int32)" />
    </member>
    <member name="F:devDept.Geometry.SharedFace.V2">
      <summary>
            Other face second vertex index.
            </summary>
    </member>
    <member name="F:devDept.Geometry.SharedFace.V3">
      <summary>
            Other face third vertex index.
            </summary>
    </member>
    <member name="F:devDept.Geometry.SharedFace.V4">
      <summary>
            Other face fourth vertex index.
            </summary>
    </member>
    <member name="F:devDept.Geometry.SharedFace.Mum">
      <summary>
            Index of the first triangle that shares this edge.
            </summary>
    </member>
    <member name="F:devDept.Geometry.SharedFace.Dad">
      <summary>
            Index of the second triangle that shares this edge.
            </summary>
    </member>
    <member name="T:devDept.Geometry.lineWeightUnitsType">
      <summary>
            Line weight unit system type.
            </summary>
    </member>
    <member name="F:devDept.Geometry.lineWeightUnitsType.Inches">
      <summary>
            Inches
            </summary>
    </member>
    <member name="F:devDept.Geometry.lineWeightUnitsType.Millimeters">
      <summary>
            Millimeters
            </summary>
    </member>
    <member name="F:devDept.Geometry.lineWeightUnitsType.Default">
      <summary>
            Export all line weight values as default.
            </summary>
    </member>
    <member name="T:devDept.Geometry.linearUnitsType">
      <summary>
            Linear (length) unit system type.
            </summary>
      <remarks>
        <seealso cref="M:devDept.Geometry.Utility.GetLinearUnitsConversionFactor(devDept.Geometry.linearUnitsType,devDept.Geometry.linearUnitsType)" />
      </remarks>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.Unitless">
      <summary>
            Unit system not specified
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.Inches">
      <summary>
            Inches
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.Feet">
      <summary>
            Feet
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.Miles">
      <summary>
            Miles
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.Millimeters">
      <summary>
            Millimeters
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.Centimeters">
      <summary>
            Centimeters
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.Meters">
      <summary>
            Meters
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.Kilometers">
      <summary>
            Kilometers
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.Microinches">
      <summary>
            Microinches
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.Mils">
      <summary>
            Mils (i.e., 0.001 inch) 
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.Yards">
      <summary>
            Yards
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.Angstroms">
      <summary>
            Angstroms
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.Nanometers">
      <summary>
            Nanometers
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.Microns">
      <summary>
            Microns
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.Decimeters">
      <summary>
            Decimeters
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.Decameters">
      <summary>
            Decameters
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.Hectometers">
      <summary>
            Hectometers
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.Gigameters">
      <summary>
            Gigameters
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.Astronomical">
      <summary>
            Astronomical units
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.LightYears">
      <summary>
            LightYears
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.Parsecs">
      <summary>
            Parsecs
            </summary>
    </member>
    <member name="F:devDept.Geometry.linearUnitsType.NotSupported">
      <summary>
            The unit system of the imported geometry is not supported by Eyeshot
            </summary>
    </member>
    <member name="T:devDept.Geometry.supportedLinearUnitsType">
      <summary>
            Supported linear (length) unit.
            </summary>
      <remarks>
        <seealso cref="M:devDept.Geometry.Utility.GetSupportedLinearUnits(devDept.Geometry.linearUnitsType)" />
      </remarks>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.Unitless">
      <summary>
            Unit system not specified
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.Inches">
      <summary>
            Inches
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.Feet">
      <summary>
            Feet
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.Miles">
      <summary>
            Miles
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.Millimeters">
      <summary>
            Millimeters
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.Centimeters">
      <summary>
            Centimeters
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.Meters">
      <summary>
            Meters
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.Kilometers">
      <summary>
            Kilometers
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.Microinches">
      <summary>
            Microinches
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.Mils">
      <summary>
            Mils (i.e., 0.001 inch) 
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.Yards">
      <summary>
            Yards
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.Angstroms">
      <summary>
            Angstroms
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.Nanometers">
      <summary>
            Nanometers
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.Microns">
      <summary>
            Microns
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.Decimeters">
      <summary>
            Decimeters
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.Decameters">
      <summary>
            Decameters
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.Hectometers">
      <summary>
            Hectometers
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.Gigameters">
      <summary>
            Gigameters
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.Astronomical">
      <summary>
            Astronomical units
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.LightYears">
      <summary>
            LightYears
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.Parsecs">
      <summary>
            Parsecs
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedLinearUnitsType.All">
      <summary>
            All the <see cref="T:devDept.Geometry.linearUnitsType" /> are supported
            </summary>
    </member>
    <member name="T:devDept.Geometry.angularUnitsType">
      <summary>
            Angular unit system type.
            </summary>
    </member>
    <member name="F:devDept.Geometry.angularUnitsType.Degrees">
      <summary>
            Degrees
            </summary>
    </member>
    <member name="F:devDept.Geometry.angularUnitsType.Radians">
      <summary>
            Radians
            </summary>
    </member>
    <member name="T:devDept.Geometry.massUnitsType">
      <summary>
            Mass unit system type.
            </summary>
    </member>
    <member name="F:devDept.Geometry.massUnitsType.Unitless">
      <summary>
            Unit system not specified
            </summary>
    </member>
    <member name="F:devDept.Geometry.massUnitsType.Micrograms">
      <summary>
            Micrograms
            </summary>
    </member>
    <member name="F:devDept.Geometry.massUnitsType.Milligrams">
      <summary>
            Milligrams
            </summary>
    </member>
    <member name="F:devDept.Geometry.massUnitsType.Grams">
      <summary>
             Grams
             </summary>
    </member>
    <member name="F:devDept.Geometry.massUnitsType.Kilograms">
      <summary>
            Kilograms
            </summary>
    </member>
    <member name="F:devDept.Geometry.massUnitsType.Tons">
      <summary>
            Tons 
             </summary>
    </member>
    <member name="F:devDept.Geometry.massUnitsType.Ounces">
      <summary>
            Ounces
            </summary>
    </member>
    <member name="F:devDept.Geometry.massUnitsType.Pounds">
      <summary>
            Pounds
            </summary>
    </member>
    <member name="F:devDept.Geometry.massUnitsType.Stones">
      <summary>
            Stones
            </summary>
    </member>
    <member name="F:devDept.Geometry.massUnitsType.ShortTons">
      <summary>
            ShortTons
            </summary>
    </member>
    <member name="F:devDept.Geometry.massUnitsType.LongTons">
      <summary>
             LongTons
            </summary>
    </member>
    <member name="F:devDept.Geometry.massUnitsType.NotSupported">
      <summary>
            All the <see cref="T:devDept.Geometry.massUnitsType" /> are supported
            </summary>
            /// <summary>
            The unit system of the imported geometry is not supported by Eyeshot
            </summary></member>
    <member name="T:devDept.Geometry.supportedMassUnitsType">
      <summary>
            Supported mass unit.
            </summary>
      <remarks>
        <seealso cref="M:devDept.Geometry.Utility.GetSupportedMassUnits(devDept.Geometry.massUnitsType)" />
      </remarks>
    </member>
    <member name="F:devDept.Geometry.supportedMassUnitsType.Unitless">
      <summary>
            Unit system not specified
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedMassUnitsType.Micrograms">
      <summary>
            Micrograms
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedMassUnitsType.Milligrams">
      <summary>
            Milligrams
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedMassUnitsType.Grams">
      <summary>
             Grams
             </summary>
    </member>
    <member name="F:devDept.Geometry.supportedMassUnitsType.Kilograms">
      <summary>
            Kilograms
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedMassUnitsType.Ton">
      <summary>
            Tons 
             </summary>
    </member>
    <member name="F:devDept.Geometry.supportedMassUnitsType.Ounce">
      <summary>
            Ounces
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedMassUnitsType.Pound">
      <summary>
            Pounds
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedMassUnitsType.Stone">
      <summary>
            Stones
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedMassUnitsType.ShortTon">
      <summary>
            ShortTons
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedMassUnitsType.LongTon">
      <summary>
             LongTons
            </summary>
    </member>
    <member name="F:devDept.Geometry.supportedMassUnitsType.All">
      <summary>
            All the <see cref="T:devDept.Geometry.massUnitsType" /> are supported
            </summary>
    </member>
    <member name="T:devDept.Geometry.FlagsHelper">
      <summary>
            Flags class helper.
            </summary>
      <remarks>For internal use only.</remarks>
    </member>
    <member name="M:devDept.Geometry.FlagsHelper.SetUnset``1(``0@,``0,System.Boolean)">
      <summary>
            Sets or unsets a flag depending on the <paramref name="set" /> value.
            </summary>
      <typeparam name="T">
      </typeparam>
      <param name="flags">The data to modify</param>
      <param name="flag">The flag to set/unset</param>
      <param name="set">If true, the flag is set, else it's unset</param>
    </member>
    <member name="T:devDept.Geometry.CircularSector">
      <summary>
            Represent a circular sector centered in the origin. A circular sector is the portion
            of a disk enclosed by two radial vectors. This class considers the disk to have an
            infinite radius, therefore one sector represents an infinite portion of plane.
            </summary>
    </member>
    <member name="P:devDept.Geometry.CircularSector.Start">
      <summary>
            Sector start vector (counter-clockwise).
            </summary>
    </member>
    <member name="P:devDept.Geometry.CircularSector.End">
      <summary>
            Sector end vector (counter-clockwise).
            </summary>
    </member>
    <member name="P:devDept.Geometry.CircularSector.CentralAngle">
      <summary>
            Central angle of the sector (varying in 0-2PI).
            </summary>
    </member>
    <member name="P:devDept.Geometry.CircularSector.Domain">
      <summary>
            Domain (start and end angles) of the sector.
            </summary>
    </member>
    <member name="M:devDept.Geometry.CircularSector.Contains(devDept.Geometry.Vector2D)">
      <summary>
            Check if the specified vector is inside the circular sector.
            </summary>
      <param name="vector">The vector to evaluate</param>
      <returns>
            True if the vector is inside the circular sector, false otherwise.
            </returns>
      <remarks>It is not required to normalize the given vector.</remarks>
    </member>
    <member name="M:devDept.Geometry.CircularSector.#ctor(devDept.Geometry.Vector2D,devDept.Geometry.Vector2D)">
      <summary>
            Standard constructor, to be used when the counter-clockwise
            arrangement of the enclosing vectors is known.
            </summary>
      <param name="start">First vector, counter-clockwise</param>
      <param name="end">Second vector, counter-clockwise</param>
      <remarks>It is not required to normalize the given vectors.</remarks>
    </member>
    <member name="M:devDept.Geometry.CircularSector.#ctor(devDept.Geometry.Vector2D,devDept.Geometry.Vector2D,devDept.Geometry.Vector2D)">
      <summary>
            Standard constructor, providing a vector parameter to specify
            which of the two possible circular sectors enclosed by the
            vectors is to be chosen. 
            </summary>
      <param name="v1">One enclosing vector</param>
      <param name="v2">The other enclosing vector</param>
      <param name="pointIn">Vector contained in the desired sector</param>
      <remarks>It is not required to normalize the given vectors.</remarks>
    </member>
    <member name="T:devDept.Geometry.VectorClock">
      <summary>
            Represent a plane subdivision in four quadrants, based on two vector axes.
            This class may be used to obtain the angle range of each section and to
            retrieve the quadrant where a point lies.
            </summary>
    </member>
    <member name="F:devDept.Geometry.VectorClock.MainAxis">
      <summary>
            Main axis, used to define the clock orientation.
            </summary>
    </member>
    <member name="F:devDept.Geometry.VectorClock.SecAxis">
      <summary>
            Secondary axis, used to define quadrants.
            </summary>
    </member>
    <member name="F:devDept.Geometry.VectorClock.SwappedAxis">
      <summary>
             When true, the angle between the main axis and the
             secondary axis is greater than 180 degrees.
            
             +----&gt;  Example of swapped axis. The secondary axis is
             |       pointing downwards with respect to the main
             |       axis: the angle is 270 degrees.
             v
             </summary>
    </member>
    <member name="F:devDept.Geometry.VectorClock.StartAngle">
      <summary>
            Angle of the main axis (varying in 0-2PI).
            </summary>
    </member>
    <member name="F:devDept.Geometry.VectorClock.QAngle">
      <summary>
            Quadrant angle: angle between the main and the secondary
            axis, varying in 0-PI.
            </summary>
    </member>
    <member name="M:devDept.Geometry.VectorClock.#ctor(devDept.Geometry.Vector2D,devDept.Geometry.Vector2D)">
      <summary>
            Create a vector clock based on the given axes.
            </summary>
      <param name="mainAxis">Main axis</param>
      <param name="secAxis">Secondary axis</param>
      <remarks>It is not required to normalize the given vectors.</remarks>
    </member>
    <member name="M:devDept.Geometry.VectorClock.Quadrant(devDept.Geometry.Point2D)">
      <summary>
             Retrieve the number of the quadrant where the given point is located.
             Quadrants are numbered from 0 to 3. The point is evaluated relative
             to the origin: if axes are (1, 0) and (0, 1), the point (1, 1)
             is in quadrant 0.
            
              1 | 0
             ---+---&gt;
              2 | 3
            
             Please note that the numbering starts from <see cref="F:devDept.Geometry.VectorClock.MainAxis" />
             and proceeds counter-clockwise (as shown above, where the main
             axis corresponds to the x-axis).
             </summary>
      <param name="point">The point to evaluate</param>
      <returns>The index of the quadrant.</returns>
    </member>
    <member name="M:devDept.Geometry.VectorClock.Locate(devDept.Geometry.Point2D,System.Int32@)">
      <summary>
            Retrieve the quadrant where the given point is located.
            </summary>
      <param name="point">The point to evaluate</param>
      <param name="quadIndex">The index of the quadrant</param>
      <returns>An interval with the quadrant start and end angles.</returns>
      <seealso cref="M:devDept.Geometry.VectorClock.Quadrant(devDept.Geometry.Point2D)" />
    </member>
    <member name="T:devDept.Geometry.HistogramData">
      <summary>
            HistogramData class definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.HistogramData.TotalHits">
      <summary>
            Gets the total number of hits.
            </summary>
    </member>
    <member name="P:devDept.Geometry.HistogramData.Larger">
      <summary>
            Gets the hits over the largest bin.
            </summary>
    </member>
    <member name="P:devDept.Geometry.HistogramData.Smaller">
      <summary>
            Gets the hits under the smallest bin.
            </summary>
    </member>
    <member name="P:devDept.Geometry.HistogramData.Bins">
      <summary>
            Gets the histogram bins.
            </summary>
    </member>
    <member name="P:devDept.Geometry.HistogramData.Max">
      <summary>
            Gets the largest value processed.
            </summary>
    </member>
    <member name="P:devDept.Geometry.HistogramData.Min">
      <summary>
            Gets the smaller value processed.
            </summary>
    </member>
    <member name="P:devDept.Geometry.HistogramData.Mean">
      <summary>
            Gets the average of all the processed values.
            </summary>
    </member>
    <member name="M:devDept.Geometry.HistogramData.#ctor(System.Int32,System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Tuple{System.Double,System.Double,System.Int32}[])">
      <summary>
            Standard constructor.
            </summary>
      <param name="totalHits">The total number of hits</param>
      <param name="larger">The hits over the larger bin</param>
      <param name="smaller">The hits over the smaller bin</param>
      <param name="max">The largest value processed</param>
      <param name="min">The smaller value processed</param>
      <param name="mean">The average of all processed values</param>
      <param name="bins">The histogram bins</param>
    </member>
    <member name="T:devDept.Geometry.IndexLine">
      <summary>
            Defines an edge using vertex indices
            </summary>
    </member>
    <member name="F:devDept.Geometry.IndexLine.V1">
      <summary>
            First vertex index.
            </summary>
    </member>
    <member name="F:devDept.Geometry.IndexLine.V2">
      <summary>
            Second vertex index.
            </summary>
    </member>
    <member name="M:devDept.Geometry.IndexLine.#ctor">
      <summary>
            Empty constructor
            </summary>
    </member>
    <member name="M:devDept.Geometry.IndexLine.#ctor(System.Int32,System.Int32)">
      <summary>
            Standard constructor
            </summary>
      <param name="v1">Index of the line start vertex</param>
      <param name="v2">Index of the line end vertex</param>
    </member>
    <member name="M:devDept.Geometry.IndexLine.Clone">
      <summary>
            Creates a deep copy of this index line.
            </summary>
      <returns>The new index line.</returns>
    </member>
    <member name="M:devDept.Geometry.IndexLine.ToArray">
      <summary>
            Returns an array of line's vertex indices.
            </summary>
      <returns>The int array.</returns>
    </member>
    <member name="P:devDept.Geometry.IndexLine.Item(System.Int32)">
      <summary>
            Gets or sets the element at the specified index.
            </summary>
      <param name="i">The zero-based index of the element to get or set</param>
      <returns>The element at the specified index.</returns>
    </member>
    <member name="T:devDept.Geometry.IndexTriangle">
      <summary>
            Defines a triangle using vertex indices.
            </summary>
    </member>
    <member name="F:devDept.Geometry.IndexTriangle.V3">
      <summary>
            Third verted index.
            </summary>
    </member>
    <member name="M:devDept.Geometry.IndexTriangle.#ctor">
      <summary>
            Empty constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.IndexTriangle.#ctor(System.Int32,System.Int32,System.Int32)">
      <summary>
            Standard constructor.
            </summary>
      <param name="v1">Index of the first triangle vertex</param>
      <param name="v2">Index of the second triangle vertex</param>
      <param name="v3">Index of the third triangle vertex</param>
    </member>
    <member name="M:devDept.Geometry.IndexTriangle.Clone">
      <summary>
            Creates a deep copy of this IndexTriangle.
            </summary>
      <returns>The new IndexTriangle.</returns>
    </member>
    <member name="M:devDept.Geometry.IndexTriangle.ToArray">
      <summary>
            Returns an array of triangle's vertex indices.
            </summary>
      <returns>The int array.</returns>
    </member>
    <member name="P:devDept.Geometry.IndexTriangle.Item(System.Int32)">
      <summary>
            Gets or sets the element at the specified index.
            </summary>
      <param name="i">The zero-based index of the element to get or set</param>
      <returns>The element at the specified index.</returns>
    </member>
    <member name="M:devDept.Geometry.IndexTriangle.Quality(System.Collections.Generic.IList{devDept.Geometry.Point3D})">
      <summary>
            Computes the triangle quality.
            </summary>
      <param name="vertices">A collection of 2D points representing the 2D mesh vertices.</param>
      <returns>The triangle quality (from 0 to 1)</returns>
    </member>
    <member name="M:devDept.Geometry.IndexComponentTriangle.Clone">
      <summary>
            Creates a deep copy of this IndexTriangle.
            </summary>
      <returns>The new IndexTriangle.</returns>
    </member>
    <member name="M:devDept.Geometry.IndexColorTriangle.Clone">
      <summary>
            Creates a deep copy of this IndexTriangle.
            </summary>
      <returns>The new IndexTriangle.</returns>
    </member>
    <member name="T:devDept.Geometry.ITriangleSupportsColor">
      <summary>
            Interface for <see cref="T:devDept.Geometry.IndexTriangle" /> that supports colors.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ITriangleSupportsColor.R">
            Color red component.
        </member>
    <member name="P:devDept.Geometry.ITriangleSupportsColor.G">
            Color green component.
        </member>
    <member name="P:devDept.Geometry.ITriangleSupportsColor.B">
            Color blue component.
        </member>
    <member name="T:devDept.Geometry.ITriangleSupportsNormals">
      <summary>
            Interface for <see cref="T:devDept.Geometry.IndexTriangle" /> that supports normals.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ITriangleSupportsNormals.N1">
      <summary>
            First vertex normal.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ITriangleSupportsNormals.N2">
      <summary>
            Second vertex normal.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ITriangleSupportsNormals.N3">
      <summary>
            Third vertex normal.
            </summary>
    </member>
    <member name="T:devDept.Geometry.ITriangleSupportsTextureCoords">
      <summary>
            Interface for <see cref="T:devDept.Geometry.IndexTriangle" /> that supports texture coordinates.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ITriangleSupportsTextureCoords.T1">
      <summary>
            First vertex texture index.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ITriangleSupportsTextureCoords.T2">
      <summary>
            Second vertex texture index.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ITriangleSupportsTextureCoords.T3">
      <summary>
            Third vertex texture index.
            </summary>
    </member>
    <member name="T:devDept.Geometry.ColorTriangle">
      <summary>
            Mesh triangle with color definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ColorTriangle.R">
            Color red component.
        </member>
    <member name="P:devDept.Geometry.ColorTriangle.G">
            Color green component.
        </member>
    <member name="P:devDept.Geometry.ColorTriangle.B">
            Color blue component.
        </member>
    <member name="T:devDept.Geometry.RichTriangle">
      <summary>
            Mesh rich triangle definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.RichTriangle.T1">
      <summary>
            First vertex texture index.
            </summary>
    </member>
    <member name="P:devDept.Geometry.RichTriangle.T2">
      <summary>
            Second vertex texture index.
            </summary>
    </member>
    <member name="P:devDept.Geometry.RichTriangle.T3">
      <summary>
            Third vertex texture index.
            </summary>
    </member>
    <member name="T:devDept.Geometry.SmoothTriangle">
      <summary>
            Mesh smooth triangle definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.SmoothTriangle.N1">
      <summary>
            First vertex normal.
            </summary>
    </member>
    <member name="P:devDept.Geometry.SmoothTriangle.N2">
      <summary>
            Second vertex normal.
            </summary>
    </member>
    <member name="P:devDept.Geometry.SmoothTriangle.N3">
      <summary>
            Third vertex normal.
            </summary>
    </member>
    <member name="T:devDept.Geometry.ColorSmoothTriangle">
      <summary>
            Mesh smooth triangle with color definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ColorSmoothTriangle.R">
            Color red component.
        </member>
    <member name="P:devDept.Geometry.ColorSmoothTriangle.G">
            Color green component.
        </member>
    <member name="P:devDept.Geometry.ColorSmoothTriangle.B">
            Color blue component.
        </member>
    <member name="T:devDept.Geometry.RichSmoothTriangle">
      <summary>
            Mesh smooth triangle with material definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.RichSmoothTriangle.T1">
      <summary>
            First vertex texture index.
            </summary>
    </member>
    <member name="P:devDept.Geometry.RichSmoothTriangle.T2">
      <summary>
            Second vertex texture index.
            </summary>
    </member>
    <member name="P:devDept.Geometry.RichSmoothTriangle.T3">
      <summary>
            Third vertex texture index.
            </summary>
    </member>
    <member name="T:devDept.Geometry.SilhoPolyRegion">
      <summary>
            2D polygonal region structure for hidden lines computation.
            </summary>
      <remarks>For internal use only.</remarks>
    </member>
    <member name="F:devDept.Geometry.SilhoPolyRegion.V1">
      <summary>
            First vertex.
            </summary>
    </member>
    <member name="F:devDept.Geometry.SilhoPolyRegion.V2">
      <summary>
            Second vertex.
            </summary>
    </member>
    <member name="F:devDept.Geometry.SilhoPolyRegion.V3">
      <summary>
            Third vertex.
            </summary>
    </member>
    <member name="T:devDept.Geometry.SilhoEdge">
      <summary>
            Edge structure for hidden lines computation.
            </summary>
    </member>
    <member name="F:devDept.Geometry.SilhoEdge.V1">
      <summary>
            First vertex.
            </summary>
    </member>
    <member name="F:devDept.Geometry.SilhoEdge.V2">
      <summary>
            Second vertex.
            </summary>
    </member>
    <member name="F:devDept.Geometry.SilhoEdge.EdgeIndex">
      <summary>
            The associated devDept.Eyeshot.Entities.Brep edge index.
            </summary>
    </member>
    <member name="T:devDept.Geometry.Interval">
      <summary>Interval definition.</summary>
    </member>
    <member name="F:devDept.Geometry.Interval.t0">
      <summary>
            Left interval value.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Interval.Low">
      <summary>
            Gets the left interval value.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Interval.Left">
      <summary>
            Gets the left interval value.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Interval.t1">
      <summary>
            Right interval value.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Interval.High">
      <summary>
            Gets the right interval value.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Interval.Right">
      <summary>
            Gets the right interval value.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Interval.#ctor(System.Double,System.Double)">
      <summary>Standard constructor.</summary>
    </member>
    <member name="M:devDept.Geometry.Interval.#ctor(System.Double[])">
      <summary>Double array constructor.</summary>
    </member>
    <member name="P:devDept.Geometry.Interval.IsDecreasing">
      <summary>Returns true if t0 &gt; t1.</summary>
    </member>
    <member name="P:devDept.Geometry.Interval.IsIncreasing">
      <summary>Returns true if t0 &lt; t1.</summary>
    </member>
    <member name="M:devDept.Geometry.Interval.Swap">
      <summary>Swaps t0 and t1.</summary>
    </member>
    <member name="M:devDept.Geometry.Interval.Reverse">
      <summary>Changes interval to [-t1, -t0].</summary>
    </member>
    <member name="P:devDept.Geometry.Interval.Length">
      <summary>
            Returns t1 - t0.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Interval.Mid">
      <summary>Returns 0.5 * (t0 + t1).</summary>
    </member>
    <member name="P:devDept.Geometry.Interval.Min">
      <summary>Returns smaller of t0 and t1.</summary>
    </member>
    <member name="P:devDept.Geometry.Interval.Max">
      <summary>Returns larger of t0 and t1.</summary>
    </member>
    <member name="P:devDept.Geometry.Interval.IsTwoPI">
      <summary>
            Returns true if the interval length is 2*PI.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Interval.ParameterAt(System.Double)">
      <summary>Convert normalized parameter to interval value, or pair of values.</summary>
    </member>
    <member name="M:devDept.Geometry.Interval.Includes(System.Double,System.Boolean)">
      <summary>
            Tests a value t to see if it is inside the interval.
            </summary>
      <param name="t">Value to test</param>
      <param name="testOpenInterval">If false, t is tested to see if it satisfies min &lt;= t &lt;= max. If true, t is tested to see if it satisfies min &lt; t &lt; max.</param>
      <returns>True if t is in the interval and false if t is not in the interval.</returns>
    </member>
    <member name="M:devDept.Geometry.Interval.Includes(System.Double,System.Double)">
      <summary>
            Tests a value t to see if it is inside the interval within a given tolerance.
            </summary>
      <param name="t">Value to test</param>
      <param name="tol">t is tested to see if it satisfies min - tol &lt; t &lt; max + tol.</param>
      <returns>True if t is in the interval and false if t is not in the interval.</returns>
    </member>
    <member name="M:devDept.Geometry.Interval.Merge(System.Collections.Generic.IList{devDept.Geometry.Interval},System.Double)">
      <summary>
            Merges a list of intervals.
            </summary>
      <param name="intervals">The list of intervals</param>
      <param name="tol">The tolerance to identify identical parameters</param>
      <returns>The resulting merged intervals.</returns>
    </member>
    <member name="M:devDept.Geometry.Interval.Intersection(devDept.Geometry.Interval,devDept.Geometry.Interval)">
      <summary>
            Compute the intersection of the specified intervals.
            </summary>
      <param name="a">First interval</param>
      <param name="b">Second interval</param>
      <returns>The intersection interval if <paramref name="a" /> and <paramref name="b" /> overlap, an empty interval otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Interval.Clamp(System.Double@)">
      <summary>
            Clamps the value between the interval bounds.
            </summary>
      <param name="t">The value</param>
    </member>
    <member name="M:devDept.Geometry.Interval.ToString">
      <summary>
            Converts this Interval to a human readable string.
            </summary>
      <returns>A string that represents this Interval.</returns>
    </member>
    <member name="T:devDept.Geometry.Matrix">
      <summary>
            Matrix operations helper class. Provides matrix multiplication, inversion and determinant computation methods.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Matrix.IsIdentity4(System.Double[0:,0:])">
      <summary>
            Returns true when the matrix is Identity.
            </summary>
      <param name="matrix">The matrix</param>
      <returns>True when the matrix is Identity, false otherwise</returns>
    </member>
    <member name="M:devDept.Geometry.Matrix.Multiply(System.Double,System.Double[0:,0:]@)">
      <summary>
            Scalar by matrix multiplication.
            </summary>
      <param name="scalar">The scalar value</param>
      <param name="matrix">The matrix</param>
    </member>
    <member name="M:devDept.Geometry.Matrix.Multiply3x(System.Double[0:,0:],System.Double[])">
      <summary>
            3x3 matrix by scalar multiplication.
            </summary>
      <param name="a">The matrix</param>
      <param name="b">The scalar value</param>
      <returns>The multiplication result.</returns>
    </member>
    <member name="M:devDept.Geometry.Matrix.Multiply4x(System.Double[0:,0:],System.Double[])">
      <summary>
            4x4 matrix by scalar multiplication.
            </summary>
      <param name="a">The matrix</param>
      <param name="b">The scalar value</param>
      <returns>The multiplication result.</returns>
    </member>
    <member name="M:devDept.Geometry.Matrix.Multiply(System.Double[0:,0:],System.Double[])">
      <summary>
            Matrix by scalar multiplication.
            </summary>
      <param name="a">The matrix</param>
      <param name="b">The scalar value</param>
      <returns>The multiplication result.</returns>
    </member>
    <member name="M:devDept.Geometry.Matrix.MultiplyX3(System.Double[],System.Double[0:,0:])">
      <summary>
            3x3 scalar by matrix multiplication.
            </summary>
      <param name="a">The scalar value</param>
      <param name="b">The matrix</param>
      <returns>The multiplication result.</returns>
    </member>
    <member name="M:devDept.Geometry.Matrix.Multiply4x4(System.Double[0:,0:],System.Double[0:,0:])">
      <summary>
            4x4 matrix by matrix multiplication.
            </summary>
      <param name="a">The left matrix</param>
      <param name="b">The right matrix</param>
      <returns>The multiplication result.</returns>
    </member>
    <member name="M:devDept.Geometry.Matrix.Multiply(System.Double[0:,0:],System.Double[0:,0:])">
      <summary>
            Matrix by matrix multiplication.
            </summary>
      <param name="a">The left matrix</param>
      <param name="b">The right matrix</param>
      <returns>The multiplication result.</returns>
    </member>
    <member name="M:devDept.Geometry.Matrix.Multiply3x3(System.Double[0:,0:],System.Double[0:,0:])">
      <summary>
            Matrix by matrix multiplication.
            </summary>
      <param name="a">The left matrix</param>
      <param name="b">The right matrix</param>
      <returns>The multiplication result.</returns>
    </member>
    <member name="M:devDept.Geometry.Matrix.Transpose(System.Double[0:,0:])">
      <summary>
            Computes the transpose of a matrix.
            </summary>
      <param name="matrix">The left matrix</param>
      <returns>The transposed matrix.</returns>
    </member>
    <member name="M:devDept.Geometry.Matrix.Determinant3(System.Double[0:,0:])">
      <summary>
            Computes the determinant of a 3x3 matrix.
            </summary>
      <param name="matrix">The matrix</param>
      <returns>The matrix determinant.</returns>
    </member>
    <member name="M:devDept.Geometry.Matrix.Determinant2(System.Double[0:,0:])">
      <summary>
            Computes the determinant of a 2x2 matrix.
            </summary>
      <param name="matrix">The matrix</param>
      <returns>The matrix determinant.</returns>
    </member>
    <member name="M:devDept.Geometry.Matrix.Inverse3(System.Double[0:,0:],System.Double[0:,0:]@)">
      <summary>
            Computes the inverse of a 3x3 matrix.
            </summary>
      <param name="matrix">The matrix</param>
      <param name="inverse">The inverse matrix</param>
      <returns>True if the operation succeeded, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Matrix.Determinant4(System.Double[0:,0:])">
      <summary>
            Computes the determinant of a 4x4 matrix.
            </summary>
      <param name="matrix">The matrix</param>
      <returns>The matrix determinant.</returns>
    </member>
    <member name="M:devDept.Geometry.Matrix.Inverse4(System.Double[0:,0:],System.Double[0:,0:]@)">
      <summary>
            Computes the inverse of a 4x4 matrix.
            </summary>
      <param name="matrix">The matrix</param>
      <param name="inverse">The inverse matrix</param>
      <returns>True if the operation succeeded, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Matrix.Inverse4(System.Double[0:,0:])">
      <summary>
            Computes the inverse of a 4x4 matrix without checking if the determinant is zero.
            </summary>
      <param name="a">The matrix</param>
      <returns>The inverted matrix.</returns>
    </member>
    <member name="T:devDept.Geometry.planeIntersectionType">
      <summary>
            Plane intersection type.
            </summary>
    </member>
    <member name="F:devDept.Geometry.planeIntersectionType.Disjoint">
      <summary>
            Disjoint (no intersection)
            </summary>
    </member>
    <member name="F:devDept.Geometry.planeIntersectionType.Coincide">
      <summary>
            The two planes coincide
            </summary>
    </member>
    <member name="F:devDept.Geometry.planeIntersectionType.UniqueLine">
      <summary>
            Intersection in a unique line
            </summary>
    </member>
    <member name="T:devDept.Geometry.Plane">
      <summary>
            Plane definition.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Plane.#ctor">
      <summary>
            XY plane constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Plane.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Vector3D)">
      <summary>
            3D point and normal vector constructor.
            </summary>
      <param name="P">Point on the plane</param>
      <param name="N">Non-zero normal to the plane</param>
    </member>
    <member name="M:devDept.Geometry.Plane.#ctor(devDept.Geometry.Vector3D)">
      <summary>
            Normal vector constructor.
            </summary>
      <param name="N">Non-zero normal to the plane</param>
    </member>
    <member name="M:devDept.Geometry.Plane.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D)">
      <summary>
            3D point, and two vectors constructor.
            </summary>
      <param name="P">Point on the plane</param>
      <param name="X">Non-zero vector in plane</param>
      <param name="Y">Another vector in the plane not parallel to X</param>
    </member>
    <member name="M:devDept.Geometry.Plane.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Three non-collinear 3D points constructor.
            </summary>
      <param name="P">First point (Origin)</param>
      <param name="Q">Second point (X axis)</param>
      <param name="R">Third point</param>
      <remarks>The Z axis is given by the normalized cross product of PQ and PR, and then the Y axis is obtained by the cross product of Z axis and X axis. So Y axis may not be aligned with PR.</remarks>
    </member>
    <member name="M:devDept.Geometry.Plane.#ctor(System.Double[])">
      <summary>
            From equation constructor. Equation form: ax + by + cz + d = 0.
            </summary>
      <param name="e">Equation of plane</param>
    </member>
    <member name="M:devDept.Geometry.Plane.Clone">
      <summary>
            Creates a deep copy of this plane.
            </summary>
      <returns>The new plane obejct.</returns>
    </member>
    <member name="M:devDept.Geometry.Plane.CreateFromPoints(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Creates the plane from three non collinear points.
            </summary>
      <param name="P">First point (Origin)</param>
      <param name="Q">Second point (X axis)</param>
      <param name="R">Third point (Y axis)</param>
    </member>
    <member name="M:devDept.Geometry.Plane.UpdateEquation">
      <summary>
            Updates plane equation.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Plane.Reflect(devDept.Geometry.Point3D)">
      <summary>
            Reflects a point about this plane.
            </summary>
      <param name="point">Point to reflect</param>
      <returns>The reflected point</returns>
    </member>
    <member name="M:devDept.Geometry.Plane.Reflect(devDept.Geometry.Vector3D)">
      <summary>
            Reflects a vector about a plane.
            </summary>
      <param name="vector">Vector to reflect</param>
      <returns>The reflected vector</returns>
      <remarks>Since the vector starts at the world origin, the reflecting plane is considered passing through it.</remarks>
    </member>
    <member name="M:devDept.Geometry.Plane.PointAt(devDept.Geometry.Point2D)">
      <summary>Evaluates a point on the plane.</summary>
      <param name="pt">Point position</param>
    </member>
    <member name="M:devDept.Geometry.Plane.PointAt(System.Double,System.Double)">
      <summary>Evaluates a point on the plane.</summary>
      <param name="s">Evaluation parameter</param>
      <param name="t">Evaluation parameter</param>
    </member>
    <member name="M:devDept.Geometry.Plane.PointAt(System.Double,System.Double,System.Double)">
      <summary>Evaluates a point on the plane.</summary>
      <param name="s">Evaluation parameter</param>
      <param name="t">Evaluation parameter</param>
      <param name="c">Elevation parameter</param>
    </member>
    <member name="M:devDept.Geometry.Plane.Intersection(devDept.Geometry.Plane,devDept.Geometry.Plane,devDept.Geometry.Segment3D@)">
      <summary>
            Computes the intersection of two planes.
            </summary>
      <param name="pln1">The first plane</param>
      <param name="pln2">The second plane</param>
      <param name="intSeg">The intersection segment (when it exists)</param>
      <returns>The intersection type.</returns>
    </member>
    <member name="M:devDept.Geometry.Plane.Intersection(devDept.Geometry.Plane,devDept.Geometry.Plane,System.Double,devDept.Geometry.Segment3D@)">
      <summary>
            Computes the intersection of two planes.
            </summary>
      <param name="pln1">The first plane</param>
      <param name="pln2">The second plane</param>
      <param name="tol">Tolerance used to decide if parallel planes are coincident or disjoint</param>
      <param name="intSeg">The intersection segment (when it exists)</param>
      <returns>The intersection type.</returns>
    </member>
    <member name="M:devDept.Geometry.Plane.Intersection(devDept.Geometry.Plane,devDept.Geometry.Plane,System.Double,devDept.Geometry.Point3D@,devDept.Geometry.Vector3D@)">
      <summary>
            Computes the intersection of two planes.
            </summary>
      <param name="pln1">The first plane</param>
      <param name="pln2">The second plane</param>
      <param name="tol">Tolerance used to decide if parallel planes are coincident or disjoint</param>
      <param name="pt">The intersection point (when it exists)</param>
      <param name="u">The intersection direction</param>
      <returns>The intersection type.</returns>
    </member>
    <member name="M:devDept.Geometry.Plane.TransformBy(devDept.Geometry.Transformation)">
      <summary>
             Transforms the plane by the provided transformation.
            </summary>
      <param name="xform">The transformation to be applied</param>
    </member>
    <member name="M:devDept.Geometry.Plane.Offset(System.Double)">
      <summary>
            Returns a new plane with the specified offset from this one.
            </summary>
      <param name="amount">The offset amount</param>
      <returns>The new plane object.</returns>
    </member>
    <member name="M:devDept.Geometry.Plane.Rotate(System.Double,devDept.Geometry.Vector3D)">
      <summary>
            Rotates this plane around an axis passing through world origin.
            </summary>
      <param name="angleInRadians">Rotation angle</param>
      <param name="axis">Rotation axis</param>
    </member>
    <member name="M:devDept.Geometry.Plane.Rotate(System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D)">
      <summary>
            Rotates this plane.
            </summary>
      <param name="angleInRadians">Rotation angle</param>
      <param name="axis">Rotation axis</param>
      <param name="center">Rotation center</param>
    </member>
    <member name="M:devDept.Geometry.Plane.Translate(System.Double,System.Double,System.Double)">
      <summary>
            Translates this plane.
            </summary>
      <param name="dx">Amount in X</param>
      <param name="dy">Amount in Y</param>
      <param name="dz">Amount in Z</param>
    </member>
    <member name="M:devDept.Geometry.Plane.Translate(devDept.Geometry.Vector3D)">
      <summary>
            Translates this plane.
            </summary>
      <param name="delta">Delta vector</param>
    </member>
    <member name="P:devDept.Geometry.Plane.XY">
      <summary>
            Gets the XY plane.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Plane.YX">
      <summary>
            Gets the YX plane.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Plane.YZ">
      <summary>
            Gets the YZ plane.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Plane.ZY">
      <summary>
            Gets the ZY plane.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Plane.ZX">
      <summary>
            Gets the ZX plane.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Plane.XZ">
      <summary>
            Gets the XZ plane.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Plane.DistanceTo(devDept.Geometry.Point3D)">
      <summary>
            Gets signed distance from the plane to a point.
            </summary>
      <returns>The distance</returns>
    </member>
    <member name="M:devDept.Geometry.Plane.Flip">
      <summary>
            Flip plane orientation by swapping X and y axes, reversing the zaxis, and
            updating the equation.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Plane.Project(devDept.Geometry.Point3D,System.Double@,System.Double@)">
      <summary>
            Gets point on plane that is closest to a given point.
            </summary>
      <param name="P">The 3D point</param>
      <param name="s">The s parameter of the closest point on the plane</param>
      <param name="t">The t parameter of the closest point on the plane</param>
    </member>
    <member name="M:devDept.Geometry.Plane.Project(devDept.Geometry.Point3D)">
      <summary>
            Gets point on plane that is closest to a given point.
            </summary>
      <param name="P">The 3D point</param>
      <returns>The closest 2D point on the plane.</returns>
    </member>
    <member name="M:devDept.Geometry.Plane.Project(devDept.Geometry.Vector3D)">
      <summary>
            Gets point on plane that is closest to a given vector.
            </summary>
      <param name="P">The 3D vector</param>
      <returns>The closest 2D vector on the plane.</returns>
    </member>
    <member name="P:devDept.Geometry.Plane.Origin">
      <summary>
            Gets or sets the plane origin.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Plane.AxisX">
      <summary>
            Gets the plane X axis.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Plane.AxisY">
      <summary>
            Gets the plane Y axis.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Plane.AxisZ">
      <summary>
            Gets the plane Z axis.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Plane.Equation">
      <summary>
            Gets the plane equation.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Plane.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Plane.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Plane.ToString">
      <summary>
            Converts this Plane to a human readable string.
            </summary>
      <returns>A string that represents this Plane.</returns>
    </member>
    <member name="M:devDept.Geometry.Plane.GetXElement(System.String)">
      <summary>
            For internal use only
            </summary>
    </member>
    <member name="T:devDept.Geometry.PlaneEquation">
      <summary>
            Plane equation definition.
            </summary>
    </member>
    <member name="F:devDept.Geometry.PlaneEquation.D">
      <summary>
            D term.
            </summary>
    </member>
    <member name="M:devDept.Geometry.PlaneEquation.#ctor">
      <summary>
            Empty constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.PlaneEquation.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Vector3D)">
      <summary>
            3D point and 3D normal constructor.
            </summary>
      <param name="P">3D point on the plane</param>
      <param name="N">3D vector perpendicular to the plane</param>
    </member>
    <member name="M:devDept.Geometry.PlaneEquation.Create(devDept.Geometry.Point3D,devDept.Geometry.Vector3D)">
      <summary>
            Creates a plane equation from a 3D point and 3D normal vector. It sets (X,Y,Z) to a unitized N, then sets D = -(X*P.X + y*P.Y + Z*P.Z).
            </summary>
      <param name="P">3D point on the plane</param>
      <param name="N">3D vector perpendicular to the plane</param>
      <returns>True if the operation succeeded, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.PlaneEquation.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Plane's coefficients constructor. Equation form: ax + by + cz + d = 0.
            </summary>
      <param name="a">First coefficient</param>
      <param name="b">Second coefficient</param>
      <param name="c">Third coefficient</param>
      <param name="d">Fourth coefficient</param>
    </member>
    <member name="M:devDept.Geometry.PlaneEquation.Clone">
      <summary>
            Creates a deep copy of this plane equation.
            </summary>
      <returns>The new plane equation object.</returns>
    </member>
    <member name="M:devDept.Geometry.PlaneEquation.ValueAt(devDept.Geometry.Point3D)">
      <summary>
            Evaluate the plane at a point.
            </summary>
      <param name="P">The point</param>
      <returns>x*P.x + y*P.y + z*P.z + d</returns>
    </member>
    <member name="M:devDept.Geometry.PlaneEquation.ValueAt(System.Double,System.Double,System.Double)">
      <summary>
            Evaluate the plane at a point.
            </summary>
      <param name="x">The x coordinate</param>
      <param name="y">The y coordinate</param>
      <param name="z">The z coordinate</param>
      <returns>X*x + Y*y + Z*z + D</returns>
    </member>
    <member name="M:devDept.Geometry.PlaneEquation.IsValid">
      <summary>
            Checks if this plane equation is valid.
            </summary>
    </member>
    <member name="M:devDept.Geometry.PlaneEquation.ToString">
      <summary>Converts this planar equation to a human readable string.</summary>
      <returns>A string that represents this planar equation.</returns>
    </member>
    <member name="M:devDept.Geometry.PlaneEquation.ToArray">
      <summary>
            Returns an array of plane equation's coefficients.
            </summary>
      <returns>The double array.</returns>
    </member>
    <member name="T:devDept.Geometry.IVertex">
      <summary>
            Common properties of vertices.
            </summary>
    </member>
    <member name="M:devDept.Geometry.IVertex.ToArray">
      <summary>
            Gets the vertex position as a double array.
            </summary>
    </member>
    <member name="T:devDept.Geometry.Point2D">
      <summary>
            Defines a 2D point. 
            </summary>
    </member>
    <member name="F:devDept.Geometry.Point2D.X">
      <summary>
            X coordinate value.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Point2D.Y">
      <summary>
            Y coordinate value.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Point2D.#ctor">
      <summary>
            Empty constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Point2D.#ctor(System.Double,System.Double)">
      <summary>
            Standard constructor.
            </summary>
      <param name="x">Point's X coordinate</param>
      <param name="y">Point's Y coordinate</param>
    </member>
    <member name="M:devDept.Geometry.Point2D.#ctor(System.Double[])">
      <summary>
            Double array constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Point2D.Clone">
      <summary>
            Creates a deep copy of this 2D point.
            </summary>
      <returns>The new 2D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point2D.ToArray">
      <summary>
            Returns an array of point's coordinates.
            </summary>
      <returns>The double array.</returns>
    </member>
    <member name="M:devDept.Geometry.Point2D.IsValid">
      <summary>
            Returns true if the point's coordinates are reasonable values.
            </summary>
      <returns>True if the point is valid, false otherwise.</returns>
    </member>
    <member name="P:devDept.Geometry.Point2D.MaximumCoordinate">
      <summary>
            Gets the absolute value of the maximum coordinate.
            </summary>
      <returns>The absolute value of the maximum coordinate.</returns>
    </member>
    <member name="P:devDept.Geometry.Point2D.Origin">
      <summary>
            Returns a 2D point at origin.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Point2D.MinValue">
      <summary>
            Returns a 2D point with coordinates at double.MinValue.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Point2D.MaxValue">
      <summary>
            Returns a 2D point with coordinates at double.MaxValue.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Point2D.op_Addition(devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            Addition between two 2D points.
            </summary>
      <param name="a">First 2D point</param>
      <param name="b">Second 2D point</param>
      <returns>The resulting 2D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point2D.op_Addition(devDept.Geometry.Point2D,devDept.Geometry.Vector2D)">
      <summary>
            Addition between a 2D point and a 2D vector.
            </summary>
      <param name="a">2D point</param>
      <param name="b">2D vector</param>
      <returns>The resulting 2D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point2D.op_Addition(devDept.Geometry.Vector2D,devDept.Geometry.Point2D)">
      <summary>
            Addition between a 2D vector and a 2D point.
            </summary>
      <param name="v">The 2D vector</param>
      <param name="p">The 2D point</param>
      <returns>The resulting 2D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point2D.op_Subtraction(devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            Subtraction between two 2D points.
            </summary>
      <param name="a">First 2D point</param>
      <param name="b">Second 2D point</param>
      <returns>The resulting 2D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point2D.op_Subtraction(devDept.Geometry.Point2D,devDept.Geometry.Vector2D)">
      <summary>
            Subtraction between a 2D point and a 2D vector.
            </summary>
      <param name="a">2D point</param>
      <param name="b">2D vector</param>
      <returns>The resulting 2D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point2D.op_Subtraction(devDept.Geometry.Vector2D,devDept.Geometry.Point2D)">
      <summary>
            Subtraction between a 2D vector and a 2D point.
            </summary>
      <param name="v">The 2D vector</param>
      <param name="p">The 2D point</param>
      <returns>The resulting 2D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point2D.op_Multiply(System.Double,devDept.Geometry.Point2D)">
      <summary>
            Product between a scalar value and a 2D point.
            </summary>
      <param name="s">Scalar value</param>
      <param name="p">The 2D point</param>
      <returns>The resulting 2D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point2D.op_Multiply(devDept.Geometry.Point2D,System.Double)">
      <summary>
            Product between a 2D point and a scalar value.
            </summary>
      <param name="s">Scalar value</param>
      <param name="p">The 2D point</param>
      <returns>The resulting 2D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point2D.op_Division(devDept.Geometry.Point2D,System.Double)">
      <summary>
            Division between a 2D point and a scalar value.
            </summary>
      <param name="s">Scalar value</param>
      <param name="p">The 2D point</param>
      <returns>The resulting 2D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point2D.ProjectTo(devDept.Geometry.Segment2D)">
      <summary>
            Project this point onto a 2D segment.
            </summary>
      <param name="seg">The 2D segment</param>
      <returns>The projected point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point2D.DistanceTo(devDept.Geometry.Segment2D)">
      <summary>
            Computes the point-line distance.
            </summary>
      <param name="seg">The line</param>
      <returns>The distance between this 2D point and its projection on the line.</returns>
    </member>
    <member name="M:devDept.Geometry.Point2D.ToString">
      <summary>
            Converts this 2D point to a human readable string.
            </summary>
      <returns>A string that represents this 2D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point2D.ToStringXml">
      <summary>
            Converts this 2D point to a human readable string.
            </summary>
      <returns>A string that represents this 2D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point2D.MidPoint(devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            Computes the midpoint between two 2D points.
            </summary>
      <param name="a">First 2D point</param>
      <param name="b">Second 2D point</param>
      <returns>The midpoint between a and b.</returns>
    </member>
    <member name="M:devDept.Geometry.Point2D.Distance(devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            Computes the distance between two 2D points.
            </summary>
      <param name="a">First point</param>
      <param name="b">Second point</param>
      <returns>The distance between a and b.</returns>
    </member>
    <member name="M:devDept.Geometry.Point2D.DistanceSquared(devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            Computes the squared distance between two 2D points.
            </summary>
      <param name="a">First point</param>
      <param name="b">Second point</param>
      <returns>The squared distance between p1 and p2.</returns>
    </member>
    <member name="M:devDept.Geometry.Point2D.DistanceTo(devDept.Geometry.Point2D)">
      <summary>
            Computes the distance to 2D point b.
            </summary>
      <param name="b">The other point</param>
      <returns>The distance between this 2D point and b.</returns>
    </member>
    <member name="M:devDept.Geometry.Point2D.AreEqual(devDept.Geometry.Point2D,devDept.Geometry.Point2D,System.Double)">
      <summary>
            Compares two 2D points in the given domain.
            </summary>
      <param name="p1">First point</param>
      <param name="p2">Second point</param>
      <param name="domainSize">The 2D diagonal length of your model.</param>
      <returns>True if the two point are coincident, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Point2D.TransformBy(devDept.Geometry.Transformation)">
      <summary>
            Transforms the 2D point by the specified transformation.
            </summary>
      <param name="xform">The transformation to be applied</param>
    </member>
    <member name="M:devDept.Geometry.Point2D.GetXElement">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="T:devDept.Geometry.Point3D">
      <summary>
            Defines a 3D point. 
            </summary>
    </member>
    <member name="F:devDept.Geometry.Point3D.Z">
      <summary>
            Z coordinate value.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Point3D.#ctor">
      <summary>
            Empty constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Point3D.#ctor(System.Double,System.Double,System.Double)">
      <summary>
            Standard constructor.
            </summary>
      <param name="x">X coordinate value</param>
      <param name="y">Y coordinate value</param>
      <param name="z">Z coordinate value</param>
    </member>
    <member name="M:devDept.Geometry.Point3D.#ctor(System.Double,System.Double)">
      <summary>
            2D point constructor
            </summary>
      <param name="x">X coordinate value</param>
      <param name="y">Y coordinate value</param>
    </member>
    <member name="M:devDept.Geometry.Point3D.#ctor(System.Double[])">
      <summary>
            Double array constructor.
            </summary>
      <param name="coords">The XYZ coordinates as a double array</param>
    </member>
    <member name="M:devDept.Geometry.Point3D.Clone">
      <summary>
            Creates a deep copy of this 3D point.
            </summary>
      <returns>The new 3D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.ToArray">
      <summary>
            Returns an array of point's coordinates.
            </summary>
      <returns>The double array.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.IsInside(devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Checks if the point is inside the specified volume.
            </summary>
      <param name="boxMin">Lower-left-front corner</param>
      <param name="boxMax">Top-right-rear corner</param>
      <returns>True if the point is inside, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.MidPoint(devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Computes the midpoint between two 3D points.
            </summary>
      <param name="a">First 3D point</param>
      <param name="b">Second 3D point</param>
      <returns>The midpoint between a and b.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.DistanceTo(devDept.Geometry.Point3D)">
      <summary>
            Computes the distance to 3D point b.
            </summary>
      <param name="b">The other point</param>
      <returns>The distance between this 3D point and b.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.Distance(devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Computes the distance between two 3D points.
            </summary>
      <param name="a">First 3D point</param>
      <param name="b">Second 3D point</param>
      <returns>The distance between a and b.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.ProjectTo(devDept.Geometry.Segment3D)">
      <summary>
            Project this point onto a 3D segment.
            </summary>
      <param name="seg">The 3D segment</param>
      <returns>The projected point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.DistanceTo(devDept.Geometry.Segment3D)">
      <summary>
            Computes the point-line distance.
            </summary>
      <param name="seg">The line</param>
      <returns>The distance between this 3D point and its projection on the line.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.DistanceSquared(devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Computes the squared distance between two 3D points.
            </summary>
      <param name="a">First point</param>
      <param name="b">Second point</param>
      <returns>The squared distance between a and b.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.DistanceTo(devDept.Geometry.Plane)">
      <summary>
            Computes the point to plane signed distance.
            </summary>
      <param name="plane">The plane</param>
      <returns>The distance between this 3D point and its projection on the plane.</returns>
    </member>
    <member name="P:devDept.Geometry.Point3D.Origin">
      <summary>
            Returns the (0,0,0) point.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Point3D.MinValue">
      <summary>
            Returns a 3D point with coordinates at double.MinValue.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Point3D.MaxValue">
      <summary>
            Returns a 3D point with coordinates at double.MaxValue.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Point3D.op_Subtraction(devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Subtraction between two 3D points.
            </summary>
      <param name="a">First 3D point</param>
      <param name="b">Second 3D point</param>
      <returns>The resulting 3D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.op_Multiply(System.Double,devDept.Geometry.Point3D)">
      <summary>
            Product between a 3D point and a scalar s.
            </summary>
      <param name="s">Scalar value</param>
      <param name="p">The point</param>
      <returns>The resulting 3D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.op_Multiply(devDept.Geometry.Point3D,System.Double)">
      <summary>
            Product between a 3D point and a scalar s.
            </summary>
      <param name="s">Scalar value</param>
      <param name="p">The point</param>
      <returns>The resulting 3D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.op_Division(devDept.Geometry.Point3D,System.Double)">
      <summary>
            Division between a 3D point and a scalar s.
            </summary>
      <param name="s">Scalar value</param>
      <param name="p">The point</param>
      <returns>The resulting 3D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.op_Addition(devDept.Geometry.Point3D,devDept.Geometry.Vector3D)">
      <summary>
            Addition between a 3D point and a 3D vector.
            </summary>
      <param name="a">The 3D point</param>
      <param name="b">The 3D vector</param>
      <returns>The resulting 3D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.op_Addition(devDept.Geometry.Vector3D,devDept.Geometry.Point3D)">
      <summary>
            Addition between a 3D vector and a 3D point.
            </summary>
      <param name="v">The 3D vector</param>
      <param name="p">The 3D point</param>
      <returns>The resulting 3D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.op_Subtraction(devDept.Geometry.Point3D,devDept.Geometry.Vector3D)">
      <summary>
            Subtraction between a 3D point and a 3D vector.
            </summary>
      <param name="a">The 3D point</param>
      <param name="b">The 3D vector</param>
      <returns>The resulting 3D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.op_Subtraction(devDept.Geometry.Vector3D,devDept.Geometry.Point3D)">
      <summary>
            Subtraction between a 3D vector and a 3D point.
            </summary>
      <param name="v">The 3D vector</param>
      <param name="p">The 3D point</param>
      <returns>The resulting 3D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.op_Addition(devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Addition between two 3D points.
            </summary>
      <param name="a">First 3D point</param>
      <param name="b">Second 3D point</param>
      <returns>The resulting 3D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.AreEqual(devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Double)">
      <summary>
            Compares two 3D points in the given domain.
            </summary>
      <param name="p1">First point</param>
      <param name="p2">Second point</param>
      <param name="domainSize">The 3D diagonal length of your model.</param>
      <returns>True if the two point are coincident, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.ToString">
      <summary>
            Converts this 3D point to a human readable string.
            </summary>
      <returns>A string that represents this 3d point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.ToStringXml">
      <summary>
            Converts this 3D point to a human readable string.
            </summary>
      <returns>A string that represents this 2D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point3D.TransformBy(devDept.Geometry.Transformation)">
      <summary>
            Transforms the 3D point by the specified transformation.
            </summary>
      <param name="xform">The transformation to be applied</param>
    </member>
    <member name="M:devDept.Geometry.Point3D.GetXElement">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="T:devDept.Geometry.PointWithDisplacement">
      <summary>
            Defines a <see cref="T:devDept.Geometry.Point3D" /> with displacement.
            </summary>
    </member>
    <member name="P:devDept.Geometry.PointWithDisplacement.Unknowns">
      <summary>
            Gets or sets the node displacement (defined as double[3]).
            </summary>
    </member>
    <member name="T:devDept.Geometry.Point4D">
      <summary>
            Defines a point in homogeneous coordinates. 
            </summary>
    </member>
    <member name="P:devDept.Geometry.Point4D.W">
      <summary>
            W term.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Point4D.#ctor">
      <summary>
            Empty constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Point4D.#ctor(System.Double,System.Double)">
      <summary>
            2D euclidean point constructor (Z=0, W=1).
            </summary>
      <param name="x">Point's X coordinate</param>
      <param name="y">Point's Y coordinate</param>
    </member>
    <member name="M:devDept.Geometry.Point4D.#ctor(System.Double,System.Double,System.Double)">
      <summary>
            3D euclidean point constructor (W=1).
            </summary>
      <param name="x">Point's X coordinate</param>
      <param name="y">Point's Y coordinate</param>
      <param name="z">Point's Z coordinate</param>
    </member>
    <member name="M:devDept.Geometry.Point4D.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Homogeneous point constructor.
            </summary>
      <param name="x">Point's X coordinate</param>
      <param name="y">Point's Y coordinate</param>
      <param name="z">Point's Z coordinate</param>
      <param name="w">Point's W coordinate</param>
    </member>
    <member name="M:devDept.Geometry.Point4D.#ctor(System.Double[])">
      <summary>
            Double array constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Point4D.#ctor(devDept.Geometry.Point3D)">
      <summary>
            3D point constructor.
            </summary>
      <param name="pt">The 3D point</param>
    </member>
    <member name="M:devDept.Geometry.Point4D.Clone">
      <summary>
            Creates a deep copy of this point.
            </summary>
      <returns>The new 4D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point4D.ToArray">
      <summary>
            Returns an array of point's coordinates.
            </summary>
      <returns>The double array.</returns>
    </member>
    <member name="P:devDept.Geometry.Point4D.Euclid">
      <summary>
            Gets or sets the Euclidean representation for this homogeneous point.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Point4D.op_Multiply(System.Double,devDept.Geometry.Point4D)">
      <summary>
            Product between a scalar value and a 4D point.
            </summary>
      <param name="value">Scalar value</param>
      <param name="p">The 4D point</param>
      <returns>The resulting 4D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point4D.op_Division(devDept.Geometry.Point4D,System.Double)">
      <summary>
            Division between a 4D point and a scalar s.
            </summary>
      <param name="s">Scalar value</param>
      <param name="p">The 4D point</param>
      <returns>The resulting 4D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point4D.op_Addition(devDept.Geometry.Point4D,devDept.Geometry.Point4D)">
      <summary>
            Addition between two 4D points.
            </summary>
      <param name="a">First 4D point</param>
      <param name="b">Second 4D point</param>
      <returns>The resulting 4D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point4D.op_Subtraction(devDept.Geometry.Point4D,devDept.Geometry.Point4D)">
      <summary>
            Subtraction between two 4D points.
            </summary>
      <param name="a">First 4D point</param>
      <param name="b">Second 4D point</param>
      <returns>The resulting 4D point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point4D.Distance(devDept.Geometry.Point4D,devDept.Geometry.Point4D)">
      <summary>
            Computes the 4D distance. 
            </summary>
      <param name="a">First 4D point</param>
      <param name="b">Second 4D point</param>
      <returns>The distance. The weights are treated as ordinary coordinates.</returns>
    </member>
    <member name="M:devDept.Geometry.Point4D.ToString">
      <summary>
            Converts this 4D point to a human readable string.
            </summary>
      <returns>A string that represents this point.</returns>
    </member>
    <member name="M:devDept.Geometry.Point4D.TransformBy(devDept.Geometry.Transformation)">
      <summary>
            Transforms the homogeneous point by the specified transformation.
            </summary>
      <param name="xform">The transformation to be applied</param>
    </member>
    <member name="T:devDept.Geometry.PointRGB">
      <summary>
            Colored 3D point definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.PointRGB.R">
      <summary>
            Red component.
            </summary>
    </member>
    <member name="P:devDept.Geometry.PointRGB.G">
      <summary>
            Green component.
            </summary>
    </member>
    <member name="P:devDept.Geometry.PointRGB.B">
      <summary>
            Blue component.
            </summary>
    </member>
    <member name="M:devDept.Geometry.PointRGB.#ctor(System.Double,System.Double,System.Double,System.Int32)">
      <summary>
            Color constructor.
            </summary>
      <param name="x">Point's X coordinate</param>
      <param name="y">Point's Y coordinate</param>
      <param name="z">Point's Z coordinate</param>
      <param name="argbColor">Point's color</param>
    </member>
    <member name="M:devDept.Geometry.PointRGB.#ctor(System.Double,System.Double,System.Double,System.Byte,System.Byte,System.Byte)">
      <summary>
            Individual color components constructor.
            </summary>
      <param name="x">Point's X coordinate</param>
      <param name="y">Point's Y coordinate</param>
      <param name="z">Point's Z coordinate</param>
      <param name="red">Point's color red component</param>
      <param name="green">Point's color green component</param>
      <param name="blue">Point's color blue component</param>
    </member>
    <member name="M:devDept.Geometry.PointRGB.Clone">
      <summary>
            Creates a deep copy of this RGB point.
            </summary>
      <returns>The new RBG point object.</returns>
    </member>
    <member name="T:devDept.Geometry.PointU">
      <summary>
            Curve point definition.
            </summary>
    </member>
    <member name="F:devDept.Geometry.PointU.U">
      <summary>
            Parametric U value.
            </summary>
    </member>
    <member name="M:devDept.Geometry.PointU.Clone">
      <summary>
            Creates a deep copy of this 3D point.
            </summary>
      <returns>The new 3D point.</returns>
    </member>
    <member name="M:devDept.Geometry.PointU.ToString">
      <summary>
            Converts this 3D point to a human readable string.
            </summary>
      <returns>A string that represents this 3D point.</returns>
    </member>
    <member name="T:devDept.Geometry.polygonStatusType">
      <summary>
            Polygon status type. 
            </summary>
      <example>
             
                        Over
                        +--------------+   On
                        |   Clip    +--+----+
                        |   o-------+--o    |
                        |   |  In   |  |    |
                        |   |  +----+--+    |
                        |   |  |    +--+----+
                        |   |  |       |
                        |   |  +-------+
                        |   |          |
                        |   o----------o
                        +--------------+
                Out
                +---------+    
                |         |
                +---------+
             
            </example>
    </member>
    <member name="F:devDept.Geometry.polygonStatusType.In">
      <summary>
            The subject polygon is inside the clip one
            </summary>
    </member>
    <member name="F:devDept.Geometry.polygonStatusType.Out">
      <summary>
            The subject polygon is outside the clip one
            </summary>
    </member>
    <member name="F:devDept.Geometry.polygonStatusType.On">
      <summary>
            The subject polygon intersects the clip one
            </summary>
    </member>
    <member name="F:devDept.Geometry.polygonStatusType.Over">
      <summary>
            The clip polygon is inside the subject one
            </summary>
    </member>
    <member name="T:devDept.Geometry.pointStatusType">
      <summary>
            Point status type.
            </summary>
    </member>
    <member name="F:devDept.Geometry.pointStatusType.Outside">
      <summary>
            Outside
            </summary>
    </member>
    <member name="F:devDept.Geometry.pointStatusType.Inside">
      <summary>
            Inside
            </summary>
    </member>
    <member name="F:devDept.Geometry.pointStatusType.Onto">
      <summary>
            Onto the polygon perimeter
            </summary>
    </member>
    <member name="F:devDept.Geometry.pointStatusType.Undetermined">
      <summary>
            The real state of the point can't be detected (it is in a particular position that fails all the controls).
            </summary>
      <remarks>Used during GBrep.IsPointInside() only</remarks>
    </member>
    <member name="T:devDept.Geometry.Polygon2D">
      <summary>
            Closed 2D polygon definition.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Polygon2D.Min">
      <summary>
            Polygon's bounding rectangle min point.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Polygon2D.Max">
      <summary>
            Polygon's bounding rectangle max point
            </summary>
    </member>
    <member name="F:devDept.Geometry.Polygon2D.Points">
      <summary>
            Polygon's points.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Polygon2D.#ctor(System.Int32)">
      <summary>
            Points only constructor.
            </summary>
      <param name="numPoints">The number of 2D points</param>
    </member>
    <member name="M:devDept.Geometry.Polygon2D.#ctor(System.Collections.Generic.IList{devDept.Geometry.Point2D})">
      <summary>
            Points only constructor.
            </summary>
      <param name="points">The list of 2D points</param>
    </member>
    <member name="M:devDept.Geometry.Polygon2D.#ctor(devDept.Geometry.Point2D[],devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            Points and bounding rectangle corners constructor.
            </summary>
      <param name="points">The list of 2D points</param>
      <param name="min">The polygon's bounding rectangle min point</param>
      <param name="max">The polygon's bounding rectangle max point</param>
    </member>
    <member name="M:devDept.Geometry.Polygon2D.UpdateBoundingRect">
      <summary>
            Update/initialize the polygon min and max 2D points.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Polygon2D.IsValid">
      <summary>
            Checks that Min and Max are not null/Nothing and that the polygon is closed.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:devDept.Geometry.Polygon2D.PointInsideBoundingRect(devDept.Geometry.Point2D)">
      <summary>
            Checks if the provided 2D point is inside the 2D polygon bounding rectangle.
            </summary>
      <param name="testPoint">The 2D point</param>
      <returns>True if the 2D point is inside the bounding rectangle of the 2D polygon, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Polygon2D.PointInsideOrOntoBoundingRect(devDept.Geometry.Point2D)">
      <summary>
            Checks if the provided 2D point is inside or onto the 2D polygon bounding rectangle.
            </summary>
      <param name="testPoint">The 2D point</param>
      <returns>True if the 2D point is inside or onto the bounding rectangle of the 2D polygon, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Polygon2D.IsPointInside(devDept.Geometry.Point2D)">
      <summary>
            Tests if a 2D point is inside the 2D polygon.
            </summary>
      <param name="testPoint">The test 2D point</param>
      <returns>True if the 2D point is inside, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Polygon2D.IsPointInside(devDept.Geometry.Point2D,System.Double)">
      <summary>
            Tests if a 2D point is inside or onto the 2D polygon.
            </summary>
      <param name="testPoint">The test 2D point</param>
      <param name="domainSize">The maximum size of the problem</param>
      <returns>The point status.</returns>
    </member>
    <member name="M:devDept.Geometry.Polygon2D.IsPolygonInside(devDept.Geometry.Polygon2D,System.Double)">
      <summary>
            Check the status of the subject polygon against the clip one.
            </summary>
      <param name="subject">Second polygon</param>
      <param name="domainSize">The 2D domain diagonal</param>
      <returns>The subject polygon status.</returns>
    </member>
    <member name="P:devDept.Geometry.Polygon2D.VertexCount">
      <summary>
            Gets Points.Count
            </summary>
    </member>
    <member name="M:devDept.Geometry.Polygon2D.IntersecWithCrossAndT(devDept.Geometry.Segment2D)">
      <summary>
            Computes the intersection (both cross and touch intersections) between this 2D polygon and the specified 2D segment.
            </summary>
      <param name="segment">The segment</param>
      <returns>A list of 2D intersection points.</returns>
    </member>
    <member name="M:devDept.Geometry.Polygon2D.IntersectWith(devDept.Geometry.Segment2D)">
      <summary>
            Checks if the specified 2D segment intersects with this 2D polygon.
            </summary>
      <param name="segment">The 2D segment</param>
      <returns>True if a cross intersection is found, false otherwise.</returns>
    </member>
    <member name="T:devDept.Geometry.Quaternion">
      <summary>
            Defines a rotation in three dimensions.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Quaternion.X">
      <summary>
            X term of this quaternion.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Quaternion.Y">
      <summary>
            Y term of this quaternion.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Quaternion.Z">
      <summary>
            Z term of this quaternion.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Quaternion.W">
      <summary>
            W term of this quaternion.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Quaternion.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Quaternion components constructor.
            </summary>
      <param name="x">The X component of this quaternion</param>
      <param name="y">The Y component of this quaternion</param>
      <param name="z">The Z component of this quaternion</param>
      <param name="w">The W component of this quaternion</param>
    </member>
    <member name="M:devDept.Geometry.Quaternion.#ctor(devDept.Geometry.Vector3D,System.Double)">
      <summary>
            Axis and angle constructor.
            </summary>
      <param name="rotAxis">The rotation axis (normalized)</param>
      <param name="rotAngleInDegrees">The rotation angle in degrees</param>
    </member>
    <member name="M:devDept.Geometry.Quaternion.#ctor(System.Double,System.Double,System.Double)">
      <summary>
            Creates a new Quaternion from specified yaw, pitch, and roll angles. 
            </summary>
      <param name="yaw">The yaw angle, in radians, around the y-axis.</param>
      <param name="pitch">The pitch angle, in radians, around the x-axis.</param>
      <param name="roll">The roll angle, in radians, around the z-axis.</param>
    </member>
    <member name="M:devDept.Geometry.Quaternion.ToEulerAngles(System.Double@,System.Double@,System.Double@)">
      <summary>
            Converts this quaternion to Euler angles.
            </summary>
      <param name="roll">Roll angle in radians</param>
      <param name="pitch">Pitch angle in radians</param>
      <param name="yaw">Yaw angle in radians</param>
      <remarks>Singularities at north/south poles (gimbal lock) are not handled by this method.</remarks>
    </member>
    <member name="M:devDept.Geometry.Quaternion.Clone">
      <summary>
            Creates a deep copy of this quaternion.
            </summary>
      <returns>The new quaternion object.</returns>
    </member>
    <member name="M:devDept.Geometry.Quaternion.FromAxisAngle(devDept.Geometry.Vector3D,System.Double)">
      <summary>
            Resets this Quaternion to the rotation specified.
            </summary>
      <param name="rotAxis">The rotation axis (normalized)</param>
      <param name="rotAngleInDegrees">The rotation angle in degrees</param>
    </member>
    <member name="M:devDept.Geometry.Quaternion.ToAxisAngle(devDept.Geometry.Vector3D@,System.Double@)">
      <summary>
            Gets current rotation.
            </summary>
      <param name="rotAxis">The rotation axis</param>
      <param name="rotAngleInDegrees">The rotation angle in degrees</param>
    </member>
    <member name="M:devDept.Geometry.Quaternion.ToMatrix(System.Double[0:,0:]@)">
      <summary>
            Gets current rotation.
            </summary>
      <param name="matrix">Rotation matrix</param>
    </member>
    <member name="M:devDept.Geometry.Quaternion.ToMatrixInverse(System.Double[0:,0:]@)">
      <summary>
            Gets current inverse rotation.
            </summary>
      <param name="matrix">Inverse rotation matrix</param>
      <remarks>Used internally to rotate the camera because it must move in the opposite direction.</remarks>
    </member>
    <member name="M:devDept.Geometry.Quaternion.Normalize">
      <summary>
            Normalizes this Quaternion. 
            </summary>
      <returns>True if the operation succeeded, false otherwise.</returns>
    </member>
    <member name="P:devDept.Geometry.Quaternion.Identity">
      <summary>
            Gets the identity Quaternion.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Quaternion.op_Multiply(devDept.Geometry.Quaternion,devDept.Geometry.Quaternion)">
      <summary>
            Multiplies the specified quaternion by another.
            </summary>
      <param name="left">First quaternion</param>
      <param name="right">Second quaternion</param>
      <returns>The Quaternion that is the product of multiplication.</returns>
    </member>
    <member name="M:devDept.Geometry.Quaternion.op_Multiply(devDept.Geometry.Quaternion,System.Double)">
      <summary>
            Multiplies the specified quaternion by a scalar.
            </summary>
      <param name="left">Quaternion</param>
      <param name="s">Scalar value</param>
      <returns>The Quaternion that is the product of multiplication.</returns>
    </member>
    <member name="M:devDept.Geometry.Quaternion.op_Multiply(System.Double,devDept.Geometry.Quaternion)">
      <summary>
            Multiplies the specified quaternion by a scalar.
            </summary>
      <param name="s">Scalar value</param>
      <param name="right">Quaternion</param>
      <returns>The Quaternion that is the product of multiplication.</returns>
    </member>
    <member name="M:devDept.Geometry.Quaternion.op_Addition(devDept.Geometry.Quaternion,devDept.Geometry.Quaternion)">
      <summary>
            Adds two quaternions.
            </summary>
      <param name="left">First quaternion</param>
      <param name="right">Second quaternion</param>
      <returns>The Quaternion resulted from the sum.</returns>
    </member>
    <member name="M:devDept.Geometry.Quaternion.ToString">
      <summary>
            Converts this Quaternion to a human readable string.
            </summary>
      <returns>A string that represents this Quaternion.</returns>
    </member>
    <member name="T:devDept.Geometry.Segment2D">
      <summary>
            Defines a 2D segment.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Segment2D.P0">
      <summary>
            Start point.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Segment2D.P1">
      <summary>
            End point.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Segment2D.#ctor">
      <summary>
            Empty constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Segment2D.#ctor(devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            Point2D constructor.
            </summary>
      <param name="p0">Start point</param>
      <param name="p1">End point</param>
    </member>
    <member name="M:devDept.Geometry.Segment2D.#ctor(devDept.Geometry.Point,devDept.Geometry.Point)">
      <summary>
            System.Drawing.Point constructor.
            </summary>
      <param name="p0">Start point</param>
      <param name="p1">End point</param>
    </member>
    <member name="M:devDept.Geometry.Segment2D.#ctor(System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Individual coordinates constructor.
            </summary>
      <param name="x0">The X value of start point</param>
      <param name="y0">The Y value of start point</param>
      <param name="x1">The X value of end point</param>
      <param name="y1">The Y value of end point</param>
    </member>
    <member name="M:devDept.Geometry.Segment2D.Clone">
      <summary>
            Creates a deep copy of this 2D segment.
            </summary>
      <returns>The new 2D segment.</returns>
    </member>
    <member name="P:devDept.Geometry.Segment2D.MidPoint">
      <summary>
            Gets the segment mid point.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Segment2D.Length">
      <summary>
            Gets the 2D segment length.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Segment2D.Normal">
      <summary>
            Gets the 2D segment normal vector (not normalized).
            </summary>
    </member>
    <member name="M:devDept.Geometry.Segment2D.Project(devDept.Geometry.Point2D)">
      <summary>
            Finds the point on the (infinite) line that is closest to given point.
            </summary>
      <param name="pt">Test point</param>
      <returns>The parameter of the point on the line that is closest to test point.</returns>
    </member>
    <member name="M:devDept.Geometry.Segment2D.ClosestPointTo(devDept.Geometry.Point2D)">
      <summary>
            Finds the point inside the segment that is closest to given point.
            </summary>
      <param name="pt">Test point</param>
      <returns>The parameter of the point on the line that is closest to test point.</returns>
    </member>
    <member name="M:devDept.Geometry.Segment2D.PointAt(System.Double)">
      <summary>
            Evaluates a point on (infinite) segment.
            </summary>
      <param name="t">Evaluation parameter</param>
      <returns>(1-t)*start + t*end</returns>
    </member>
    <member name="M:devDept.Geometry.Segment2D.Intersection(devDept.Geometry.Segment2D,devDept.Geometry.Segment2D,devDept.Geometry.Point2D@,devDept.Geometry.Point2D@,System.Double)">
      <summary>
            Computes the intersection of two 2D segments.
            </summary>
      <param name="s1">First segement</param>
      <param name="s2">Second segment</param>
      <param name="i0">Intersection point (when it exists)</param>
      <param name="i1">Endpoint of the intersect segment [i0, i1] (when it exists)</param>
      <param name="domainSize">The maximum diagonal size of the domain</param>
      <returns>The intersection type.</returns>
      <remarks>Be aware that both segments must have Lenght &gt; 0.</remarks>
    </member>
    <member name="M:devDept.Geometry.Segment2D.IntersectionLine(devDept.Geometry.Segment2D,devDept.Geometry.Segment2D,devDept.Geometry.Point2D@)">
      <summary>
            Computes the intersection of two infinite 2D lines.
            </summary>
      <param name="s1">First line</param>
      <param name="s2">Second line</param>
      <param name="i0">Intersection point (when it exists)</param>
      <returns>True if the intersection exists, false otherwise (parallel lines).</returns>
    </member>
    <member name="M:devDept.Geometry.Segment2D.Intersection(devDept.Geometry.Segment2D,devDept.Geometry.Segment2D,devDept.Geometry.Point2D@)">
      <summary>
            Computes the intersection of two 2D segments.
            </summary>
      <param name="s1">First line</param>
      <param name="s2">Second line</param>
      <param name="i0">Intersection point (when it exists)</param>
      <returns>True if the intersection exists, false otherwise (parallel or disjoint).</returns>
      <remarks>If return value is true and i0 is null, the segments are collinear and overlapping.</remarks>
      <remarks>Be aware that both segments must have Lenght &gt; 0.</remarks>
    </member>
    <member name="M:devDept.Geometry.Segment2D.IntersectionAndT(devDept.Geometry.Segment2D,devDept.Geometry.Segment2D,devDept.Geometry.Point2D@)">
      <summary>
            Computes the intersection of two 2D segments.
            </summary>
      <param name="s1">First line</param>
      <param name="s2">Second line</param>
      <param name="i0">Intersection point (when it exists)</param>
      <returns>True if the intersection exists, false otherwise (parallel disjoint or disjoint).</returns>
      <remarks>Here we return true even when the intersection is on the boundary of one of the two segments.</remarks>
    </member>
    <member name="P:devDept.Geometry.Segment2D.IsPoint">
      <summary>
            If true, the segment is a degenerated one (a point).
            </summary>
    </member>
    <member name="M:devDept.Geometry.Segment2D.ToString">
      <summary>
            Converts this 2D segment to a human readable string.
            </summary>
      <returns>A string that represents this 2D segment.</returns>
    </member>
    <member name="M:devDept.Geometry.Segment2D.ExtendBy(System.Double,System.Double)">
      <summary>
            Extends the segment of the amount provided.
            </summary>
      <param name="atStart">Extension amount at segment start</param>
      <param name="atEnd">Extension amount at segment end</param>
    </member>
    <member name="M:devDept.Geometry.Segment2D.AreCollinear(devDept.Geometry.Segment2D,devDept.Geometry.Segment2D)">
      <summary>
            Returns true if the two segments are collinear.
            </summary>
      <param name="s1">The first segment</param>
      <param name="s2">The second segment</param>
    </member>
    <member name="M:devDept.Geometry.Segment2D.AreOverlapping(devDept.Geometry.Segment2D,devDept.Geometry.Segment2D)">
      <summary>
            Returns true if the two segments are overlapping.
             </summary>
      <param name="seg1">The first segment</param>
      <param name="seg2">The second segment</param>
      <remarks>
             If the part of segment where s1 and s2 overlap is very small and it is close to one of the endpoints, it may returns false.
            </remarks>
    </member>
    <member name="T:devDept.Geometry.segmentIntersectionType">
      <summary>
            2D segment intersection type.
            </summary>
    </member>
    <member name="F:devDept.Geometry.segmentIntersectionType.Disjoint">
      <summary>
            Disjoint
            </summary>
    </member>
    <member name="F:devDept.Geometry.segmentIntersectionType.EndPointTouch">
      <summary>
            The two segments touch at end points (are contiguous)
            </summary>
    </member>
    <member name="F:devDept.Geometry.segmentIntersectionType.Touch">
      <summary>
            The intersection point is the end point of one of the segments
            </summary>
    </member>
    <member name="F:devDept.Geometry.segmentIntersectionType.Cross">
      <summary>
            Intersect in unique point i0
            </summary>
    </member>
    <member name="F:devDept.Geometry.segmentIntersectionType.OverlapInSegment">
      <summary>
            Overlap in segment from i0 to i1
            </summary>
    </member>
    <member name="F:devDept.Geometry.segmentIntersectionType.CollinearEndPointTouch">
      <summary>
            The two segments touch at end points and are collinear
            </summary>
    </member>
    <member name="T:devDept.Geometry.Segment3D">
      <summary>
            Defines a 3D segment.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Segment3D.P0">
      <summary>
            Start point.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Segment3D.P1">
      <summary>
            End point.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Segment3D.#ctor">
      <summary>
            Empty constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Segment3D.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Point3D constructor.
            </summary>
      <param name="p0">Start point</param>
      <param name="p1">End point</param>
    </member>
    <member name="M:devDept.Geometry.Segment3D.#ctor(devDept.Geometry.Vector3D)">
      <summary>
            3D vector constructor.
            </summary>
      <param name="p1">The 3D vector</param>
    </member>
    <member name="M:devDept.Geometry.Segment3D.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
      <summary>
            Individual coordinates constructor.
            </summary>
      <param name="x0">The X value of start point</param>
      <param name="y0">The Y value of start point</param>
      <param name="z0">The Z value of start point</param>
      <param name="x1">The X value of end point</param>
      <param name="y1">The Y value of end point</param>
      <param name="z1">The Z value of end point</param>
    </member>
    <member name="M:devDept.Geometry.Segment3D.Clone">
      <summary>
            Creates a deep copy of this 3D segment.
            </summary>
      <returns>The new 3D segment.</returns>
    </member>
    <member name="P:devDept.Geometry.Segment3D.IsPoint">
      <summary>
            If true, the segment is a degenerated one (a point).
            </summary>
    </member>
    <member name="M:devDept.Geometry.Segment3D.ExtendTo(devDept.Geometry.Point3D)">
      <summary>
            Extends (if necessary) the segment to the provided 3D point.
            </summary>
      <param name="extPt">The extension point</param>
    </member>
    <member name="M:devDept.Geometry.Segment3D.IsOnAxis(devDept.Geometry.Vector3D,devDept.Geometry.Point3D)">
      <summary>
            Returns true if the segment lays on the axis defined by the 3D point <paramref name="center" /> and the direction <paramref name="dir" />.
            </summary>
      <param name="dir">The 3D direction vector</param>
      <param name="center">The 3D center point</param>
      <returns>True if the segments is on the axis, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Segment3D.IsInPlane(devDept.Geometry.Plane,System.Double)">
      <summary>
            Checks if the 3D segment lays on the specified plane.
            </summary>
      <param name="plane">The plane to test</param>
      <param name="tol">The tolerance</param>
      <returns>True if the segment lays on the plane, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Segment3D.Project(devDept.Geometry.Point3D)">
      <summary>
            Finds the point on the (infinite) line that is closest to given point.
            </summary>
      <param name="pt">Test point</param>
      <returns>The parameter of the point on the line that is closest to test point.</returns>
    </member>
    <member name="M:devDept.Geometry.Segment3D.ClosestPointTo(devDept.Geometry.Point3D)">
      <summary>
            Finds the point inside the segment that is closest to given point.
            </summary>
      <param name="pt">Test point</param>
      <returns>The parameter of the point on the segment that is closest to test point.</returns>
    </member>
    <member name="M:devDept.Geometry.Segment3D.PointAt(System.Double)">
      <summary>
            Evaluates a point on (infinite) segment.
            </summary>
      <param name="t">Evaluation parameter</param>
      <returns>(1-t)*start + t*end</returns>
    </member>
    <member name="P:devDept.Geometry.Segment3D.MidPoint">
      <summary>
            Gets the 3D segment middle point.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Segment3D.Length">
      <summary>
            Gets the 3D segment length.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Segment3D.LengthSquared">
      <summary>
            Gets the 3D segment length squared.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Segment3D.IntersectWith(devDept.Geometry.Plane,devDept.Geometry.Point3D@)">
      <summary>
            Intersects a 3D segment with a plane.
            </summary>
      <param name="plane">The plane</param>
      <param name="intPoint">The intersection point (if exists)</param>
      <returns>True if the intersection was found, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Segment3D.IntersectWith(devDept.Geometry.Plane,System.Boolean,devDept.Geometry.Point3D@)">
      <summary>
            Intersects a 3D segment with a plane.
            </summary>
      <param name="plane">The plane</param>
      <param name="infinite">If true, the Segment3D is treated as an infinite line</param>
      <param name="intPoint">The intersection point (if exists)</param>
      <returns>True if the intersection was found, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Segment3D.IntersectWith(devDept.Geometry.PlaneEquation)">
      <summary>
            Intersects the 3D segment with a plane.
            </summary>
      <param name="pe">The plane equation</param>
      <returns>True if the intersection was found, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Segment3D.IntersectWith(devDept.Geometry.PlaneEquation,System.Boolean)">
      <summary>
            Intersects the 3D segment with a plane.
            </summary>
      <param name="pe">The plane equation</param>
      <param name="infinite">If true, the Segment3D is treated as an infinite line</param>
      <returns>True if the intersection was found, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Segment3D.IntersectWith(devDept.Geometry.PlaneEquation,devDept.Geometry.Point3D@)">
      <summary>
            Intersects the 3D segment with a plane.
            </summary>
      <param name="pe">The plane equation</param>
      <param name="intPoint">The intersection point (if exists)</param>
      <returns>True if the intersection was found, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Segment3D.IntersectWith(devDept.Geometry.PlaneEquation,System.Boolean,devDept.Geometry.Point3D@)">
      <summary>
            Intersects the 3D segment with a plane.
            </summary>
      <param name="pe">The plane equation</param>
      <param name="infinite">If true, the Segment3D is treated as an infinite line</param>
      <param name="intPoint">The intersection point (if exists)</param>
      <returns>True if the intersection was found, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Segment3D.IntersectWithInternal(devDept.Geometry.PlaneEquation,devDept.Geometry.Point3D@,System.Boolean,System.Boolean)">
      <summary>
            Intersects the 3D segment with a plane. (For internal use only)
            </summary>
    </member>
    <member name="M:devDept.Geometry.Segment3D.IntersectWith(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D@)">
      <summary>
            Intersects the 3D segment with a triangle.
            </summary>
      <param name="p1">First triangle vertex</param>
      <param name="p2">Second triangle vertex</param>
      <param name="p3">Third triangle vertex</param>
      <param name="intPoint">The intersection point (if exists)</param>
      <returns>True if the intersection was found, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Segment3D.IntersectWith(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Boolean,devDept.Geometry.Point3D@,System.Double@,System.Double@)">
      <summary>
            Intersects the 3D segment with a triangle.
            </summary>
      <param name="p1">First triangle vertex</param>
      <param name="p2">Second triangle vertex</param>
      <param name="p3">Third triangle vertex</param>
      <param name="ray">When true, it considers a ray starting from P0 to infinite</param>
      <param name="intPoint">The intersection point (if exists)</param>
      <param name="s">The triangle s coordinate</param>
      <param name="t">The triangle t coordinate</param>
      <returns>True if the intersection was found, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Segment3D.IntersectWith(devDept.Geometry.Point3D,devDept.Geometry.Point3D,System.Boolean)">
      <summary>
            Intersects the 3D segment with an Axis-Aligned Box.
            </summary>
      <param name="boxMin">the min corner of the box</param>
      <param name="boxMax">the max corner of the box</param>
      <param name="infinite">If true, the Segment3D is treated as an infinite line</param>
      <param name="seg">The 3D segment</param>
      <returns>True if there is an intersection, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Segment3D.IntersectWithInternal(System.Int32[],devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Vector3D,System.Double,System.Double)">
      <summary>
            Intersects the 3D segment with an Axis-Aligned Box. (For internal use only)
            </summary>
    </member>
    <member name="M:devDept.Geometry.Segment3D.Intersection(devDept.Geometry.Segment3D,devDept.Geometry.Segment3D,System.Boolean,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@)">
      <summary>
            Gets the end points of the shortest segment perpendicular to two 3D segments, when it exists and is unique.
            </summary>
      <param name="segA">The first segment</param>
      <param name="segB">The second segment</param>
      <param name="infinite">If true, the Segment3Ds are treated as an infinite lines</param>
      <param name="pointOnA">The end point on <paramref name="segA" /></param>
      <param name="pointOnB">The end point on <paramref name="segB" /></param>
      <returns>True if there is one shortest segment perpendicular to segA and segB, false otherwise.</returns>
      <remarks>If <paramref name="pointOnA" /> and <paramref name="pointOnB" /> coincide, there is an intersection between the two segments. When the segments are parallel, it always returns false and the points are null.</remarks>
    </member>
    <member name="M:devDept.Geometry.Segment3D.Intersection(devDept.Geometry.Segment3D,devDept.Geometry.Segment3D,System.Boolean,devDept.Geometry.Point3D@,devDept.Geometry.Point3D@,System.Double@,System.Double@)">
      <summary>
            Gets the end points of the shortest segment perpendicular to two 3D segments, when it exists and is unique.
            </summary>
      <param name="segA">The first segment</param>
      <param name="segB">The second segment</param>
      <param name="infinite">If true, the Segment3Ds are treated as an infinite lines</param>
      <param name="pointOnA">The end point on <paramref name="segA" /></param>
      <param name="pointOnB">The end point on <paramref name="segB" /></param>
      <param name="paramOnA">The parameter of the end point on <paramref name="segA" /></param>
      <param name="paramOnB">The parameter of the end point on <paramref name="segB" /></param>
      <returns>True if there is one shortest segment perpendicular to segA and segB, false otherwise.</returns>
      <remarks>If <paramref name="pointOnA" /> and <paramref name="pointOnB" /> coincide, there is an intersection between the two segments. When the segments are parallel, it always returns false and the points are null.</remarks>
    </member>
    <member name="M:devDept.Geometry.Segment3D.ToString">
      <summary>
            Converts this 3D segment to a human readable string.
            </summary>
      <returns>A string that represents this 3D segment.</returns>
    </member>
    <member name="M:devDept.Geometry.Segment3D.AreCollinear(devDept.Geometry.Segment3D,devDept.Geometry.Segment3D)">
      <summary>
            Returns true if the two segments are collinear.
            </summary>
      <param name="s1">The first segment</param>
      <param name="s2">The second segment</param>
    </member>
    <member name="M:devDept.Geometry.Segment3D.AreOverlapping(devDept.Geometry.Segment3D,devDept.Geometry.Segment3D)">
      <summary>
            Returns true if the two segments are overlapping.
             </summary>
      <param name="seg1">The first segment</param>
      <param name="seg2">The second segment</param>
      <remarks>If the part of segment where s1 and s2 overlap is very small and it is close to one of the endpoints, it may returns false.</remarks>
    </member>
    <member name="T:devDept.Geometry.Size2D">
      <summary>
            Defines a 2D size. 
            </summary>
    </member>
    <member name="M:devDept.Geometry.Size2D.#ctor(System.Double,System.Double)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Size2D.#ctor(devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            Two 2D points constructor.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Size2D.Diagonal">
      <summary>
            Returns the rectangle diagonal length.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Size2D.Min">
      <summary>
            Gets the minimum rectangle dimension.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Size2D.Max">
      <summary>
            Gets the maximum rectangle dimension.
            </summary>
    </member>
    <member name="T:devDept.Geometry.Size3D">
      <summary>
            Defines a 3D size. 
            </summary>
    </member>
    <member name="M:devDept.Geometry.Size3D.#ctor(System.Double,System.Double,System.Double)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Size3D.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Two 3D points constructor.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Size3D.Diagonal">
      <summary>
            Gets the box diagonal length.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Size3D.Min">
      <summary>
            Gets the minimum box dimension.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Size3D.Max">
      <summary>
            Gets the maximum box dimension.
            </summary>
    </member>
    <member name="T:devDept.Geometry.Transformation">
      <summary>4x4 transformation matrix.</summary>
      <example>
            Usage example.
            	<code lang="CS" title="[New Example]">
            Transformation t = new Translation(10, 0, 0);
            Transformation r = new Rotation(Math.PI/6, Vector3D.AxisY); // angle in radians
             
            Transformation c = t * r; // combines the two transformations (order matters)
             
            Point3D pt = new (10, 20, 30);
             
            Point3D newPt = c * p; // transforms the point pt
            </code><code lang="VB" title="[New Example]">
            Dim t As Transformation = New Translation(10, 0, 0)
            Dim r As Transformation = New Rotation(Math.PI/6, Vector3D.AxisY) ' angle in radians
             
            Dim c As Transformation = t * r ' combines the two transformations (order matters)
             
            Dim pt As Point3D = New (10, 20, 30)
             
            Dim ptNew As Point3D = c * p ' transforms the point pt
            </code></example>
    </member>
    <member name="M:devDept.Geometry.Transformation.#ctor">
      <summary>
            Zero matrix constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Transformation.#ctor(System.Double)">
      <summary>
            Diagonal matrix constructor.
            </summary>
      <param name="d">Diagonal value</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.#ctor(System.Double[0:,0:])">
      <summary>4x4 square array of doubles constructor.</summary>
      <param name="m">The matrix (deeply copied)</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.#ctor(System.Double[],System.Boolean)">
      <summary>16x array of doubles constructor.</summary>
      <param name="m">The matrix as an array of 16 doubles (deeply copied) ordered by row or by column</param>
      <param name="byRow">If true the matrix is loaded by row, else by column</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.IsIdentity(System.Double)">
      <summary>
            Check if the transformation is the 'Identity' one.
            1 0 0 0
            0 1 0 0
            0 0 1 0
            0 0 0 1
            </summary>
      <param name="zeroTolerance">Test tolerance</param>
      <returns>Returns true if matrix is the identity transformation.</returns>
    </member>
    <member name="M:devDept.Geometry.Transformation.IsIdentity">
      <summary>
            Check if the transformation is the 'Identity' one.
            1 0 0 0
            0 1 0 0
            0 0 1 0
            0 0 0 1
            </summary>
      <returns>Returns true if matrix is the identity transformation.</returns>
    </member>
    <member name="M:devDept.Geometry.Transformation.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D)">
      <summary>
            As frame constructor.
            </summary>
      <param name="P">3D point</param>
      <param name="X">X axis vector (unit length)</param>
      <param name="Y">Y axis vector (unit length)</param>
      <param name="Z">Z axis vector (unit length)</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.Clone">
      <summary>
            Creates a deep copy of this transformation.
            </summary>
      <returns>The new transformation object.</returns>
    </member>
    <member name="M:devDept.Geometry.Transformation.Zero">
      <summary>
            All zeros.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Transformation.Identity">
      <summary>
            Diagonal is (1,1,1,1).
            </summary>
    </member>
    <member name="M:devDept.Geometry.Transformation.Diagonal(System.Double)">
      <summary>
            Diagonal 3x3 with bottom row = 0,0,0,1.
            </summary>
      <param name="d">Diagonal value</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.Scaling(System.Double,System.Double,System.Double)">
      <summary>
            Creates non-uniform scale transformation with the origin as a fixed point.
            </summary>
      <param name="sx">Scale factor along X</param>
      <param name="sy">Scale factor along Y</param>
      <param name="sz">Scale factor along Z</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.Scaling(devDept.Geometry.Vector3D)">
      <summary>
            Creates non-uniform scale transformation with the origin as a fixed point.
            </summary>
      <param name="sv">Scale vector</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.Scaling(devDept.Geometry.Point3D,System.Double)">
      <summary>
            Create uniform scale transformation with a specified fixed point.
            </summary>
      <param name="fixedPoint">Fixed point</param>
      <param name="scaleFactor">Scale factor</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.Scaling(devDept.Geometry.Point3D,System.Double,System.Double,System.Double)">
      <summary>
            Create a non-uniform scale transformation with a specified fixed point.
            </summary>
      <param name="fixedPoint">Fixed point</param>
      <param name="sx">Scale factor along X</param>
      <param name="sy">Scale factor along Y</param>
      <param name="sz">Scale factor along Z</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.Translation(System.Double,System.Double,System.Double)">
      <summary>
            Creates a new transformation of translation.
            Right column is (dx, dy, dz, 1).
            </summary>
      <param name="dx">Amount in X</param>
      <param name="dy">Amount in Y</param>
      <param name="dz">Amount in Z</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.Translation(devDept.Geometry.Vector3D)">
      <summary>
            Creates a new transformation of translation.
            Right column is (v.X, v.Y, v.Z, 1).
            </summary>
      <param name="v">Delta vector</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.PlanarProjection(devDept.Geometry.Plane)">
      <summary>
            Get transformation that projects to a plane. This transformation maps a 3D point P to the point plane.ClosestPointTo(Q).
            </summary>
      <param name="plane">Plane to project to</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.op_Multiply(devDept.Geometry.Transformation,devDept.Geometry.Point2D)">
      <summary>
            Applies transformation to a 2D point.
            </summary>
      <param name="t">The transformation</param>
      <param name="p">The point</param>
      <returns>The transformed point.</returns>
    </member>
    <member name="M:devDept.Geometry.Transformation.op_Multiply(devDept.Geometry.Transformation,devDept.Geometry.Point3D)">
      <summary>
            Applies transformation to a 3D point.
            </summary>
      <param name="t">The transformation</param>
      <param name="p">The point</param>
      <returns>The transformed point.</returns>
    </member>
    <member name="M:devDept.Geometry.Transformation.op_Multiply(devDept.Geometry.Transformation,devDept.Geometry.PointRGB)">
      <summary>
            Applies transformation to a RGB point.
            </summary>
      <param name="t">The transformation</param>
      <param name="p">The point</param>
      <returns>The transformed point.</returns>
    </member>
    <member name="M:devDept.Geometry.Transformation.op_Multiply(devDept.Geometry.Transformation,devDept.Geometry.Point4D)">
      <summary>
            Applies transformation to a 4D point.
            </summary>
      <param name="t">The transformation</param>
      <param name="h">The point</param>
      <returns>The transformed point.</returns>
    </member>
    <member name="M:devDept.Geometry.Transformation.op_Multiply(devDept.Geometry.Transformation,devDept.Geometry.Vector2D)">
      <summary>
            Applies transformation to a 2D vector.
            </summary>
      <param name="t">The transformation</param>
      <param name="v">The point</param>
      <returns>The transformed vector.</returns>
    </member>
    <member name="M:devDept.Geometry.Transformation.op_Multiply(devDept.Geometry.Transformation,devDept.Geometry.Vector3D)">
      <summary>
            Applies transformation to a 3D vector.
            </summary>
      <param name="t">The transformation</param>
      <param name="v">The point</param>
      <returns>The transformed vector.</returns>
    </member>
    <member name="M:devDept.Geometry.Transformation.Transpose">
      <summary>
            Transposes the 4x4 matrix.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Transformation.Invert">
      <summary>
            Inverts the 4x4 matrix.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Transformation.Rotation(System.Double,devDept.Geometry.Vector3D)">
      <summary>
            Creates a new transformation of rotation.
            </summary>
      <param name="angleInRadians">Angle in radians</param>
      <param name="axis">Rotation axis</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.Rotation(System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Creates a new transformation of rotation.
            </summary>
      <param name="angleInRadians">Angle in radians</param>
      <param name="axisStart">Axis start point</param>
      <param name="axisEnd">Axis end point</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.Rotation(System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D)">
      <summary>
            Creates a new transformation of rotation.
            </summary>
      <param name="angleInRadians">Angle in radians</param>
      <param name="axis">Rotation axis</param>
      <param name="center">Center point</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.Rotation(devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,devDept.Geometry.Point3D)">
      <summary>
            Creates a new transformation of rotation.
            </summary>
      <param name="startDir">StartPoint direction</param>
      <param name="endDir">End direction</param>
      <param name="center">Center point</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.Rotation(devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D)">
      <summary>
        <para> Creates a new transformation of rotation.</para>
        <para>The frames should be right hand orthonormal frames (unit vectors with Z = X X
                Y). The resulting rotation fixes the origin (0,0,0), maps initial X to final X,
                initial Y to final Y, and initial Z to final Z.</para>
      </summary>
      <param name="X0">First frame X axis</param>
      <param name="Y0">First frame Y axis</param>
      <param name="Z0">First frame Z axis</param>
      <param name="X1">Second frame X axis</param>
      <param name="Y1">Second frame Y axis</param>
      <param name="Z1">Second frame Z axis</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.Rotation(devDept.Geometry.Plane,devDept.Geometry.Plane)">
      <summary>
        <para>Creates a new transformation of rotation.</para>
        <para>The frames should be right hand orthonormal frames (unit vectors with Z = X X
                Y). The resulting rotation fixes the origin (0,0,0), maps initial X to final X,
                initial Y to final Y, and initial Z to final Z.</para>
        <para>If the initial and final center are equal, then that center point is the
                fixed point of the rotation. If the initial and final point differ, then the
                resulting transform is the composition of a rotation fixing P0 and translation from
                P0 to P1. The resulting transformation maps P0 to P1, P0+X0 to P1+X1, ...</para>
      </summary>
      <param name="plane0">First frame</param>
      <param name="plane1">Second frame</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.Rotation(devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D)">
      <summary>
        <para>Creates a new transformation of rotation.</para>
        <para>The frames should be right hand orthonormal frames (unit vectors with Z = X X
                Y). The resulting rotation fixes the origin (0,0,0), maps initial X to final X,
                initial Y to final Y, and initial Z to final Z.</para>
        <para>If the initial and final center are equal, then that center point is the
                fixed point of the rotation. If the initial and final point differ, then the
                resulting transform is the composition of a rotation fixing P0 and translation from
                P0 to P1. The resulting transformation maps P0 to P1, P0+X0 to P1+X1, ...</para>
      </summary>
      <param name="P0">First frame Origin</param>
      <param name="X0">First frame X axis</param>
      <param name="Y0">First frame Y axis</param>
      <param name="Z0">First frame Z axis</param>
      <param name="P1">Second frame Origin</param>
      <param name="X1">Second frame X axis</param>
      <param name="Y1">Second frame Y axis</param>
      <param name="Z1">Second frame Z axis</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.Mirror(devDept.Geometry.Plane)">
      <summary>
            Mirror transformation.
            </summary>
      <param name="plane">Mirror plane</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.Mirror(devDept.Geometry.Point3D,devDept.Geometry.Vector3D)">
      <summary>
            Mirror transformation.
            </summary>
      <param name="P">Point on mirror plane</param>
      <param name="N">AxisZ of mirror plane</param>
    </member>
    <member name="P:devDept.Geometry.Transformation.Item(System.Int32,System.Int32)">
      <summary>Direct access on matrix values.</summary>
    </member>
    <member name="M:devDept.Geometry.Transformation.op_Addition(devDept.Geometry.Transformation,devDept.Geometry.Transformation)">
      <summary>
            Adds two transformations.
            </summary>
      <param name="left">Left one</param>
      <param name="right">Right one</param>
      <returns>The resulting transformation</returns>
    </member>
    <member name="M:devDept.Geometry.Transformation.op_Subtraction(devDept.Geometry.Transformation,devDept.Geometry.Transformation)">
      <summary>
            Subtract two transformations.
            </summary>
      <param name="left">Left one</param>
      <param name="right">Right one</param>
      <returns>The resulting transformation</returns>
    </member>
    <member name="M:devDept.Geometry.Transformation.ChangeBasis(devDept.Geometry.Plane,devDept.Geometry.Plane)">
      <summary>
             Computes a change of basis transformation.
             </summary>
      <remarks>
        <para>If you have points defined with respect to planes, the version of
                ChangeBasis() that takes two planes computes the transformation to change
                coordinates from one plane to another. The predefined world plane Plane.XY can be
                used as an argument.</para>
        <para>If P = plane0.Evaluate(a0, b0, c0)</para>
        <para>and (a1,b1,c1) = ChangeBasis(plane0, plane1) * new Point3D(a0, b0, c0)</para>
        <para>then P = plane1.Evaluate(a1, b1, c1)</para>
        <para>The version of ChangeBasis() that takes six vectors maps (a0, b0, c0) to (a1,
                b1, c1) where a0*X0 + b0*Y0 + c0*Z0 = a1*X1 + b1*Y1 + c1*Z1.</para>
        <para>The version of ChangeBasis() that takes six vectors with center points maps
                (a0, b0, c0) to (a1, b1, c1) where P0 + a0*X0 + b0*Y0 + c0*Z0 = P1 + a1*X1 + b1*Y1
                + c1*Z1.</para>
        <para>The change of basis transformation is not the same as the rotation
                transformation that rotates one orthonormal frame to another. See the Rotation()
                method.</para>
      </remarks>
      <returns>True if the operation succeeded, false otherwise</returns>
      <param name="initial">Initial plane</param>
      <param name="final">Final plane</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.ChangeBasis(devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D)">
      <summary>
            Computes a change of basis transformation.
            </summary>
      <param name="X0">Initial frame X (X,Y,Z = arbitrary basis)</param>
      <param name="Y0">Initial frame Y</param>
      <param name="Z0">Initial frame Z</param>
      <param name="X1">Final frame X (X,Y,Z = arbitrary basis)</param>
      <param name="Y1">Final frame Y</param>
      <param name="Z1">Final frame Z</param>
      <returns>True if the operation succeeded, false otherwise</returns>
    </member>
    <member name="M:devDept.Geometry.Transformation.ChangeBasis(devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D)">
      <summary>
            Computes a change of basis transformation. 
            </summary>
      <remarks>
            Change of basis transformations and rotation transformations
            are often confused.  This is a change of basis transformation.
            If Q = P0 + a0*X0 + b0*Y0 + c0*Z0 = P1 + a1*X1 + b1*Y1 + c1*Z1
            then this transform will map the point (a0,b0,c0) to (a1,b1,c1)
            </remarks>
      <param name="P0">Initial frame center</param>
      <param name="X0">Initial frame X (X,Y,Z = arbitrary basis)</param>
      <param name="Y0">Initial frame Y</param>
      <param name="Z0">Initial frame Z</param>
      <param name="P1">Final frame center</param>
      <param name="X1">Final frame X (X,Y,Z = arbitrary basis)</param>
      <param name="Y1">Final frame Y</param>
      <param name="Z1">Final frame Z</param>
      <returns>True if the operation succeeded, false otherwise.</returns>
    </member>
    <member name="P:devDept.Geometry.Transformation.IsTranslation">
      <summary>
            Checks if the transformation is translation only.
            </summary>
      <returns>True if the transformation is translation only, false otherwise.</returns>
    </member>
    <member name="P:devDept.Geometry.Transformation.IsScaled">
      <summary>
            Checks if the transformation contains scaling.
            </summary>
      <returns>True if the transformation contains scaling, false otherwise.</returns>
    </member>
    <member name="P:devDept.Geometry.Transformation.Matrix">
      <summary>
            Gets or sets the 4x4 matrix.
            </summary>
      <remarks>The first index is the row index, the second is the column index.</remarks>
    </member>
    <member name="P:devDept.Geometry.Transformation.MatrixAsVectorByRow">
      <summary>Gets the 4x4 matrix as an array of doubles ordered by row.</summary>
    </member>
    <member name="P:devDept.Geometry.Transformation.MatrixAsVectorByColumn">
      <summary>Gets the 4x4 matrix as an array of doubles ordered by column.</summary>
    </member>
    <member name="P:devDept.Geometry.Transformation.ScaleFactorX">
      <summary>
            Gets the scale factor along X.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Transformation.ScaleFactorY">
      <summary>
            Gets the scale factor along Y.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Transformation.ScaleFactorZ">
      <summary>
            Gets the scale factor along Z.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Transformation.IsScaleFactorUniform">
      <summary>
            Returns true if the scale factor of the transformation is the same in the X, Y and Z directions.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Transformation.IsScaleFactorUniformForPlanar(devDept.Geometry.Plane,System.Double@)">
      <summary>
            Returns true if the scale factor of the transformation is the same in the two directions of the plane.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Transformation.IsReversed">
      <summary>
            Returns true if the transformation is orientation-reversing, i.e. if the determinant of the 3x3 submatrix is smaller than zero.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Transformation.Dump">
      <summary>
            Dumps the matrix on Console window.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Transformation.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Transformation.GetXElement">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Transformation.GetTransformationForNormals">
      <summary>
            Gets the transformation to transform the normals (inverse transpose of the upper 3x3 matrix).
            </summary>
      <returns>The transformation.</returns>
    </member>
    <member name="T:devDept.Geometry.Identity">
      <summary>
            Identity transformation.
            </summary>
      <seealso cref="T:devDept.Geometry.Transformation">Transformation Class</seealso>
    </member>
    <member name="M:devDept.Geometry.Identity.#ctor">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Identity.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.Translation">
      <summary>
            Translation transformation.
            </summary>
      <seealso cref="T:devDept.Geometry.Transformation">Transformation Class</seealso>
    </member>
    <member name="M:devDept.Geometry.Translation.#ctor(System.Double,System.Double,System.Double)">
      <summary>
            Standard constructor.
            </summary>
      <param name="dx">Amount in X</param>
      <param name="dy">Amount in Y</param>
      <param name="dz">Amount in Z</param>
    </member>
    <member name="M:devDept.Geometry.Translation.#ctor(devDept.Geometry.Vector3D)">
      <summary>
            3D vector constructor.
            </summary>
      <param name="v">Delta vector</param>
    </member>
    <member name="M:devDept.Geometry.Translation.#ctor(devDept.Geometry.Vector2D)">
      <summary>
            2D vector constructor.
            </summary>
      <param name="v">Delta vector</param>
    </member>
    <member name="M:devDept.Geometry.Translation.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Translation.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.Rotation">
      <summary>
            Rotation transformation.
            </summary>
      <seealso cref="T:devDept.Geometry.Transformation" />
    </member>
    <member name="M:devDept.Geometry.Rotation.#ctor(System.Double,devDept.Geometry.Vector3D)">
      <summary>
            Angle and axis constructor.
            </summary>
      <param name="angleInRadians">Angle in radians</param>
      <param name="axis">Rotation axis passign through origin</param>
    </member>
    <member name="M:devDept.Geometry.Rotation.#ctor(System.Double,devDept.Geometry.Vector3D,devDept.Geometry.Point3D)">
      <summary>
            Angle, axis and center point constructor.
            </summary>
      <param name="angleInRadians">Angle in radians</param>
      <param name="axis">Rotation axis</param>
      <param name="center">Center point</param>
    </member>
    <member name="M:devDept.Geometry.Rotation.#ctor(System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Angle, axis start point and end point constructor.
            </summary>
      <param name="angleInRadians">Angle in radians</param>
      <param name="axisStart">Axis start point</param>
      <param name="axisEnd">Axis end point</param>
    </member>
    <member name="M:devDept.Geometry.Rotation.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Rotation.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.Scaling">
      <summary>
            Scale transformation.
            </summary>
      <seealso cref="T:devDept.Geometry.Transformation" />
    </member>
    <member name="M:devDept.Geometry.Scaling.#ctor(System.Double)">
      <summary>
            Uniform scale factor constructor.
            </summary>
      <param name="factor">Scale factor</param>
    </member>
    <member name="M:devDept.Geometry.Scaling.#ctor(System.Double,System.Double,System.Double)">
      <summary>
            Non-uniform scale factor constructor.
            </summary>
      <param name="sx">Scale factor along X</param>
      <param name="sy">Scale factor along Y</param>
      <param name="sz">Scale factor along Z</param>
    </member>
    <member name="M:devDept.Geometry.Scaling.#ctor(devDept.Geometry.Vector3D)">
      <summary>
            3D vector constructor.
            </summary>
      <param name="sv">Scale vector</param>
    </member>
    <member name="M:devDept.Geometry.Scaling.#ctor(devDept.Geometry.Point3D,System.Double)">
      <summary>
            3D point and scale factor constructor.
            </summary>
      <param name="fixedPoint">Fixed point</param>
      <param name="factor">Scale factor</param>
    </member>
    <member name="M:devDept.Geometry.Scaling.#ctor(devDept.Geometry.Point3D,System.Double,System.Double,System.Double)">
      <summary>
            3D point and scale factors constructor.
            </summary>
      <param name="fixedPoint">Fixed point</param>
      <param name="sx">Scale factor along X</param>
      <param name="sy">Scale factor along Y</param>
      <param name="sz">Scale factor along Z</param>
    </member>
    <member name="M:devDept.Geometry.Scaling.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Scaling.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.Mirror">
      <summary>
            Mirror transformation.
            </summary>
      <seealso cref="T:devDept.Geometry.Transformation" />
    </member>
    <member name="M:devDept.Geometry.Mirror.#ctor(devDept.Geometry.Plane)">
      <summary>
            Standard constructor.
            </summary>
      <param name="plane">Mirror plane</param>
    </member>
    <member name="M:devDept.Geometry.Mirror.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Mirror.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.Align3D">
      <summary>
            Transformation that aligns an orthonormal frame with another.
            </summary>
      <seealso cref="T:devDept.Geometry.Transformation" />
    </member>
    <member name="M:devDept.Geometry.Align3D.#ctor(devDept.Geometry.Plane,devDept.Geometry.Plane)">
      <summary>
            Standard constructor: builds a transformation that brings originalFrame onto destinationFrame.
            </summary>
      <param name="originalFrame">First frame</param>
      <param name="destinationFrame">Second frame</param>
    </member>
    <member name="M:devDept.Geometry.Align3D.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Standard constructor.
            </summary>
      <param name="p1A">First point of first frame</param>
      <param name="p1B">First point of second frame</param>
      <param name="p2A">Second point of first frame</param>
      <param name="p2B">Second point of second frame</param>
      <param name="p3A">Third point of first frame</param>
      <param name="p3B">Third point of second frame</param>
      <remarks>The two frames are orthonormal, obtained with the plane constructor by three points.</remarks>
    </member>
    <member name="M:devDept.Geometry.Align3D.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor for deserializing objects.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="M:devDept.Geometry.Align3D.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance with the data needed to serialize the target object.
            </summary>
      <param name="info">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> instance that defines the serialized data.</param>
      <param name="context">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> instance that contains the serialized data.</param>
    </member>
    <member name="T:devDept.Geometry.Vector2D">
      <summary>
            Defines a 2D vector.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Vector2D.X">
      <summary>
            X coordinate value.
            </summary>
    </member>
    <member name="F:devDept.Geometry.Vector2D.Y">
      <summary>
            Y coordinate value.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector2D.#ctor">
      <summary>
            Empty constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector2D.#ctor(System.Double,System.Double)">
      <summary>
            Standard constructor.
            </summary>
      <param name="x">Vector's X component</param>
      <param name="y">Vector's Y component</param>
    </member>
    <member name="M:devDept.Geometry.Vector2D.#ctor(devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            Two 2D points constructor. A 2D vector with direction from P0 to P1.
            </summary>
      <param name="P0">First point</param>
      <param name="P1">Second point</param>
    </member>
    <member name="M:devDept.Geometry.Vector2D.#ctor(System.Double[])">
      <summary>
            Double array constructor.
            </summary>
      <param name="v">The array of doubles</param>
    </member>
    <member name="M:devDept.Geometry.Vector2D.Clone">
      <summary>
            Creates a deep copy of this 2D vector.
            </summary>
      <returns>The new 2D vector.</returns>
    </member>
    <member name="M:devDept.Geometry.Vector2D.ToArray">
      <summary>
            Returns an array of vector's coordinates.
            </summary>
      <returns>The double array.</returns>
    </member>
    <member name="M:devDept.Geometry.Vector2D.IsValid">
      <summary>
            Returns true if the vector's coordinates are reasonable values.
            </summary>
      <returns>True if the vector is valid, false otherwise.</returns>
    </member>
    <member name="P:devDept.Geometry.Vector2D.MaximumCoordinate">
      <summary>
            Gets the absolute value of the maximum coordinate.
            </summary>
      <returns>The absolute value of the maximum coordinate.</returns>
    </member>
    <member name="M:devDept.Geometry.Vector2D.op_Multiply(System.Double,devDept.Geometry.Vector2D)">
      <summary>
            Multiplication between a scalar value and a 2D vector.
            </summary>
      <param name="s">Scalar value</param>
      <param name="v">The 2D vector</param>
    </member>
    <member name="M:devDept.Geometry.Vector2D.op_Multiply(devDept.Geometry.Vector2D,System.Double)">
      <summary>
            Multiplication between a scalar value and a 2D vector.
            </summary>
      <param name="s">Scalar value</param>
      <param name="v">The 2D vector</param>
    </member>
    <member name="M:devDept.Geometry.Vector2D.Subtract(devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            Subtraction between two 2D points.
            </summary>
      <param name="a">The first 2D point</param>
      <param name="b">The second 2D point</param>
      <returns>The resulting 2D vector.</returns>
    </member>
    <member name="M:devDept.Geometry.Vector2D.Add(devDept.Geometry.Point2D,devDept.Geometry.Point2D)">
      <summary>
            Addition between two 2D points.
            </summary>
      <param name="a">The first 2D point</param>
      <param name="b">The second 2D point</param>
      <returns>The resulting 2D vector.</returns>
    </member>
    <member name="M:devDept.Geometry.Vector2D.Normalize">
      <summary>
            Resizes the 2D vector to unit length.
            </summary>
      <returns>True if the operation succeeded, false otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Vector2D.Reverse">
      <summary>
            Inverts the 2D vector direction.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Vector2D.IsUnit">
      <summary>
        <b>True</b> if the vector has length equal to one.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Vector2D.IsZero">
      <summary>
        <b>True</b> if the vector has length equal to zero.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Vector2D.Length">
      <summary>
            Gets or sets the 2D vector length.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Vector2D.LengthSquared">
      <summary>
            Gets the 2D vector squared length.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Vector2D.AxisX">
      <summary>
            Returns the X axis vector.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Vector2D.AxisY">
      <summary>
            Returns the Y axis vector.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Vector2D.Angle">
      <summary>
            Gets the angle between the X-axis and the 2D vector.
            </summary>
      <returns>The angle in radians.</returns>
    </member>
    <member name="M:devDept.Geometry.Vector2D.AngleBetween(devDept.Geometry.Vector2D,devDept.Geometry.Vector2D)">
      <summary>Computes the angle between two 2D vectors.</summary>
      <returns>The angle in radians in the range 0 &lt; angle &lt; PI.</returns>
      <param name="u">First 2D vector (unit length)</param>
      <param name="v">Second 2D vector (unit length)</param>
    </member>
    <member name="M:devDept.Geometry.Vector2D.SignedAngleBetween(devDept.Geometry.Vector2D,devDept.Geometry.Vector2D)">
      <summary>Computes the angle between two 2D vectors.</summary>
      <returns>The angle in radians in the range -PI &lt; angle &lt; +PI.</returns>
      <param name="u">First 2D vector</param>
      <param name="v">Second 2D vector</param>
      <remarks>It is not required to normalize the given vectors.</remarks>
    </member>
    <member name="M:devDept.Geometry.Vector2D.PerpDotProduct(devDept.Geometry.Vector2D,devDept.Geometry.Vector2D)">
      <summary>
            Perpendicular dot product.
            </summary>
      <param name="u">First 2D vector</param>
      <param name="v">Second 2D vector</param>
      <returns>The perpendicular dot product value.</returns>
      <remarks>
            The vectors should be unit length if the desired return value
            is the sine of the angle between the two vectors.
            </remarks>
    </member>
    <member name="M:devDept.Geometry.Vector2D.op_Subtraction(devDept.Geometry.Vector2D,devDept.Geometry.Vector2D)">
      <summary>
            Subtraction between two 2D vectors.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector2D.op_Addition(devDept.Geometry.Vector2D,devDept.Geometry.Vector2D)">
      <summary>
            Addition between two vectors.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector2D.Dot(devDept.Geometry.Vector2D,devDept.Geometry.Vector2D)">
      <summary>
            Dot product between two 2D vectors.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector2D.op_Multiply(devDept.Geometry.Vector2D,devDept.Geometry.Vector2D)">
      <summary>
            Dot product between two 2D vectors.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector2D.Dot(devDept.Geometry.Vector2D,devDept.Geometry.Point2D)">
      <summary>
            Dot product between a 2D vector and a 2D point.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector2D.Dot(devDept.Geometry.Point2D,devDept.Geometry.Vector2D)">
      <summary>
            Dot product between a 2D point and a 2D vector.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector2D.Zero">
      <summary>
            Sets all the vector components to zero.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector2D.AreCoincident(devDept.Geometry.Vector2D,devDept.Geometry.Vector2D)">
      <summary>
            Returns true if the angle between the two 2D vectors is zero.
            </summary>
      <param name="u">First 2D vector (unit length)</param>
      <param name="v">Second 2D vector (unit length)</param>
    </member>
    <member name="M:devDept.Geometry.Vector2D.AreCoincident(devDept.Geometry.Vector2D,devDept.Geometry.Vector2D,System.Double)">
      <summary>
            Returns true if the angle between the two 2D vectors is zero or almost zero.
            </summary>
      <param name="u">First 2D vector (unit length)</param>
      <param name="v">Second 2D vector (unit length)</param>
      <param name="tol">Dot product comparison tolerance</param>
    </member>
    <member name="M:devDept.Geometry.Vector2D.AreOpposite(devDept.Geometry.Vector2D,devDept.Geometry.Vector2D)">
      <summary>
            Returns true if the angle between the two 2D vectors is PI.
            </summary>
      <param name="u">First 2D vector (unit length)</param>
      <param name="v">Second 2D vector (unit length)</param>
    </member>
    <member name="M:devDept.Geometry.Vector2D.AreOpposite(devDept.Geometry.Vector2D,devDept.Geometry.Vector2D,System.Double)">
      <summary>
            Returns true if the angle between the two 2D vectors is PI or almost PI.
            </summary>
      <param name="u">First 2D vector (unit length)</param>
      <param name="v">Second 2D vector (unit length)</param>
      <param name="tol">Dot product comparison tolerance</param>
    </member>
    <member name="M:devDept.Geometry.Vector2D.AreParallel(devDept.Geometry.Vector2D,devDept.Geometry.Vector2D)">
      <summary>
            Returns true if the angle between the two 2D vectors is 0 or PI.
            </summary>
      <param name="u">First 2D vector (unit length)</param>
      <param name="v">Second 2D vector (unit length)</param>
    </member>
    <member name="M:devDept.Geometry.Vector2D.AreParallel(devDept.Geometry.Vector2D,devDept.Geometry.Vector2D,System.Double)">
      <summary>
            Returns true if the angle between the two 2D vectors is zero or PI or almost zero or almost PI.
            </summary>
      <param name="u">First 2D vector (unit length)</param>
      <param name="v">Second 2D vector (unit length)</param>
      <param name="tol">Dot product comparison tolerance</param>
    </member>
    <member name="M:devDept.Geometry.Vector2D.AreOrthogonal(devDept.Geometry.Vector2D,devDept.Geometry.Vector2D)">
      <summary>
            Returns true if the angle between the two 2D vectors is PI/2.
            </summary>
      <param name="u">First 2D vector (unit length)</param>
      <param name="v">Second 2D vector (unit length)</param>
    </member>
    <member name="M:devDept.Geometry.Vector2D.AreOrthogonal(devDept.Geometry.Vector2D,devDept.Geometry.Vector2D,System.Double)">
      <summary>
            Returns true if the angle between the two 2D vectors is PI/2 or almost PI/2.
            </summary>
      <param name="u">First 2D vector (unit length)</param>
      <param name="v">Second 2D vector (unit length)</param>
      <param name="tol">Dot product comparison tolerance</param>
    </member>
    <member name="M:devDept.Geometry.Vector2D.ToString">
      <summary>
            Converts this 2D vector to a human readable string.
            </summary>
      <returns>A string that represents this 2D vector.</returns>
    </member>
    <member name="M:devDept.Geometry.Vector2D.ToStringXml">
      <summary>
            Converts this 2D vector to a human readable string.
            </summary>
      <returns>A string that represents this 2D vector.</returns>
    </member>
    <member name="M:devDept.Geometry.Vector2D.Negate">
      <summary>Reverses the 2D vector direction.</summary>
    </member>
    <member name="M:devDept.Geometry.Vector2D.TransformBy(devDept.Geometry.Transformation)">
      <summary>
            Transforms the 2D vector by the specified transformation.
            </summary>
      <param name="xform">The transformation to be applied</param>
    </member>
    <member name="T:devDept.Geometry.Vector3D">
      <summary>
            3D Vector definition.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector3D.#ctor">
      <summary>
            Empty constructor.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector3D.#ctor(System.Double,System.Double)">
      <summary>
            2D constructor.
            </summary>
      <param name="x">Vector's X component</param>
      <param name="y">Vector's Y component</param>
    </member>
    <member name="M:devDept.Geometry.Vector3D.#ctor(System.Double,System.Double,System.Double)">
      <summary>
            3D constructor.
            </summary>
      <param name="x">Vector's X component</param>
      <param name="y">Vector's Y component</param>
      <param name="z">Vector's Z component</param>
    </member>
    <member name="M:devDept.Geometry.Vector3D.#ctor(System.Double[])">
      <summary>
            Double array constructor.
            </summary>
      <param name="v">The array of doubles</param>
    </member>
    <member name="M:devDept.Geometry.Vector3D.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Two 3D points constructor. A 3D vector with direction from P0 to P1.
            </summary>
      <param name="P0">First point</param>
      <param name="P1">Second point</param>
    </member>
    <member name="M:devDept.Geometry.Vector3D.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Three 3D points constructor. A 3D vector perpendicular to a plane defined by 3 points.
            </summary>
      <param name="P0">Origin point</param>
      <param name="P1">Point along the X axis</param>
      <param name="P2">Point along the Y axis</param>
      <remarks>Check <see cref="P:devDept.Geometry.Vector3D.IsZero" /> before using this 3D vector.</remarks>
    </member>
    <member name="M:devDept.Geometry.Vector3D.Clone">
      <summary>
            Creates a deep copy of this 3D vector.
            </summary>
      <returns>The new 3D vector.</returns>
    </member>
    <member name="P:devDept.Geometry.Vector3D.AxisX">
      <summary>
            Returns the +X axis vector.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Vector3D.AxisMinusX">
      <summary>
            Returns the -X axis vector.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Vector3D.AxisY">
      <summary>
            Returns the +Y axis vector.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Vector3D.AxisMinusY">
      <summary>
            Returns the -Y axis vector.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Vector3D.AxisZ">
      <summary>
            Returns the +Z axis vector.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Vector3D.AxisMinusZ">
      <summary>
            Returns the -Z axis vector.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Vector3D.IsZero">
      <summary>
        <b>True</b> if the vector has length equal to zero.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Vector3D.IsUnit">
      <summary>
        <b>True</b> if the vector has length equal to one.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Vector3D.Length">
      <summary>
            Gets or sets the 3D vector length.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Vector3D.LengthSquared">
      <summary>
            Gets or sets the vector length.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector3D.PerpendicularTo(devDept.Geometry.Vector3D)">
      <summary>
            Sets this vector to be perpendicular to another vector. The result is not normalized.
            </summary>
      <param name="v">The test 3D vector</param>
      <returns> False if input vector is zero, true otherwise.</returns>
    </member>
    <member name="M:devDept.Geometry.Vector3D.Zero">
      <summary>
            Sets all the vector components to zero.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector3D.op_Subtraction(devDept.Geometry.Vector3D,devDept.Geometry.Vector3D)">
      <summary>
            Subtraction between two vectors.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector3D.op_Addition(devDept.Geometry.Vector3D,devDept.Geometry.Vector3D)">
      <summary>
            Addition between two 3D vectors.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector3D.op_Multiply(System.Double,devDept.Geometry.Vector3D)">
      <summary>
            Multiplication between a scalar value and a 3D vector.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector3D.op_Multiply(devDept.Geometry.Vector3D,System.Double)">
      <summary>
            Multiplication between a 3D vector and a scalar s.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector3D.op_Division(devDept.Geometry.Vector3D,System.Double)">
      <summary>
            Division between a 3D vector and a scalar s.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector3D.Normalize">
      <summary>
            Resizes the 3D vector to unit length.
            </summary>
      <returns>True if the operation succeeded, false otherwise.</returns>
    </member>
    <member name="P:devDept.Geometry.Vector3D.AngleInXY">
      <summary>
            Gets the angle between the X-axis and the vector projection on the XY plane.
            </summary>
      <returns>The angle in radians.</returns>
    </member>
    <member name="P:devDept.Geometry.Vector3D.AngleFromXY">
      <summary>Gets the angle between the vector and the XY plane.</summary>
      <returns>The angle in radians.</returns>
    </member>
    <member name="M:devDept.Geometry.Vector3D.Dot(devDept.Geometry.Vector3D,devDept.Geometry.Vector3D)">
      <summary>
            Dot product between two 3D vectors.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector3D.op_Multiply(devDept.Geometry.Vector3D,devDept.Geometry.Vector3D)">
      <summary>
            Dot product between two 3D vectors.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector3D.Dot(devDept.Geometry.Vector3D,devDept.Geometry.Point3D)">
      <summary>
            Dot product between a 3D vector and a 3D point.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector3D.Dot(devDept.Geometry.Point3D,devDept.Geometry.Vector3D)">
      <summary>
            Dot product between a 3D point and a 3D vector.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Vector3D.Subtract(devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Subtraction between two 3D points.
            </summary>
      <param name="a">The first 3D point</param>
      <param name="b">The second 3D point</param>
      <returns>The resulting 3D vector.</returns>
    </member>
    <member name="M:devDept.Geometry.Vector3D.Add(devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>
            Addition between two 3D points.
            </summary>
      <param name="a">The first 3D point</param>
      <param name="b">The second 3D point</param>
      <returns>The resulting 3D vector.</returns>
    </member>
    <member name="M:devDept.Geometry.Vector3D.Cross(devDept.Geometry.Vector3D,devDept.Geometry.Vector3D)">
      <summary>
            Cross product between two 3D vectors.
            </summary>
      <returns>The resulting 3D vector, <b>not</b> normalized.</returns>
    </member>
    <member name="M:devDept.Geometry.Vector3D.Cross(devDept.Geometry.Point3D,devDept.Geometry.Point3D)">
      <summary>Cross product between two 3D points.</summary>
      <returns>The resulting 3D vector, <b>not</b> normalized.</returns>
    </member>
    <member name="M:devDept.Geometry.Vector3D.AngleBetween(devDept.Geometry.Vector3D,devDept.Geometry.Vector3D)">
      <summary>Computes the angle between two vectors.</summary>
      <returns>The angle in radians in the range 0 &lt; angle &lt; PI.</returns>
      <param name="u">First 3D vector (unit length)</param>
      <param name="v">Second 3D vector (unit length)</param>
    </member>
    <member name="M:devDept.Geometry.Vector3D.ToString">
      <summary>Converts this 3D vector to a human readable string.</summary>
      <returns>A string that represents this 3D vector.</returns>
    </member>
    <member name="M:devDept.Geometry.Vector3D.ToStringXml">
      <summary>
            Converts this 3D vector to a human readable string.
            </summary>
      <returns>A string that represents this 2D vector.</returns>
    </member>
    <member name="M:devDept.Geometry.Vector3D.Negate">
      <summary>Reverses the 3D vector direction.</summary>
    </member>
    <member name="M:devDept.Geometry.Vector3D.AreCoincident(devDept.Geometry.Vector3D,devDept.Geometry.Vector3D)">
      <summary>
            Returns true if the angle between the two 3D vectors is zero.
            </summary>
      <param name="u">First 3D vector (unit length)</param>
      <param name="v">Second 3D vector (unit length)</param>
    </member>
    <member name="M:devDept.Geometry.Vector3D.AreCoincident(devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,System.Double)">
      <summary>
            Returns true if the angle between the two 3D vectors is zero or almost zero.
            </summary>
      <param name="u">First 3D vector (unit length)</param>
      <param name="v">Second 3D vector (unit length)</param>
      <param name="tol">Dot product comparison tolerance</param>
    </member>
    <member name="M:devDept.Geometry.Vector3D.AreOpposite(devDept.Geometry.Vector3D,devDept.Geometry.Vector3D)">
      <summary>
            Returns true if the angle between the two 3D vectors is PI.
            </summary>
      <param name="u">First 3D vector (unit length)</param>
      <param name="v">Second 3D vector (unit length)</param>
    </member>
    <member name="M:devDept.Geometry.Vector3D.AreOpposite(devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,System.Double)">
      <summary>
            Returns true if the angle between the two 3D vectors is PI or almost PI.
            </summary>
      <param name="u">First 3D vector (unit length)</param>
      <param name="v">Second 3D vector (unit length)</param>
      <param name="tol">Dot product comparison tolerance</param>
    </member>
    <member name="M:devDept.Geometry.Vector3D.AreParallel(devDept.Geometry.Vector3D,devDept.Geometry.Vector3D)">
      <summary>
            Returns true if the angle between the two 3D vectors is 0 or PI.
            </summary>
      <param name="u">First 3D vector (unit length)</param>
      <param name="v">Second 3D vector (unit length)</param>
    </member>
    <member name="M:devDept.Geometry.Vector3D.AreParallel(devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,System.Double)">
      <summary>
            Returns true if the angle between the two 3D vectors is zero or PI or almost zero or almost PI.
            </summary>
      <param name="u">First 3D vector (unit length)</param>
      <param name="v">Second 3D vector (unit length)</param>
      <param name="tol">Dot product comparison tolerance</param>
    </member>
    <member name="M:devDept.Geometry.Vector3D.AreOrthogonal(devDept.Geometry.Vector3D,devDept.Geometry.Vector3D)">
      <summary>
            Returns true if the angle between the two 3D vectors is PI/2.
            </summary>
      <param name="u">First 3D vector (unit length)</param>
      <param name="v">Second 3D vector (unit length)</param>
    </member>
    <member name="M:devDept.Geometry.Vector3D.AreOrthogonal(devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,System.Double)">
      <summary>
            Returns true if the angle between the two 3D vectors is PI/2 or almost PI/2.
            </summary>
      <param name="u">First 3D vector (unit length)</param>
      <param name="v">Second 3D vector (unit length)</param>
      <param name="tol">Dot product comparison tolerance</param>
    </member>
    <member name="M:devDept.Geometry.Vector3D.TransformBy(devDept.Geometry.Transformation)">
      <summary>
            Transforms the 3D vector by the specified transformation.
            </summary>
      <param name="xform">The transformation to be applied</param>
    </member>
    <member name="T:devDept.Geometry.ssiFailureType">
      <summary>
            Surface-Surface Intersection types of failure.
            </summary>
    </member>
    <member name="F:devDept.Geometry.ssiFailureType.DontTouch">
      <summary>
            The two entities don't touch
            </summary>
    </member>
    <member name="F:devDept.Geometry.ssiFailureType.InvalidIntersectionCurves">
      <summary>
            The intersection was found but the intersection points/curves are  missing or not valid
            </summary>
    </member>
    <member name="F:devDept.Geometry.ssiFailureType.Success">
      <summary>
            The intersection was successfully found
            </summary>
    </member>
    <member name="F:devDept.Geometry.ssiFailureType.BoundaryProcessingFailed">
      <summary>
            The intersection failed during boundary processing, check intersection curves first.
            </summary>
    </member>
    <member name="F:devDept.Geometry.ssiFailureType.UnknownFailure">
      <summary>
            Unknown failure
            </summary>
    </member>
    <member name="F:devDept.Geometry.ssiFailureType.FilletIntersectionNotFound">
      <summary>
            Surface-Surface intersection not found.
            </summary>
    </member>
    <member name="F:devDept.Geometry.ssiFailureType.InvalidFillet">
      <summary>
            There are no arcs to make the fillet with
            </summary>
    </member>
    <member name="T:devDept.Geometry.Fem.IndexLineEx">
      <summary>
            Fem line definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Fem.IndexLineEx.ElementIndex">
      <summary>
            Gets the parent element index.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Fem.IndexLineEx.#ctor(System.Int32,System.Int32,System.Int32)">
      <summary>
            Element index and vertex indices constructor
            </summary>
    </member>
    <member name="T:devDept.Geometry.Fem.IndexTriangleEx">
      <summary>
            Fem triangle definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.Fem.IndexTriangleEx.ElementIndex">
      <summary>
            Gets the parent element index.
            </summary>
    </member>
    <member name="M:devDept.Geometry.Fem.IndexTriangleEx.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
      <summary>
            Element index and vertex indices constructor
            </summary>
    </member>
    <member name="T:devDept.Geometry.AnalyticSurf">
      <summary>
            Base class for analytic gSurfaces.
            </summary>
    </member>
    <member name="P:devDept.Geometry.AnalyticSurf.Index">
      <summary>
            Gets gSurface index, when available from import of standard CAD file formats.
            </summary>
    </member>
    <member name="M:devDept.Geometry.AnalyticSurf.#ctor(System.Int32)">
      <summary>
            Standard constructor.
            </summary>
      <param name="index">The gSurface index, when available from import of standard CAD file formats.</param>
    </member>
    <member name="M:devDept.Geometry.AnalyticSurf.#ctor(devDept.Geometry.AnalyticSurf)">
      <summary>
            Copy constructor.
            </summary>
      <param name="another">The other analytic gSurface object</param>
    </member>
    <member name="M:devDept.Geometry.AnalyticSurf.Clone">
      <summary>
            Creates a deep copy of this analytic gSurface.
            </summary>
      <returns>The new analytic gSurface object.</returns>
    </member>
    <member name="M:devDept.Geometry.AnalyticSurf.ConvertToSurrogate">
      <summary>
            Converts the analitc gSurface to its surrogate, for serialization purpose.
            </summary>
      <returns>The surrogate.</returns>
    </member>
    <member name="P:devDept.Geometry.AnalyticSurf.HasSeam">
      <summary>
            Returns true when the gSurface has one or two seams.
            </summary>
      <value>True in case of closed gSurfaces.</value>
    </member>
    <member name="M:devDept.Geometry.AnalyticSurf.GetSurface(devDept.Geometry.Entities.IGCurve[],System.Boolean)">
      <summary>
            Returns the trimmed gSurface(s).
            </summary>
      <returns>The resulting trimmed gSurface(s).</returns>
    </member>
    <member name="M:devDept.Geometry.AnalyticSurf.GetUntrimmed(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},System.Boolean,devDept.Geometry.Entities.GSurface@)">
      <summary>
            Gets the untrimmed parametric surface. Seams can be relocated to avoid the intersection with edge curves.
            </summary>
      <param name="edgeCurves">A collection of individual edge curves not organized into composite curves</param>
      <param name="sense">The surface sense, true for same sense.</param>
      <param name="notRotated">The original untrimmed surface (as defined in STEP file).</param>
      <returns>The resulting untrimmed surface.</returns>
    </member>
    <member name="M:devDept.Geometry.AnalyticSurf.TransformBy(devDept.Geometry.Transformation)">
      <summary>
            Transforms this analytic gSurface by the provided transformation.
            </summary>
      <param name="transform">The transformation</param>
    </member>
    <member name="T:devDept.Geometry.TabulatedSurf">
      <summary>
            Analytic tabulated gSurface definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.TabulatedSurf.Generatrix">
      <summary>
            Gets tabulated gSurface generatrix 3D vector.
            </summary>
    </member>
    <member name="P:devDept.Geometry.TabulatedSurf.Directrix">
      <summary>
            Gets tabulated gSurface igCurve.
            </summary>
    </member>
    <member name="M:devDept.Geometry.TabulatedSurf.#ctor(devDept.Geometry.Entities.IGCurve,devDept.Geometry.Vector3D,System.Int32)">
      <summary>
            Standard constructor.
            </summary>
      <param name="directrix">The extrusion amount</param>
      <param name="generatrix">The base igCurve</param>
      <param name="index">The gSurface index, when available from import of standard CAD file formats.</param>
    </member>
    <member name="T:devDept.Geometry.NurbsSurf">
      <summary>
            Analytic nurbs gSurface definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.NurbsSurf.DegreeU">
      <summary>
            Gets the gSurface degree in U direction.
            </summary>
    </member>
    <member name="P:devDept.Geometry.NurbsSurf.DegreeV">
      <summary>
            Gets the gSurface degree in V direction.
            </summary>
    </member>
    <member name="P:devDept.Geometry.NurbsSurf.KnotVectorU">
      <summary>
            Gets the gSurface knot vector in U direction.
            </summary>
    </member>
    <member name="P:devDept.Geometry.NurbsSurf.KnotVectorV">
      <summary>
            Gets the gSurface knot vector in V direction.
            </summary>
    </member>
    <member name="P:devDept.Geometry.NurbsSurf.ControlPoints">
      <summary>
            Gets the gSurface control point net.
            </summary>
    </member>
    <member name="M:devDept.Geometry.NurbsSurf.#ctor(System.Int32,System.Double[],System.Int32,System.Double[],devDept.Geometry.Point4D[0:,0:],System.Int32)">
      <summary>
            Standard constructor.
            </summary>
      <param name="uDegree">GSurface degree in the U parametric direction</param>
      <param name="uKnotVector">Knot vector in the U parametric direction</param>
      <param name="vDegree">GSurface degree in the V parametric direction</param>
      <param name="vKnotVector">Knot vector in the V parametric direction</param>
      <param name="ctrlPoints">GSurface control points</param>
    </member>
    <member name="T:devDept.Geometry.PlanarSurf">
      <summary>
            Analytic planar gSurface definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.PlanarSurf.ExtensionAmount">
      <summary>
            Gets the extension amount for untrimmed gSurfaces.
            </summary>
    </member>
    <member name="P:devDept.Geometry.PlanarSurf.Plane">
      <summary>
            Gets the planar gSurface plane.
            </summary>
    </member>
    <member name="M:devDept.Geometry.PlanarSurf.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,System.Int32)">
      <summary>
            Standard constructor.
            </summary>
      <param name="location">A 3D point representing the plane origin</param>
      <param name="normal">A 3D vector representing the plane normal</param>
      <param name="refDir">A 3D vector representing the plane X axis</param>
      <param name="index">The surface index, when available from import of standard CAD file formats.</param>
    </member>
    <member name="M:devDept.Geometry.PlanarSurf.#ctor(devDept.Geometry.Plane,System.Int32)">
      <summary>
            Proprietary file format constructor.
            </summary>
      <param name="plane">The plane stored in the file.</param>
      <param name="index">The surface index, when available from import of standard CAD file formats.</param>
    </member>
    <member name="M:devDept.Geometry.PlanarSurf.GetLengthAlongVector(devDept.Geometry.Plane,System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},devDept.Geometry.Interval@)">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="M:devDept.Geometry.PlanarSurf.ComputeTabulatedExtension(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve},devDept.Geometry.Entities.GCurve,devDept.Geometry.Vector3D,devDept.Geometry.Interval@,devDept.Geometry.Vector3D@,System.Double@)">
      <summary>
            For internal use only.
            </summary>
    </member>
    <member name="T:devDept.Geometry.RevolvedSurf">
      <summary>
            Analytic revolved gSurface definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.RevolvedSurf.Generatrix">
      <summary>
            Gets revolved gSurface igCurve.
            </summary>
    </member>
    <member name="M:devDept.Geometry.RevolvedSurf.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,devDept.Geometry.Entities.IGCurve,System.Int32)">
      <summary>
            Standard constructor.
            </summary>
      <param name="location">A 3D point representing the plane origin</param>
      <param name="normal">A 3D vector representing the plane normal</param>
      <param name="refDir">A 3D vector representing the plane X axis</param>
      <param name="generatrix">The igCurve to be revolved</param>
      <param name="index">The gSurface index, when available from import of standard CAD file formats.</param>
    </member>
    <member name="M:devDept.Geometry.RevolvedSurf.#ctor(devDept.Geometry.Plane,devDept.Geometry.Entities.IGCurve,System.Int32)">
      <summary>
            Proprietary file format constructor.
            </summary>
      <param name="plane">The plane stored in the file.</param>
      <param name="generatrix">The igCurve to be revolved</param>
      <param name="index">The gSurface index, when available from import of standard CAD file formats.</param>
    </member>
    <member name="T:devDept.Geometry.CylindricalSurf">
      <summary>
            Analytic cylindrical gSurface definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.CylindricalSurf.Radius">
      <summary>
            Gets cylinder radius.
            </summary>
    </member>
    <member name="M:devDept.Geometry.CylindricalSurf.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,System.Double,System.Int32)">
      <summary>
            Standard constructor.
            </summary>
      <param name="location">A 3D point representing the plane origin</param>
      <param name="axis">A 3D vector representing the plane normal</param>
      <param name="refDir">A 3D vector representing the plane X axis</param>
      <param name="radius">The cylider radius</param>
      <param name="index">The gSurface index, when available from import of standard CAD file formats.</param>
    </member>
    <member name="M:devDept.Geometry.CylindricalSurf.#ctor(devDept.Geometry.Plane,System.Double,System.Int32)">
      <summary>
            Proprietary file format constructor.
            </summary>
      <param name="plane">The plane stored in the file.</param>
      <param name="radius">The cylider radius</param>
      <param name="index">The gSurface index, when available from import of standard CAD file formats.</param>
    </member>
    <member name="T:devDept.Geometry.ConicalSurf">
      <summary>
            Analytic conical gSurface definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ConicalSurf.HalfAngle">
      <summary>
            The cone half angle in radians.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ConicalSurf.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,System.Double,System.Double,System.Int32)">
      <summary>
            Standard constructor.
            </summary>
      <param name="location">A 3D point representing the plane origin</param>
      <param name="axis">A 3D vector representing the plane normal</param>
      <param name="refDir">A 3D vector representing the plane X axis</param>
      <param name="radius">The cone radius</param>
      <param name="halfAngle">The cone half angle</param>
      <param name="index">The gSurface index, when available from import of standard CAD file formats.</param>
    </member>
    <member name="M:devDept.Geometry.ConicalSurf.#ctor(devDept.Geometry.Plane,System.Double,System.Double,System.Int32)">
      <summary>
            Proprietary file format constructor.
            </summary>
      <param name="plane">The plane stored in the file.</param>
      <param name="radius">The cone radius</param>
      <param name="halfAngle">The cone half angle</param>
      <param name="index">The gSurface index, when available from import of standard CAD file formats.</param>
    </member>
    <member name="T:devDept.Geometry.ToroidalSurf">
      <summary>
            Analytic toroidal gSurface definition.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ToroidalSurf.MajorRadius">
      <summary>
            Gets toroidal gSurface major radius.
            </summary>
    </member>
    <member name="P:devDept.Geometry.ToroidalSurf.MinorRadius">
      <summary>
            Gets toroidal gSurface minor radius.
            </summary>
    </member>
    <member name="M:devDept.Geometry.ToroidalSurf.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,System.Double,System.Double,System.Int32)">
      <summary>
            Internal constructor.
            </summary>
      <param name="location">A 3D point representing the plane origin</param>
      <param name="axis">A 3D vector representing the plane normal</param>
      <param name="refDir">A 3D vector representing the plane X axis</param>
      <param name="majorRadius">The torus major radius</param>
      <param name="minorRadius">The torus minor radius</param>
      <param name="index">The gSurface index, when available from import of standard CAD file formats.</param>
    </member>
    <member name="M:devDept.Geometry.ToroidalSurf.#ctor(devDept.Geometry.Plane,System.Double,System.Double,System.Int32)">
      <summary>
            Proprietary file format constructor.
            </summary>
      <param name="plane">The plane stored in the file.</param>
      <param name="majorRadius">The torus major radius</param>
      <param name="minorRadius">The torus minor radius</param>
      <param name="index">The gSurface index, when available from import of standard CAD file formats.</param>
    </member>
    <member name="T:devDept.Geometry.SphericalSurf">
      <summary>
            Analytic spherical surface definition.
            </summary>
    </member>
    <member name="M:devDept.Geometry.SphericalSurf.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D,System.Double,System.Int32)">
      <summary>
            Standard constructor.
            </summary>
      <param name="location">A 3D point representing the plane origin</param>
      <param name="axis">A 3D vector representing the plane normal</param>
      <param name="refDir">A 3D vector representing the plane X axis</param>
      <param name="radius">The sphere radius</param>
      <param name="index">The surface index, when available from import of standard CAD file formats.</param>
    </member>
    <member name="M:devDept.Geometry.SphericalSurf.#ctor(devDept.Geometry.Plane,System.Double,System.Int32)">
      <summary>
            Proprietary file format constructor.
            </summary>
      <param name="plane">The plane stored in the file.</param>
      <param name="radius">The cylider radius</param>
      <param name="index">The surface index, when available from import of standard CAD file formats.</param>
    </member>
    <member name="M:devDept.Serialization.AngleConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.AngleConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.AngleConstraintSurrogate.Supplementary">
      <summary>
            See <see cref="P:devDept.Geometry.ConstraintSolver.AngleConstraint.Supplementary" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.AngleConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.ConstraintSolver.AngleConstraint.#ctor(devDept.Geometry.ConstraintSolver.SketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.CollinearPointsConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.CollinearPointsConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.CollinearPointsConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.CollinearPointsConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.CollinearPointsConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="!:CollinearPointsConstraint.CollinearPoints(sketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.CollinearConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.CollinearConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.CollinearConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.CollinearConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.CollinearConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="T:devDept.Geometry.ConstraintSolver.CollinearConstraint" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.ConcentricCirclesDistanceConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.ConcentricCirclesDistanceConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.ConcentricCirclesDistanceConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.ConcentricCirclesDistanceConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.ConcentricCirclesDistanceConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.ConstraintSolver.ConcentricCirclesDistanceConstraint.#ctor(devDept.Geometry.ConstraintSolver.SketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.ConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.Constraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.ConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.Constraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.ConstraintSurrogate.Ids">
      <summary>
            See <see cref="F:devDept.Geometry.ConstraintSolver.Constraint._ids" /></summary>
    </member>
    <member name="F:devDept.Serialization.ConstraintSurrogate.Visible">
      <summary>
            See <see cref="P:devDept.Geometry.ConstraintSolver.Constraint.Visible" /></summary>
    </member>
    <member name="T:devDept.Serialization.DiameterConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.DiameterConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.DiameterConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.DiameterConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.DiameterConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="!:DiameterConstraint.Diameter(SketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.EqualConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.EqualConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.EqualConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.EqualConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.EqualConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="T:devDept.Geometry.ConstraintSolver.EqualConstraint" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.SketchSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.Sketch" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SketchSurrogate.#ctor(devDept.Geometry.ConstraintSolver.Sketch)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SketchSurrogate.Entities">
      <summary>
            See <see cref="P:devDept.Geometry.ConstraintSolver.Sketch.Entities" /></summary>
    </member>
    <member name="F:devDept.Serialization.SketchSurrogate.Constraints">
      <summary>
            See <see cref="P:devDept.Geometry.ConstraintSolver.Sketch.Constraints" /></summary>
    </member>
    <member name="F:devDept.Serialization.SketchSurrogate.Plane">
      <summary>
            See <see cref="!:Sketch.Plane" /></summary>
    </member>
    <member name="M:devDept.Serialization.SketchSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.ConstraintSolver.Sketch.#ctor(devDept.Geometry.Plane)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.SketchSurrogate.op_Implicit(devDept.Serialization.SketchSurrogate)~devDept.Geometry.ConstraintSolver.Sketch">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SketchSurrogate.op_Implicit(devDept.Geometry.ConstraintSolver.Sketch)~devDept.Serialization.SketchSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.HVConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.HVConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.HVConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.HVConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.HVConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="T:devDept.Geometry.ConstraintSolver.HVConstraint" /> constructor to create the object.
             </remarks>
    </member>
    <member name="M:devDept.Serialization.IdPathSurrogate.#ctor(devDept.Geometry.ConstraintSolver.IdPath)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.IdPathSurrogate.Paths">
      <summary>
            See <see cref="F:devDept.Geometry.ConstraintSolver.IdPath.path" /></summary>
    </member>
    <member name="M:devDept.Serialization.IdPathSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.ConstraintSolver.IdPath.#ctor" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.IdPathSurrogate.op_Implicit(devDept.Serialization.IdPathSurrogate)~devDept.Geometry.ConstraintSolver.IdPath">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.IdPathSurrogate.op_Implicit(devDept.Geometry.ConstraintSolver.IdPath)~devDept.Serialization.IdPathSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.IdSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.Id" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.IdSurrogate.#ctor(devDept.Geometry.ConstraintSolver.Id)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.IdSurrogate.value">
      <summary>
            See <see cref="!:Id.v" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.IdSurrogate.second">
      <summary>
            See <see cref="!:Id.s" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.IdSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="!:Id.Id(s, v)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.IdSurrogate.op_Implicit(devDept.Serialization.IdSurrogate)~devDept.Geometry.ConstraintSolver.Id">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.IdSurrogate.op_Implicit(devDept.Geometry.ConstraintSolver.Id)~devDept.Serialization.IdSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.LengthConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.LengthConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.LengthConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.LengthConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.LengthConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="!:LengthConstraint.Length(SketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.LinesDistanceConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.LinesDistanceConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.LinesDistanceConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.LinesDistanceConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.LinesDistanceConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="!:LinesDistanceConstraint.LinesDistance(SketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.MidPointConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.MidPointConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.MidPointConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.MidPointConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.MidPointConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="!:MidPointConstraint.MidPoint(SketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.MirrorConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.MirrorConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.MirrorConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.MirrorConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.MirrorConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="!:MirrorConstraint.Mirror(SketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.ParallelConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.ParallelConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.ParallelConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.ParallelConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.ParallelConstraintSurrogate.Option">
      <summary>
            See <see cref="T:devDept.Geometry.ConstraintSolver.ParallelConstraint.Option" /></summary>
    </member>
    <member name="M:devDept.Serialization.ParallelConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="!:ParallelConstraint.Parallel(SketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.PerpendicularConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.PerpendicularConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PerpendicularConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.PerpendicularConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PerpendicularConstraintSurrogate.Option">
      <summary>
            See <see cref="T:devDept.Geometry.ConstraintSolver.PerpendicularConstraint.Option" /></summary>
    </member>
    <member name="M:devDept.Serialization.PerpendicularConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="!:PerpendicularConstraint.Perpendicular(SketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.PointAtConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.PointAtConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointAtConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.PointAtConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointAtConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="!:PointAtConstraint.PointAt(SketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.PointFixedConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.PointFixedConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointFixedConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.PointFixedConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointFixedConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="!:PointFixedConstraint.PointFixed(sketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.PointLineDistanceConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.PointLineDistanceConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointLineDistanceConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.PointLineDistanceConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointLineDistanceConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="!:PointLineDistanceConstraint.PointLineDistance(SketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.PointOnConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.PointOnConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointOnConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.PointOnConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointOnConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="!:PointOnConstraint.PointOn(SketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.CoincidentConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.CoincidentConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.CoincidentConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.CoincidentConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.CoincidentConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.ConstraintSolver.CoincidentConstraint.#ctor(devDept.Geometry.ConstraintSolver.SketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.PointsDistanceConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.PointsDistanceConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointsDistanceConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.PointsDistanceConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointsDistanceConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="!:PointsDistanceConstraint.PointsDistance(SketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.RadiusConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.RadiusConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.RadiusConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.RadiusConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.RadiusConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="!:RadiusConstraint.Radius(SketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.SketchArcSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.SketchArc" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SketchArcSurrogate.#ctor(devDept.Geometry.ConstraintSolver.SketchArc)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SketchArcSurrogate.StartPoint">
      <summary>
            See <see cref="!:Sketch.StartPoint" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SketchArcSurrogate.EndPoint">
      <summary>
            See <see cref="!:Sketch.EndPoint" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SketchArcSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.ConstraintSolver.SketchCircle.#ctor(devDept.Geometry.ConstraintSolver.SketchInternal)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.SketchCircleSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.SketchCircle" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SketchCircleSurrogate.#ctor(devDept.Geometry.ConstraintSolver.SketchCircle)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SketchCircleSurrogate.Radius">
      <summary>
            See <see cref="P:devDept.Geometry.ConstraintSolver.SketchCircle.Radius" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SketchCircleSurrogate.Center">
      <summary>
            See <see cref="P:devDept.Geometry.ConstraintSolver.SketchCircle.Center" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SketchCircleSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.ConstraintSolver.SketchCircle.#ctor(devDept.Geometry.ConstraintSolver.SketchInternal)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.SketchSplineSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.SketchSpline" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SketchSplineSurrogate.#ctor(devDept.Geometry.ConstraintSolver.SketchSpline)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SketchSplineSurrogate.ControlPoints">
      <summary>
            See <see cref="F:devDept.Geometry.ConstraintSolver.SketchSpline.ControlPoints" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SketchSplineSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="T:devDept.Geometry.ConstraintSolver.SketchCircle" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.SketchEllipseSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.SketchEllipse" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SketchEllipseSurrogate.#ctor(devDept.Geometry.ConstraintSolver.SketchEllipse)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SketchEllipseSurrogate.Center">
      <summary>
            See <see cref="P:devDept.Geometry.ConstraintSolver.SketchEllipse.Center" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SketchEllipseSurrogate.RadiusX">
      <summary>
            See <see cref="P:devDept.Geometry.ConstraintSolver.SketchEllipse.RadiusX" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SketchEllipseSurrogate.RadiusY">
      <summary>
            See <see cref="P:devDept.Geometry.ConstraintSolver.SketchEllipse.RadiusY" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SketchEllipseSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.ConstraintSolver.SketchEllipse.#ctor(devDept.Geometry.ConstraintSolver.SketchInternal)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.SketchCurveSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.SketchCurve" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SketchCurveSurrogate.#ctor(devDept.Geometry.ConstraintSolver.SketchCurve)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SketchCurveSurrogate.Construction">
      <summary>
            See <see cref="P:devDept.Geometry.ConstraintSolver.SketchCurve.Construction" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SketchCurveSurrogate.Projected">
      <summary>
            See <see cref="P:devDept.Geometry.ConstraintSolver.SketchCurve.Projected" />.
            </summary>
    </member>
    <member name="T:devDept.Serialization.SketchLineSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.SketchLine" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SketchLineSurrogate.#ctor(devDept.Geometry.ConstraintSolver.SketchLine)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SketchLineSurrogate.StartPoint">
      <summary>
            See <see cref="P:devDept.Geometry.ConstraintSolver.SketchLine.StartPoint" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SketchLineSurrogate.EndPoint">
      <summary>
            See <see cref="P:devDept.Geometry.ConstraintSolver.SketchLine.EndPoint" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SketchLineSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.ConstraintSolver.SketchPoint.#ctor(devDept.Geometry.ConstraintSolver.SketchInternal)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.SketchItemSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.SketchItem" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SketchItemSurrogate.#ctor(devDept.Geometry.ConstraintSolver.SketchItem)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SketchItemSurrogate.ConvertToObject">
      <summary>
            Creates the entity related to the surrogate.
            </summary>
      <remarks>When this method is called, the <see cref="!:Content" /> field is already initialized.</remarks>
      <returns>The entity created.</returns>
    </member>
    <member name="M:devDept.Serialization.SketchItemSurrogate.op_Implicit(devDept.Serialization.SketchItemSurrogate)~devDept.Geometry.ConstraintSolver.SketchItem">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SketchItemSurrogate.op_Implicit(devDept.Geometry.ConstraintSolver.SketchItem)~devDept.Serialization.SketchItemSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.SketchPointSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.SketchPoint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SketchPointSurrogate.#ctor(devDept.Geometry.ConstraintSolver.SketchPoint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SketchPointSurrogate.PlanePosition">
      <summary>
            See <see cref="P:devDept.Geometry.ConstraintSolver.SketchPoint.PlanePosition" />. 
            </summary>
    </member>
    <member name="M:devDept.Serialization.SketchPointSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.ConstraintSolver.SketchPoint.#ctor(devDept.Geometry.ConstraintSolver.SketchInternal)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.TangentConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.TangentConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.TangentConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.TangentConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.TangentConstraintSurrogate.Option">
      <summary>
            See <see cref="T:devDept.Geometry.ConstraintSolver.TangentConstraint.Option" /></summary>
    </member>
    <member name="M:devDept.Serialization.TangentConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="!:TangentConstraint.Tangent(sketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.ValueConstraintSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConstraintSolver.ValueConstraint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.ValueConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.ValueConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.ValueConstraintSurrogate.Reference">
      <summary>
            See <see cref="P:devDept.Geometry.ConstraintSolver.ValueConstraint.Reference" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.ValueConstraintSurrogate.DimPos">
      <summary>
            See <see cref="F:devDept.Geometry.ConstraintSolver.ValueConstraint.DimPos" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.ValueConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="!:ValueConstraint.ValueConstraint(sketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GCompositeCurveSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GCompositeCurve" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GCompositeCurveSurrogate.#ctor(devDept.Geometry.Entities.GCompositeCurve)">
      <summary>
            Standard Constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GCompositeCurveSurrogate.CurveList">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GCompositeCurve.CurveList" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GCompositeCurveSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>        
             This method uses the <see cref="M:devDept.Geometry.Entities.GCompositeCurve.#ctor(System.Collections.Generic.IEnumerable{devDept.Geometry.Entities.IGCurve},System.Boolean)" /> constructor with the latest param equal to false to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GPointCloudSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GPointCloud" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GPointCloudSurrogate.#ctor(devDept.Geometry.Entities.GPointCloud)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GPointCloudSurrogate.Vertices">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GPointCloud.Vertices" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GPointCloudSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GPointCloud.#ctor(System.Collections.Generic.IList{devDept.Geometry.Point3D})" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GMeshSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GMesh" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GMeshSurrogate.#ctor(devDept.Geometry.Entities.GMesh)">
      <summary>
            Standard Constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GMeshSurrogate.MeshNature">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GMesh.MeshNature" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GMeshSurrogate.EdgeStyle">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GMesh.EdgeStyle" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GMeshSurrogate.Vertices">
      <summary>
            See <see cref="!:GEntity.Vertices" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GMeshSurrogate.Triangles">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GMesh.Triangles" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GMeshSurrogate.TextureCoords">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GMesh.TextureCoords" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GMeshSurrogate.Normals">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GMesh.Normals" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GMeshSurrogate.Edges">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GMesh.Edges" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GMeshSurrogate.SmoothingAngle">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GMesh.SmoothingAngle" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GMeshSurrogate.LightWeight">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GMesh.LightWeight" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GMeshSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="T:devDept.Geometry.Entities.GMesh" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GRegionSurrogate">
      <summary>
            Defines the <see cref="!:Eyeshot.Entities.GRegion" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GRegionSurrogate.#ctor(devDept.Geometry.Entities.GRegion)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GRegionSurrogate.Plane">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GPlanarEntity.Plane" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GRegionSurrogate.ContourList">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GRegion.ContourList" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GRegionSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>        
             This method uses the <see cref="M:devDept.Geometry.Entities.GRegion.#ctor(System.Collections.Generic.IList{devDept.Geometry.Entities.IGCurve})" /> constructor with an empty list. (The <see cref="P:devDept.Geometry.Entities.GRegion.ContourList" /> is filled with the <see cref="M:devDept.Serialization.GRegionSurrogate.CopyDataToObject(devDept.Geometry.Entities.GEntity)" /> method.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.VerticalPointsDistanceConstraintSurrogate">
      <summary>
            Defines the <see cref="!:VerticalPointsDistance" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.VerticalPointsDistanceConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.VerticalPointsDistanceConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.VerticalPointsDistanceConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="!:VerticalPointsDistance.VerticalPointsDistance(SketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.HorizontalPointsDistanceConstraintSurrogate">
      <summary>
            Defines the <see cref="!:HorizontalPointsDistance" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.HorizontalPointsDistanceConstraintSurrogate.#ctor(devDept.Geometry.ConstraintSolver.HorizontalPointsDistanceConstraint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.HorizontalPointsDistanceConstraintSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="!:HorizontalPointsDistance.HorizontalPointsDistance(SketchInternal)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.SystemPointSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Point" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SystemPointSurrogate.#ctor(devDept.Geometry.Point)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SystemPointSurrogate.X">
      <summary>
            See <see cref="P:devDept.Geometry.Point.X" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SystemPointSurrogate.Y">
      <summary>
            See <see cref="P:devDept.Geometry.Point.Y" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SystemPointSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="T:devDept.Geometry.Point" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.SystemPointSurrogate.op_Implicit(devDept.Serialization.SystemPointSurrogate)~devDept.Geometry.Point">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SystemPointSurrogate.op_Implicit(devDept.Geometry.Point)~devDept.Serialization.SystemPointSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.SystemPointFSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.PointF" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SystemPointFSurrogate.#ctor(devDept.Geometry.PointF)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SystemPointFSurrogate.X">
      <summary>
            See <see cref="P:devDept.Geometry.PointF.X" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SystemPointFSurrogate.Y">
      <summary>
            See <see cref="P:devDept.Geometry.PointF.Y" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SystemPointFSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="T:devDept.Geometry.PointF" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.SystemPointFSurrogate.op_Implicit(devDept.Serialization.SystemPointFSurrogate)~devDept.Geometry.PointF">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SystemPointFSurrogate.op_Implicit(devDept.Geometry.PointF)~devDept.Serialization.SystemPointFSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.TextureMappingDataSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Eyeshot.TextureMappingData" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.TextureMappingDataSurrogate.#ctor(devDept.Eyeshot.TextureMappingData)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.TextureMappingDataSurrogate.Transformation">
      <summary>
            See <see cref="P:devDept.Eyeshot.TextureMappingData.Transformation" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.TextureMappingDataSurrogate.Max">
      <summary>
            See <see cref="P:devDept.Eyeshot.TextureMappingData.Max" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.TextureMappingDataSurrogate.Min">
      <summary>
            See <see cref="P:devDept.Eyeshot.TextureMappingData.Min" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.TextureMappingDataSurrogate.MappingMode">
      <summary>
            See <see cref="P:devDept.Eyeshot.TextureMappingData.MappingMode" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.TextureMappingDataSurrogate.ScaleX">
      <summary>
            See <see cref="P:devDept.Eyeshot.TextureMappingData.ScaleX" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.TextureMappingDataSurrogate.ScaleY">
      <summary>
            See <see cref="P:devDept.Eyeshot.TextureMappingData.ScaleY" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.TextureMappingDataSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Eyeshot.TextureMappingData.#ctor(devDept.Geometry.textureMappingType,System.Double,System.Double,devDept.Geometry.Point3D,devDept.Geometry.Point3D)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.TextureMappingDataSurrogate.op_Implicit(devDept.Serialization.TextureMappingDataSurrogate)~devDept.Eyeshot.TextureMappingData">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.TextureMappingDataSurrogate.op_Implicit(devDept.Eyeshot.TextureMappingData)~devDept.Serialization.TextureMappingDataSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.ProtoArray`1">
      <summary>
            Class for multidimensional array handling
            </summary>
    </member>
    <member name="T:devDept.Serialization.ProtoJaggedArray`1">
      <summary>
            Class for jagged arrays handling
            </summary>
    </member>
    <member name="T:devDept.Serialization.Extensions">
      <summary>
            Serialization extensions.
            </summary>
    </member>
    <member name="T:devDept.Serialization.ProtoObject">
      <summary>
            Class for object handling
            </summary>
      <remarks>Helper class to store generic object not natively supported from protobuf-net.</remarks>
    </member>
    <member name="M:devDept.Serialization.ProtoObject.#ctor(System.Object)">
      <summary>
            Standard constructor.
            </summary>
      <param name="obj">The object.</param>
    </member>
    <member name="P:devDept.Serialization.ProtoObject.Object">
      <summary>
            The object.
            </summary>
    </member>
    <member name="T:devDept.Serialization.QuaternionSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Quaternion" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.QuaternionSurrogate.#ctor(devDept.Geometry.Quaternion)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.QuaternionSurrogate.X">
      <summary>
            See <see cref="F:devDept.Geometry.Quaternion.X" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.QuaternionSurrogate.Y">
      <summary>
            See <see cref="F:devDept.Geometry.Quaternion.Y" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.QuaternionSurrogate.Z">
      <summary>
            See <see cref="F:devDept.Geometry.Quaternion.Z" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.QuaternionSurrogate.W">
      <summary>
            See <see cref="F:devDept.Geometry.Quaternion.W" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.QuaternionSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Quaternion.#ctor(System.Double,System.Double,System.Double,System.Double)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.QuaternionSurrogate.op_Implicit(devDept.Serialization.QuaternionSurrogate)~devDept.Geometry.Quaternion">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.QuaternionSurrogate.op_Implicit(devDept.Geometry.Quaternion)~devDept.Serialization.QuaternionSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.ProtoObjectSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Serialization.ProtoObject" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.ProtoObjectSurrogate.#ctor(devDept.Serialization.ProtoObject)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.ProtoObjectSurrogate.Object">
      <summary>
            See <see cref="P:devDept.Serialization.ProtoObject.Object" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.ProtoObjectSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="!:ProtoObject.ProtoObject()" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.ProtoObjectSurrogate.op_Implicit(devDept.Serialization.ProtoObjectSurrogate)~devDept.Serialization.ProtoObject">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.ProtoObjectSurrogate.op_Implicit(devDept.Serialization.ProtoObject)~devDept.Serialization.ProtoObjectSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.ProtoObjectSurrogate.AfterDeserialize(ProtoBuf.SerializationContext)">
      <summary>
            Called after the object deserialization.
            </summary>
      <param name="serializationContext">The serialization context</param>
      <remarks>The override of this method must always call the base at the beginning.</remarks>
      <exception cref="T:System.ArgumentException">Thrown when the serialization context is not a valid <see cref="T:devDept.Serialization.Serializer" /> object.</exception>
    </member>
    <member name="M:devDept.Serialization.ProtoObjectSurrogate.BeforeSerialize(ProtoBuf.SerializationContext)">
      <summary>
            Called before the object serialization.
            </summary>
      <param name="serializationContext">The serialization context</param>
      <remarks>The override of this method must always call the base at the beginning.</remarks>
      <exception cref="T:System.ArgumentException">Thrown when the serialization context is not a valid <see cref="T:devDept.Serialization.Serializer" /> object.</exception>
    </member>
    <member name="T:devDept.Serialization.ColorSmoothTriangleSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ColorSmoothTriangle" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.ColorSmoothTriangleSurrogate.#ctor(devDept.Geometry.ColorSmoothTriangle)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.ColorSmoothTriangleSurrogate.R">
      <summary>
            See <see cref="P:devDept.Geometry.ColorSmoothTriangle.R" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.ColorSmoothTriangleSurrogate.G">
      <summary>
            See <see cref="P:devDept.Geometry.ColorSmoothTriangle.G" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.ColorSmoothTriangleSurrogate.B">
      <summary>
            See <see cref="P:devDept.Geometry.ColorSmoothTriangle.B" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.ColorSmoothTriangleSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.ColorSmoothTriangle.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte,System.Byte,System.Byte)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.ColorTriangleSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ColorTriangle" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.ColorTriangleSurrogate.#ctor(devDept.Geometry.ColorTriangle)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.ColorTriangleSurrogate.R">
      <summary>
            See <see cref="P:devDept.Geometry.ColorTriangle.R" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.ColorTriangleSurrogate.G">
      <summary>
            See <see cref="P:devDept.Geometry.ColorTriangle.G" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.ColorTriangleSurrogate.B">
      <summary>
            See <see cref="P:devDept.Geometry.ColorTriangle.B" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.ColorTriangleSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.ColorTriangle.#ctor(System.Int32,System.Int32,System.Int32,System.Byte,System.Byte,System.Byte)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.IndexLineSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.IndexLine" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.IndexLineSurrogate.#ctor(devDept.Geometry.IndexLine)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.IndexLineSurrogate.V1">
      <summary>
            See <see cref="F:devDept.Geometry.IndexLine.V1" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.IndexLineSurrogate.V2">
      <summary>
            See <see cref="F:devDept.Geometry.IndexLine.V2" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.IndexLineSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.IndexLine.#ctor(System.Int32,System.Int32)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.IndexLineSurrogate.op_Implicit(devDept.Serialization.IndexLineSurrogate)~devDept.Geometry.IndexLine">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.IndexLineSurrogate.op_Implicit(devDept.Geometry.IndexLine)~devDept.Serialization.IndexLineSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.IndexTriangleSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.IndexTriangle" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.IndexTriangleSurrogate.#ctor(devDept.Geometry.IndexTriangle)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.IndexTriangleSurrogate.V3">
      <summary>
            See <see cref="!:IndexTriangle.V1" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.IndexTriangleSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.IndexTriangle.#ctor(System.Int32,System.Int32,System.Int32)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.PlaneEquationSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.PlaneEquation" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PlaneEquationSurrogate.#ctor(devDept.Geometry.PlaneEquation)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PlaneEquationSurrogate.D">
      <summary>
            See <see cref="F:devDept.Geometry.PlaneEquation.D" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PlaneEquationSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.PlaneEquation.#ctor(System.Double,System.Double,System.Double,System.Double)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.PlaneEquation_V6Surrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.PlaneEquation" /> until version 6 of the Eyeshot file format.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PlaneEquation_V6Surrogate.#ctor(devDept.Geometry.PlaneEquation)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PlaneEquation_V6Surrogate.D">
      <summary>
            See <see cref="F:devDept.Geometry.PlaneEquation.D" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PlaneEquation_V6Surrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.PlaneEquation.#ctor(System.Double,System.Double,System.Double,System.Double)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.PlaneSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Plane" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PlaneSurrogate.#ctor(devDept.Geometry.Plane)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PlaneSurrogate.Origin">
      <summary>
            See <see cref="P:devDept.Geometry.Plane.Origin" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PlaneSurrogate.AxisX">
      <summary>
            See <see cref="P:devDept.Geometry.Plane.AxisX" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PlaneSurrogate.AxisY">
      <summary>
            See <see cref="P:devDept.Geometry.Plane.AxisY" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PlaneSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Plane.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Vector3D,devDept.Geometry.Vector3D)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.PlaneSurrogate.op_Implicit(devDept.Serialization.PlaneSurrogate)~devDept.Geometry.Plane">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PlaneSurrogate.op_Implicit(devDept.Geometry.Plane)~devDept.Serialization.PlaneSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.Point2DSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Point2D" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Point2DSurrogate.#ctor(devDept.Geometry.Point2D)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.Point2DSurrogate.X">
      <summary>
            See <see cref="F:devDept.Geometry.Point2D.X" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.Point2DSurrogate.Y">
      <summary>
            See <see cref="F:devDept.Geometry.Point2D.Y" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Point2DSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Point2D.#ctor(System.Double,System.Double)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.Point2DSurrogate.op_Implicit(devDept.Serialization.Point2DSurrogate)~devDept.Geometry.Point2D">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Point2DSurrogate.op_Implicit(devDept.Geometry.Point2D)~devDept.Serialization.Point2DSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.Point2D_V6Surrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Point2D" /> until version 6 of the Eyeshot file format.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Point2D_V6Surrogate.#ctor(devDept.Geometry.Vector2D)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.Point2D_V6Surrogate.X">
      <summary>
            See <see cref="F:devDept.Geometry.Vector2D.X" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.Point2D_V6Surrogate.Y">
      <summary>
            See <see cref="F:devDept.Geometry.Vector2D.Y" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Point2D_V6Surrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Vector2D.#ctor(System.Double,System.Double)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.Point2D_V6Surrogate.op_Implicit(devDept.Serialization.Point2D_V6Surrogate)~devDept.Geometry.Vector2D">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Point2D_V6Surrogate.op_Implicit(devDept.Geometry.Vector2D)~devDept.Serialization.Point2D_V6Surrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.Point3DSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Point3D" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Point3DSurrogate.#ctor(devDept.Geometry.Point3D)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.Point3DSurrogate.Z">
      <summary>
            See <see cref="F:devDept.Geometry.Point3D.Z" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Point3DSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Point3D.#ctor(System.Double,System.Double,System.Double)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.Point3D_V6Surrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Point3D" /> until version 6 of the Eyeshot file format.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Point3D_V6Surrogate.#ctor(devDept.Geometry.Vector3D)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.Point3D_V6Surrogate.Z">
      <summary>
            See <see cref="F:devDept.Geometry.Vector3D.Z" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Point3D_V6Surrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Vector3D.#ctor(System.Double,System.Double,System.Double)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.PointRGBSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.PointRGB" /> surrogate.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PointRGBSurrogate.R">
      <summary>
            See <see cref="P:devDept.Geometry.PointRGB.R" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PointRGBSurrogate.G">
      <summary>
            See <see cref="P:devDept.Geometry.PointRGB.G" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PointRGBSurrogate.B">
      <summary>
            See <see cref="P:devDept.Geometry.PointRGB.B" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointRGBSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.PointRGB.#ctor(System.Double,System.Double,System.Double,System.Byte,System.Byte,System.Byte)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.PointTangentSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.PointTangent" /> surrogate.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PointTangentSurrogate.Tx">
      <summary>
            See <see cref="F:devDept.Geometry.PointTangent.Tx" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PointTangentSurrogate.Ty">
      <summary>
            See <see cref="F:devDept.Geometry.PointTangent.Ty" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PointTangentSurrogate.Tz">
      <summary>
            See <see cref="F:devDept.Geometry.PointTangent.Tz" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointTangentSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.PointTangent.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.RichSmoothTriangleSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.RichSmoothTriangle" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.RichSmoothTriangleSurrogate.#ctor(devDept.Geometry.RichSmoothTriangle)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.RichSmoothTriangleSurrogate.T1">
      <summary>
            See <see cref="P:devDept.Geometry.RichSmoothTriangle.T1" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.RichSmoothTriangleSurrogate.T2">
      <summary>
            See <see cref="P:devDept.Geometry.RichSmoothTriangle.T2" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.RichSmoothTriangleSurrogate.T3">
      <summary>
            See <see cref="P:devDept.Geometry.RichSmoothTriangle.T3" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.RichSmoothTriangleSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.RichSmoothTriangle.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.RichTriangleSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.RichTriangle" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.RichTriangleSurrogate.#ctor(devDept.Geometry.RichTriangle)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.RichTriangleSurrogate.T1">
      <summary>
            See <see cref="P:devDept.Geometry.RichTriangle.T1" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.RichTriangleSurrogate.T2">
      <summary>
            See <see cref="P:devDept.Geometry.RichTriangle.T2" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.RichTriangleSurrogate.T3">
      <summary>
            See <see cref="P:devDept.Geometry.RichTriangle.T3" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.RichTriangleSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.RichTriangle.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.SmoothTriangleSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.SmoothTriangle" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SmoothTriangleSurrogate.#ctor(devDept.Geometry.SmoothTriangle)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SmoothTriangleSurrogate.N1">
      <summary>
            See <see cref="P:devDept.Geometry.SmoothTriangle.N1" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SmoothTriangleSurrogate.N2">
      <summary>
            See <see cref="P:devDept.Geometry.SmoothTriangle.N2" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.SmoothTriangleSurrogate.N3">
      <summary>
            See <see cref="P:devDept.Geometry.SmoothTriangle.N3" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SmoothTriangleSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.SmoothTriangle.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.Surrogate`1">
      <summary>
            Base class for classes surrogates.
            </summary>
      <typeparam name="T">The class related to the surrogate.</typeparam>
    </member>
    <member name="M:devDept.Serialization.Surrogate`1.#ctor(`0)">
      <summary>
            Standard constructor.
            </summary>
      <param name="obj">Object that must be serialized</param>
      <remarks>This constructor call the <see cref="M:devDept.Serialization.Surrogate`1.CopyDataFromObject(`0)" /> method.</remarks>
      <seealso cref="M:devDept.Serialization.Surrogate`1.CopyDataFromObject(`0)" />
    </member>
    <member name="P:devDept.Serialization.Surrogate`1.Version">
      <summary>
            Gets the Eyeshot proprietary file format version used for this surrogate.
            </summary>
      <remarks>Internally set with the file header's version.</remarks>
      <remarks>It's set before reading and before writing the surrogate, so it can be used as a discriminant in methods <see cref="M:devDept.Serialization.Surrogate`1.ConvertToObject" />, <see cref="M:devDept.Serialization.Surrogate`1.CopyDataToObject(`0)" /> when reading and <see cref="M:devDept.Serialization.Surrogate`1.BeforeSerialize(ProtoBuf.SerializationContext)" /> when writing.</remarks>
      <remarks>It is equal to -1 when not initialized yet.</remarks>
    </member>
    <member name="F:devDept.Serialization.Surrogate`1.Tag">
      <summary>
            Gets or sets the file header tag (for deserialization purpose only).
            </summary>
      <remarks>
            It can be used to handle custom versions. 
            It is filled by the <see cref="M:devDept.Serialization.Surrogate`1.BeforeDeserialize(ProtoBuf.SerializationContext)" /> method with the data get from the file header.
            </remarks>
    </member>
    <member name="P:devDept.Serialization.Surrogate`1.Log">
      <summary>
            Gets the list of errors and warnings generated during the serialization/deserialization processes.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Surrogate`1.ConvertToObject">
      <summary>
            Creates the object related to the surrogate when reading data.
            </summary>
      <returns>The object created.</returns>
    </member>
    <member name="M:devDept.Serialization.Surrogate`1.CopyDataToObject(`0)">
      <summary>
            Copies common data from surrogate to object when reading data.
            </summary>
      <remarks>This method is called by <see cref="M:devDept.Serialization.Surrogate`1.ConvertToObject" /> method after the creation of the object instance.</remarks>
      <seealso cref="M:devDept.Serialization.Surrogate`1.ConvertToObject" />
    </member>
    <member name="M:devDept.Serialization.Surrogate`1.CopyDataFromObject(`0)">
      <summary>
            Copies all data from the object to its surrogate when writing data.
            </summary>
      <remarks>Use this method to fill ALL the properties of this surrogate. It is called by the empty constructor to initialize the surrogates properties.</remarks>
    </member>
    <member name="M:devDept.Serialization.Surrogate`1.WriteLog(System.String)">
      <summary>
            Writes a message into the log.
            </summary>
      <param name="message">The message to write.</param>
    </member>
    <member name="M:devDept.Serialization.Surrogate`1.BeforeDeserialize(ProtoBuf.SerializationContext)">
      <summary>
            Called before the object deserialization.
            </summary>
      <param name="serializationContext">The serialization context</param>
      <remarks>The override of this method must always call the base at the beginning.</remarks>
      <exception cref="T:System.ArgumentException">Thrown when the serialization context is not a valid <see cref="T:devDept.Serialization.Serializer" /> object.</exception>
    </member>
    <member name="M:devDept.Serialization.Surrogate`1.AfterDeserialize(ProtoBuf.SerializationContext)">
      <summary>
            Called after the object deserialization.
            </summary>
      <param name="serializationContext">The serialization context</param>
      <remarks>The override of this method must always call the base at the beginning.</remarks>
    </member>
    <member name="M:devDept.Serialization.Surrogate`1.BeforeSerialize(ProtoBuf.SerializationContext)">
      <summary>
            Called before the object serialization.
            </summary>
      <param name="serializationContext">The serialization context</param>
      <remarks>The override of this method must always call the base at the beginning.</remarks>
      <exception cref="T:System.ArgumentException">Thrown when the serialization context is not a valid <see cref="T:devDept.Serialization.Serializer" /> object.</exception>
    </member>
    <member name="M:devDept.Serialization.Surrogate`1.ThrowDeprecatedException">
      <summary>
            Throws an exception for obsolete surrogates.
            </summary>
      <remarks>Used for static implicit operators and called in CopyDataFromObject() method.</remarks>
    </member>
    <member name="T:devDept.Serialization.SurrogateWithReferenceId`1">
      <summary>
            Base class for surrogates that support object graph reference.
            </summary>
      <typeparam name="T">The class related to the surrogate.</typeparam>
    </member>
    <member name="M:devDept.Serialization.SurrogateWithReferenceId`1.#ctor(`0)">
      <summary>
            Standard constructor.
            </summary>
      <param name="obj">Object that must be serialized</param>
    </member>
    <member name="M:devDept.Serialization.SurrogateWithReferenceId`1.#ctor(System.Int32)">
      <summary>
            Constructor for object graph reference handling.
            </summary>
      <param name="referenceId">The id associated to this instance.</param>
    </member>
    <member name="P:devDept.Serialization.SurrogateWithReferenceId`1.ReferenceId">
      <summary>
            Gets the unique id assigned to the surrogate during the process of serialization/deserialization to handle object graph reference.
            </summary>
      <remarks>Default value is -1.</remarks>
    </member>
    <member name="T:devDept.Serialization.Vector2DSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Vector2D" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Vector2DSurrogate.#ctor(devDept.Geometry.Vector2D)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.Vector2DSurrogate.X">
      <summary>
            See <see cref="F:devDept.Geometry.Vector2D.X" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.Vector2DSurrogate.Y">
      <summary>
            See <see cref="F:devDept.Geometry.Vector2D.Y" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Vector2DSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Vector2D.#ctor(System.Double,System.Double)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.Vector2DSurrogate.op_Implicit(devDept.Serialization.Vector2DSurrogate)~devDept.Geometry.Vector2D">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Vector2DSurrogate.op_Implicit(devDept.Geometry.Vector2D)~devDept.Serialization.Vector2DSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.Vector2D_V6Surrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Vector2D" /> until version 6 of the Eyeshot file format.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Vector2D_V6Surrogate.#ctor(devDept.Geometry.Vector2D)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Vector2D_V6Surrogate.op_Implicit(devDept.Serialization.Vector2D_V6Surrogate)~devDept.Geometry.Vector2D">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Vector2D_V6Surrogate.op_Implicit(devDept.Geometry.Vector2D)~devDept.Serialization.Vector2D_V6Surrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.Vector3DSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Vector3D" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Vector3DSurrogate.#ctor(devDept.Geometry.Vector3D)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.Vector3DSurrogate.Z">
      <summary>
            See <see cref="F:devDept.Geometry.Vector3D.Z" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Vector3DSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Vector3D.#ctor(System.Double,System.Double,System.Double)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.Vector3D_V6Surrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Vector3D" /> until version 6 of the Eyeshot file format.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Vector3D_V6Surrogate.#ctor(devDept.Geometry.Vector3D)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Vector3D_V6Surrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Vector3D.#ctor(System.Double,System.Double,System.Double)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.Vector3D_V6Surrogate.op_Implicit(devDept.Serialization.Vector3D_V6Surrogate)~devDept.Geometry.Vector3D">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Vector3D_V6Surrogate.op_Implicit(devDept.Geometry.Vector3D)~devDept.Serialization.Vector3D_V6Surrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.PointNormalUvSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.PointNormalUv" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointNormalUvSurrogate.#ctor(devDept.Geometry.PointNormalUv)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PointNormalUvSurrogate.Nx">
      <summary>
            See <see cref="F:devDept.Geometry.PointNormalUv.Nx" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PointNormalUvSurrogate.Ny">
      <summary>
            See <see cref="F:devDept.Geometry.PointNormalUv.Ny" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PointNormalUvSurrogate.Nz">
      <summary>
            See <see cref="F:devDept.Geometry.PointNormalUv.Nz" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PointNormalUvSurrogate.PlotValue">
      <summary>
            See <see cref="F:devDept.Geometry.PointNormalUv.PlotValue" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PointNormalUvSurrogate.ColorIndex">
      <summary>
            See <see cref="F:devDept.Geometry.PointNormalUv.ColorIndex" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PointNormalUvSurrogate.Index">
      <summary>
            See <see cref="F:devDept.Geometry.PointNormalUv.Index" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointNormalUvSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.PointNormalUv.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.PointUvSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.PointUv" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointUvSurrogate.#ctor(devDept.Geometry.PointUv)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PointUvSurrogate.V">
      <summary>
            See <see cref="F:devDept.Geometry.PointUv.V" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointUvSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.PointUv.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.PointUSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.PointU" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointUSurrogate.#ctor(devDept.Geometry.PointU)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PointUSurrogate.U">
      <summary>
            See <see cref="F:devDept.Geometry.PointU.U" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointUSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.PointU.#ctor(System.Double,System.Double,System.Double,System.Double)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.Point4DSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Point4D" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Point4DSurrogate.#ctor(devDept.Geometry.Point4D)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.Point4DSurrogate.W">
      <summary>
            See <see cref="P:devDept.Geometry.Point4D.W" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Point4DSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Point4D.#ctor(System.Double,System.Double,System.Double,System.Double)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.IntervalSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Interval" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.IntervalSurrogate.#ctor(devDept.Geometry.Interval)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.IntervalSurrogate.t0">
      <summary>
            See <see cref="F:devDept.Geometry.Interval.t0" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.IntervalSurrogate.t1">
      <summary>
            See <see cref="F:devDept.Geometry.Interval.t1" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.IntervalSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Interval.#ctor(System.Double,System.Double)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.IntervalSurrogate.op_Implicit(devDept.Serialization.IntervalSurrogate)~devDept.Geometry.Interval">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.IntervalSurrogate.op_Implicit(devDept.Geometry.Interval)~devDept.Serialization.IntervalSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.TransformationSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Transformation" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.TransformationSurrogate.#ctor(devDept.Geometry.Transformation)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.TransformationSurrogate.Matrix">
      <summary>
            The <see cref="P:devDept.Geometry.Transformation.Matrix" /> as many single-dimension arrays.
            </summary>
      <remarks>ProtoBuf-Net does not support serializing/deserializing multi-dimensional arrays.</remarks>
    </member>
    <member name="M:devDept.Serialization.TransformationSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Transformation.#ctor(System.Double[0:,0:])" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.TransformationSurrogate.op_Implicit(devDept.Serialization.TransformationSurrogate)~devDept.Geometry.Transformation">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.TransformationSurrogate.op_Implicit(devDept.Geometry.Transformation)~devDept.Serialization.TransformationSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.PointTangentUSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.PointTangentU" /> surrogate.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PointTangentUSurrogate.U">
      <summary>
            See <see cref="F:devDept.Geometry.PointTangentU.U" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointTangentUSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.PointTangentU.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.PointNormalSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.PointNormal" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointNormalSurrogate.#ctor(devDept.Geometry.PointNormal)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PointNormalSurrogate.Nx">
      <summary>
            See <see cref="F:devDept.Geometry.PointNormal.Nx" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PointNormalSurrogate.Ny">
      <summary>
            See <see cref="F:devDept.Geometry.PointNormal.Ny" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PointNormalSurrogate.Nz">
      <summary>
            See <see cref="F:devDept.Geometry.PointNormal.Nz" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointNormalSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.PointNormal.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.PointWithDisplacementSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.PointWithDisplacement" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointWithDisplacementSurrogate.#ctor(devDept.Geometry.PointWithDisplacement)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PointWithDisplacementSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.PointWithDisplacement.#ctor(System.Double,System.Double,System.Double)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.Polygon2DSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Polygon2D" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Polygon2DSurrogate.#ctor(devDept.Geometry.Polygon2D)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.Polygon2DSurrogate.Min">
      <summary>
            See <see cref="F:devDept.Geometry.Polygon2D.Min" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.Polygon2DSurrogate.Max">
      <summary>
            See <see cref="F:devDept.Geometry.Polygon2D.Max" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.Polygon2DSurrogate.Points">
      <summary>
            See <see cref="F:devDept.Geometry.Polygon2D.Points" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Polygon2DSurrogate.op_Implicit(devDept.Serialization.Polygon2DSurrogate)~devDept.Geometry.Polygon2D">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Polygon2DSurrogate.op_Implicit(devDept.Geometry.Polygon2D)~devDept.Serialization.Polygon2DSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.Segment3DSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Segment3D" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Segment3DSurrogate.#ctor(devDept.Geometry.Segment3D)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.Segment3DSurrogate.P0">
      <summary>
            See <see cref="F:devDept.Geometry.Segment3D.P0" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.Segment3DSurrogate.P1">
      <summary>
            See <see cref="F:devDept.Geometry.Segment3D.P1" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Segment3DSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Segment3D.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Point3D)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.Segment3DSurrogate.op_Implicit(devDept.Serialization.Segment3DSurrogate)~devDept.Geometry.Segment3D">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Segment3DSurrogate.op_Implicit(devDept.Geometry.Segment3D)~devDept.Serialization.Segment3DSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.Segment2DSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Segment2D" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Segment2DSurrogate.#ctor(devDept.Geometry.Segment2D)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.Segment2DSurrogate.P0">
      <summary>
            See <see cref="F:devDept.Geometry.Segment2D.P0" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.Segment2DSurrogate.P1">
      <summary>
            See <see cref="F:devDept.Geometry.Segment2D.P1" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Segment2DSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Segment2D.#ctor(devDept.Geometry.Point2D,devDept.Geometry.Point2D)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.Segment2DSurrogate.op_Implicit(devDept.Serialization.Segment2DSurrogate)~devDept.Geometry.Segment2D">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Segment2DSurrogate.op_Implicit(devDept.Geometry.Segment2D)~devDept.Serialization.Segment2DSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.GEntitySurrogate">
      <summary>
            Defines the base class for gEntity surrogates.
            </summary>
      <remarks>This class is not declared as abstract to handle not supported gEntity.</remarks>
    </member>
    <member name="M:devDept.Serialization.GEntitySurrogate.#ctor(devDept.Geometry.Entities.GEntity)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GEntitySurrogate.EntityData">
      <summary>
            The <see cref="P:devDept.Geometry.Entities.GEntity.EntityData" /> as <see cref="T:devDept.Serialization.ProtoObject" />.
            </summary>
      <remarks>ProtoBuf does not support serializing/deserializing object.</remarks>
      <seealso cref="T:devDept.Serialization.ProtoObject" />
    </member>
    <member name="F:devDept.Serialization.GEntitySurrogate.Type">
      <summary>
            Gets the gEntity type for logging purpose (Not supported gEntity type, i.e. different Eyeshot editions).        
            </summary>
    </member>
    <member name="M:devDept.Serialization.GEntitySurrogate.ConvertToObject">
      <summary>
            Creates the gEntity related to the surrogate.
            </summary>
      <returns>The gEntity created.</returns>
    </member>
    <member name="M:devDept.Serialization.GEntitySurrogate.CopyDataToObject(devDept.Geometry.Entities.GEntity)">
      <inheritdoc />
    </member>
    <member name="M:devDept.Serialization.GEntitySurrogate.CopyDataFromObject(devDept.Geometry.Entities.GEntity)">
      <inheritdoc />
    </member>
    <member name="M:devDept.Serialization.GEntitySurrogate.op_Implicit(devDept.Serialization.GEntitySurrogate)~devDept.Geometry.Entities.GEntity">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GEntitySurrogate.op_Implicit(devDept.Geometry.Entities.GEntity)~devDept.Serialization.GEntitySurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
      <exception cref="T:devDept.Eyeshot.EyeshotException">Thrown when the <see cref="M:devDept.Geometry.Entities.GEntity.ConvertToSurrogate" /> method returns null value.</exception>
    </member>
    <member name="M:devDept.Serialization.GEntitySurrogate.BeforeDeserialize(ProtoBuf.SerializationContext)">
      <summary>
            Called before the object deserialization.
            </summary>
      <param name="serializationContext">The serialization context</param>
      <remarks>The override of this method must always call the base at the beginning.</remarks>
      <exception cref="T:System.ArgumentException">Thrown when the serialization context is not a valid <see cref="!:FileSerializer" /> object.</exception>
    </member>
    <member name="M:devDept.Serialization.GEntitySurrogate.BeforeSerialize(ProtoBuf.SerializationContext)">
      <summary>
            Called before the object serialization.
            </summary>
      <param name="serializationContext">The serialization context</param>
      <remarks>The override of this method must always call the base at the beginning.</remarks>
      <exception cref="T:System.ArgumentException">Thrown when the serialization context is not a valid <see cref="!:FileSerializer" /> object.</exception>
    </member>
    <member name="T:devDept.Serialization.GLineSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GLine" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GLineSurrogate.#ctor(devDept.Geometry.Entities.GLine)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GLineSurrogate.StartPoint">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GLine.StartPoint" /></summary>
    </member>
    <!-- Badly formed XML comment ignored for member "F:devDept.Serialization.GLineSurrogate.EndPoint" -->
    <member name="M:devDept.Serialization.GLineSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GLine.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Point3D)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GArcSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GArc" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GArcSurrogate.#ctor(devDept.Geometry.Entities.GArc)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GArcSurrogate.Domain">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GArc.Domain" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GArcSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GArc.#ctor(devDept.Geometry.Plane,devDept.Geometry.Point3D,System.Double,System.Double,System.Double)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GCircleSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GCircle" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GCircleSurrogate.#ctor(devDept.Geometry.Entities.GCircle)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GCircleSurrogate.Plane">
      <summary>
            See <see cref="T:devDept.Geometry.Plane" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GCircleSurrogate.Radius">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GCircle.Radius" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GCircleSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GCircle.#ctor(devDept.Geometry.Plane,System.Double)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GPlanarEntitySurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GPlanarEntity" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GPlanarEntitySurrogate.#ctor(devDept.Geometry.Entities.GPlanarEntity)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GPlanarEntitySurrogate.Plane">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GPlanarEntity.Plane" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GPlanarEntitySurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="T:devDept.Geometry.Entities.GPlanarEntity" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GPointSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GPoint" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GPointSurrogate.#ctor(devDept.Geometry.Entities.GPoint)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GPointSurrogate.Position">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GPoint.Position" /></summary>
    </member>
    <member name="M:devDept.Serialization.GPointSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GPoint.#ctor(devDept.Geometry.Point3D)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GLinearPathSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GLinearPath" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GLinearPathSurrogate.#ctor(devDept.Geometry.Entities.GLinearPath)">
      <summary>
            Standard Constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GLinearPathSurrogate.Vertices">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GLinearPath.Vertices" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GLinearPathSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GLinearPath.#ctor(devDept.Geometry.Point3D[])" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GEllipseSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GEllipse" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GEllipseSurrogate.#ctor(devDept.Geometry.Entities.GEllipse)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GEllipseSurrogate.Plane">
      <summary>
            See <see cref="T:devDept.Geometry.Plane" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GEllipseSurrogate.RadiusX">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GEllipse.RadiusX" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GEllipseSurrogate.RadiusY">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GEllipse.RadiusY" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GEllipseSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GEllipse.#ctor(devDept.Geometry.Plane,System.Double,System.Double)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GEllipticalArcSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GEllipticalArc" /> surrogate.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GEllipticalArcSurrogate.Domain">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GEllipticalArc.Domain" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GEllipticalArcSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GEllipticalArc.#ctor(devDept.Geometry.Plane,System.Double,System.Double,System.Double,System.Double)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GQuadSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GQuad" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GQuadSurrogate.#ctor(devDept.Geometry.Entities.GQuad)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GQuadSurrogate.V1">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GQuad.V1" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GQuadSurrogate.V2">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GQuad.V2" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GQuadSurrogate.V3">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GQuad.V3" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GQuadSurrogate.V4">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GQuad.V4" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GQuadSurrogate.Normal">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GQuad.Normal" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GQuadSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="T:devDept.Geometry.Entities.GQuad" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GTriangleSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GTriangle" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GTriangleSurrogate.#ctor(devDept.Geometry.Entities.GTriangle)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GTriangleSurrogate.V1">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GTriangle.V1" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GTriangleSurrogate.V2">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GTriangle.V2" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GTriangleSurrogate.V3">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GTriangle.V3" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GTriangleSurrogate.Normal">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GTriangle.Normal" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GTriangleSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GTriangle.#ctor(devDept.Geometry.Point3D,devDept.Geometry.Point3D,devDept.Geometry.Point3D)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.serializationType">
      <summary>
            The serialization type for the Eyeshot proprietary file format.
            </summary>
    </member>
    <member name="F:devDept.Serialization.serializationType.Uncompressed">
      <summary>
            Uncompressed file format.
            </summary>
    </member>
    <member name="F:devDept.Serialization.serializationType.Compressed">
      <summary>
            Compressed file format.
            </summary>
    </member>
    <member name="F:devDept.Serialization.serializationType.WithLengthPrefix">
      <summary>
            Custom file format.
            </summary>
      <remarks>Use this value in the file header to identify an object-by-object serialization for your custom binary file format. Any kind of compression is delegated to you.</remarks>
    </member>
    <member name="T:devDept.Serialization.Serializer">
      <summary>
            Base class that defines the protobuf model for the Eyeshot proprietary file format.
            </summary>
    </member>
    <member name="F:devDept.Serialization.Serializer.LastVersion">
      <summary>
            Gets the last supported Eyeshot proprietary file format version.
            </summary>
    </member>
    <member name="F:devDept.Serialization.Serializer.FirstVersion">
      <summary>
            Gets the first supported Eyeshot proprietary file format version.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Serializer.IsValidVersion(System.Int32)">
      <summary>
            Checks if a version is a valid Eyeshot proprietary file format version.
            </summary>
      <param name="version">The Eyeshot proprietary file format version to check.</param>
      <returns>True when the version is supported, otherwise false.</returns>
    </member>
    <member name="M:devDept.Serialization.Serializer.ResizeCache(System.Int32)">
      <summary>
            Resizes the cache for object graph reference handling.
            </summary>
      <param name="size">
      </param>
    </member>
    <member name="M:devDept.Serialization.Serializer.AddToCache(System.Object,devDept.Serialization.ISurrogateWithReferenceId)">
      <summary>
            For internal use only. Adds the specified key and value to the serializer cache for the current thread during the serialization process.
            </summary>
      <param name="objKey">The the element to add as key.</param>
      <param name="objValue">The value of the element to add.</param>
      <remarks>The <see cref="P:devDept.Serialization.ISurrogateWithReferenceId.ReferenceId" /> is updated for <paramref name="objValue" /></remarks>
    </member>
    <member name="M:devDept.Serialization.Serializer.AddToCache(devDept.Serialization.ISurrogateWithReferenceId,System.Object)">
      <summary>
            For internal use only. Adds the specified key and value to the serializer cache for the current thread during the serialization process.
            </summary>
      <param name="objKey">The the element to add as key.</param>
      <param name="objValue">The value of the element to add.</param>
      <remarks>The <see cref="P:devDept.Serialization.ISurrogateWithReferenceId.ReferenceId" /> is updated for <paramref name="objKey" /></remarks>
    </member>
    <member name="M:devDept.Serialization.Serializer.AddToObjectsCache(System.Object,System.Object)">
      <summary>
            For internal use only. Adds the specified key and value to the serializer cache for the current thread during the serialization process.
            </summary>
      <param name="objKey">The the element to add as key.</param>
      <param name="objValue">The value of the element to add.</param>
      <remarks>
        <para>You can use this cache to store data not stored in objects anymore.</para>
        <para>Useful for Eyeshot proprietary file format backward compatibility during deserialization process.</para>
      </remarks>
    </member>
    <member name="M:devDept.Serialization.Serializer.ResetCache">
      <summary>
            For internal use only. Resets the cache for the current thread.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Serializer.GetCachedObjectWithReferenceId(System.Object)">
      <summary>
            For internal use only. Gets the <see cref="T:devDept.Serialization.ISurrogateWithReferenceId" /> associated with the specified object for the current thread.
            </summary>
      <param name="obj">The object corresponding to the value to get.</param>
      <returns>The related ISurrogateWithReferenceId if presents, otherwise null.</returns>
    </member>
    <member name="M:devDept.Serialization.Serializer.GetCachedObject(devDept.Serialization.ISurrogateWithReferenceId)">
      <summary>
            For internal use only. Gets the cached object associated with the specified <see cref="T:devDept.Serialization.ISurrogateWithReferenceId" />.
            </summary>
      <param name="surrogateWithReferenceId">The <see cref="T:devDept.Serialization.ISurrogateWithReferenceId" /> corresponding to the object to get.</param>
      <returns>The related object if presents, otherwise null.</returns>
    </member>
    <member name="M:devDept.Serialization.Serializer.GetCachedObject(System.Object)">
      <summary>
            For internal use only. Gets the cached object associated with the specified key.
            </summary>
      <param name="key">The key of the element to get.</param>
      <returns>The related object if presents, otherwise null.</returns>
      <remarks>
        <para>You can use this cache to store data not stored in objects anymore.</para>
        <para>Useful for Eyeshot proprietary file format backward compatibility during deserialization process.</para>
      </remarks>
    </member>
    <member name="M:devDept.Serialization.Serializer.#ctor">
      <summary>
            Empty constructor for deserialization purpose only.
            </summary>
    </member>
    <member name="P:devDept.Serialization.Serializer.HeaderVersion">
      <summary>
            During the serialization it represents the <see cref="F:devDept.Serialization.Serializer.LastVersion" />, during the deserialization it represents the file header version.
            </summary>
      <remarks>It is equal to -1 when the Header is not read yet.</remarks>
    </member>
    <member name="P:devDept.Serialization.Serializer.HeaderTag">
      <summary>
            During the serialization it represents the custom tag, during the deserialization it represents the file header tag.
            </summary>
      <remarks>It is equal to null when the Header is not read yet.</remarks>
    </member>
    <member name="P:devDept.Serialization.Serializer.Model">
      <summary>
            The ProtoBuf.Meta.RuntimeTypeModel that contains the object types that must be serialized.
            </summary>
    </member>
    <member name="P:devDept.Serialization.Serializer.Log">
      <summary>
            Gets the list of errors and warnings generated during the serialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Serializer.SetProtobufModel(ProtoBuf.Meta.RuntimeTypeModel)">
      <summary>
            Sets the protobuf model.
            </summary>
      <remarks>
        <para>You can use this method to speedup Serializer initialization by using a protobuf model already compiled (for example when reading or writing a multiple files with the same protobuf declaration).</para>
        <para>After calling this method both <see cref="M:devDept.Serialization.Serializer.FillHeaderModel" /> and <see cref="M:devDept.Serialization.Serializer.FillModel" /> methods will be skipped of course.</para>
      </remarks>
      <seealso cref="M:devDept.Serialization.Serializer.FillHeaderModel" />
      <seealso cref="M:devDept.Serialization.Serializer.FillModel" />
      <seealso cref="M:devDept.Serialization.Serializer.ModelIsCompiled" />
    </member>
    <member name="M:devDept.Serialization.Serializer.Contains(System.Type)">
      <summary>
            Checks if the type is contained in the serializer model.
            </summary>
      <param name="type">The object type.</param>
      <returns>True when the type is contained in the <see cref="P:devDept.Serialization.Serializer.Model" />, otherwise false.</returns>
    </member>
    <member name="M:devDept.Serialization.Serializer.WriteLog(System.String)">
      <summary>
            Writes a message into the log.
            </summary>
      <param name="message">The message to write.</param>
    </member>
    <member name="M:devDept.Serialization.Serializer.FillHeaderModel">
      <summary>
            Initialize the protobuf model for the file header.
            </summary>
      <remarks>Derived class have to call the base.FillModel() first.</remarks>
    </member>
    <member name="M:devDept.Serialization.Serializer.FillModel">
      <summary>
            Initialize the protobuf model for the Eyeshot proprietary file format.
            </summary>
      <remarks>Derived class have to call the base.FillModel() first.</remarks>
    </member>
    <member name="M:devDept.Serialization.Serializer.AddPlaneField(ProtoBuf.Meta.MetaType)">
      <summary>
            Adds the "Plane" field with fieldNumber = 50 for a specific surrogate definition.
            </summary>
      <param name="metaType">The meta type object representing the surrogate definition.</param>
      <remarks>For internal use only.</remarks>
    </member>
    <member name="M:devDept.Serialization.Serializer.AddVerticesField(ProtoBuf.Meta.MetaType)">
      <summary>
            Adds the "Vertices" field with fieldNumber = 51 for a specific surrogate definition.
            </summary>
      <param name="metaType">The meta type object representing the surrogate definition.</param>
      <remarks>For internal use only.</remarks>
    </member>
    <member name="M:devDept.Serialization.Serializer.AddTrianglesField(ProtoBuf.Meta.MetaType)">
      <summary>
            Adds the "Triangles" field with fieldNumber = 52 for a specific surrogate definition.
            </summary>
      <param name="metaType">The meta type object representing the surrogate definition.</param>
      <remarks>For internal use only.</remarks>
    </member>
    <member name="M:devDept.Serialization.Serializer.AddNormalsField(ProtoBuf.Meta.MetaType)">
      <summary>
            Adds the "Normals" field with fieldNumber = 53 for a specific surrogate definition.
            </summary>
      <param name="metaType">The meta type object representing the surrogate definition.</param>
      <remarks>For internal use only.</remarks>
    </member>
    <member name="M:devDept.Serialization.Serializer.AddTextureCoordsField(ProtoBuf.Meta.MetaType)">
      <summary>
            Adds the "TextureCoords" field with fieldNumber = 54 for a specific surrogate definition.
            </summary>
      <param name="metaType">The meta type object representing the surrogate definition.</param>
      <remarks>For internal use only.</remarks>
    </member>
    <member name="M:devDept.Serialization.Serializer.AddEdgesField(ProtoBuf.Meta.MetaType)">
      <summary>
            Adds the "Edges" field with fieldNumber = 55 for a specific surrogate definition.
            </summary>
      <param name="metaType">The meta type object representing the surrogate definition.</param>
      <remarks>For internal use only.</remarks>
    </member>
    <member name="M:devDept.Serialization.Serializer.AddNormalField(ProtoBuf.Meta.MetaType)">
      <summary>
            Adds the "Normal" field with fieldNumber = 56 for a specific surrogate definition.
            </summary>
      <param name="metaType">The meta type object representing the surrogate definition.</param>
      <remarks>For internal use only.</remarks>
    </member>
    <member name="M:devDept.Serialization.Serializer.CompileModel">
      <summary>
            Compile protobuf model in place for better performance and freeze it. This method can be used when all types are known beforehand.
            </summary>
      <exception cref="T:System.NullReferenceException">Thrown when the <see cref="P:devDept.Serialization.Serializer.Model" /> is null.</exception>
    </member>
    <member name="M:devDept.Serialization.Serializer.ModelIsCompiled">
      <summary>
            Indicates whether the protobuf model is already compiled or not.
            </summary>
      <returns>True when the protobuf model is compiled, otherwise false.</returns>
      <remarks>Once the protobuf model is compiled it cannot be changed anymore, except if the <see cref="M:devDept.Serialization.Serializer.ResetModel" />() method is called.</remarks>
      <seealso cref="M:devDept.Serialization.Serializer.SetProtobufModel(ProtoBuf.Meta.RuntimeTypeModel)" />
      <seealso cref="M:devDept.Serialization.Serializer.ResetModel" />
    </member>
    <member name="M:devDept.Serialization.Serializer.ResetModel">
      <summary>
            Resets the protobuf model.
            </summary>
    </member>
    <member name="M:devDept.Serialization.Serializer.GetType(System.String)">
      <summary>
            Gets the <see cref="T:System.Type" /> from an assembly qualified name.
            </summary>
      <remarks>
            This method is used to read properties of type object.
            For Serializer derived class, you need to make the override of the <see cref="M:devDept.Serialization.Serializer.GetTypeForObject(System.String)" /> method.
            </remarks>
      <seealso cref="M:devDept.Serialization.Serializer.GetTypeForObject(System.String)" />
      <seealso cref="T:devDept.Serialization.ProtoObject" />
    </member>
    <member name="M:devDept.Serialization.Serializer.GetTypeForObject(System.String)">
      <summary>
            Gets the type of an object starting from the assembly name.
            </summary>
      <remarks>Derived classes must first call <see cref="M:System.Type.GetType" /> method. If null, then they can call base method.</remarks>
      <seealso cref="M:devDept.Serialization.Serializer.GetType(System.String)" />
    </member>
    <member name="T:devDept.Serialization.ISurrogateWithReferenceId">
      <summary>
            Interface for objects supporting the object graph reference with the Eyeshot proprietary file format.
            </summary>
    </member>
    <member name="P:devDept.Serialization.ISurrogateWithReferenceId.ReferenceId">
      <summary>
            Gets or sets the id for the object referenced more than once during the process of serialization/deserialization.
            </summary>
      <remarks>Default value is -1.</remarks>
    </member>
    <member name="T:devDept.Serialization.FaceSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GSolid.Face" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.FaceSurrogate.#ctor(devDept.Geometry.Entities.GSolid.Face)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.FaceSurrogate.FirstContour">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GSolid.Face.FirstContour" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.FaceSurrogate.FaceLabel">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GSolid.Face.FaceLabel" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.FaceSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GSolid.Face.#ctor(System.Int32,System.Int32)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.FaceSurrogate.op_Implicit(devDept.Serialization.FaceSurrogate)~devDept.Geometry.Entities.GSolid.Face">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.FaceSurrogate.op_Implicit(devDept.Geometry.Entities.GSolid.Face)~devDept.Serialization.FaceSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.EdgeDataSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GSolid.EdgeData" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.EdgeDataSurrogate.#ctor(devDept.Geometry.Entities.GSolid.EdgeData)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.EdgeDataSurrogate.BeginVertex">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GSolid.EdgeData.BeginVertex" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.EdgeDataSurrogate.EndVertex">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GSolid.EdgeData.EndVertex" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.EdgeDataSurrogate.Type">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GSolid.EdgeData.Type" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.EdgeDataSurrogate.NextFace">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GSolid.EdgeData.NextFace" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.EdgeDataSurrogate.NextEdge">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GSolid.EdgeData.NextEdge" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.EdgeDataSurrogate.PreviousFace">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GSolid.EdgeData.PreviousFace" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.EdgeDataSurrogate.PreviousEdge">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GSolid.EdgeData.PreviousEdge" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.EdgeDataSurrogate.Angle">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GSolid.EdgeData.Angle" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.EdgeDataSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="T:devDept.Geometry.Entities.GSolid.EdgeData" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.EdgeDataSurrogate.op_Implicit(devDept.Serialization.EdgeDataSurrogate)~devDept.Geometry.Entities.GSolid.EdgeData">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.EdgeDataSurrogate.op_Implicit(devDept.Geometry.Entities.GSolid.EdgeData)~devDept.Serialization.EdgeDataSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.CycleSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GSolid.Cycle" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.CycleSurrogate.#ctor(devDept.Geometry.Entities.GSolid.Cycle)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.CycleSurrogate.FirstEdge">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GSolid.Cycle.FirstEdge" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.CycleSurrogate.NextContour">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GSolid.Cycle.NextContour" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.CycleSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="T:devDept.Geometry.Entities.GSolid.Cycle" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.CycleSurrogate.op_Implicit(devDept.Serialization.CycleSurrogate)~devDept.Geometry.Entities.GSolid.Cycle">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.CycleSurrogate.op_Implicit(devDept.Geometry.Entities.GSolid.Cycle)~devDept.Serialization.CycleSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.GPortionSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GSolid.Portion" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GPortionSurrogate.#ctor(devDept.Geometry.Entities.GSolid.Portion)">
      <summary>
            Standard Constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GPortionSurrogate.MeshNature">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GMesh.MeshNature" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GPortionSurrogate.EdgeStyle">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GMesh.EdgeStyle" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GPortionSurrogate.Vertices">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GSolid.Portion.Vertices" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GPortionSurrogate.Triangles">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GMesh.Triangles" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GPortionSurrogate.TextureCoords">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GMesh.TextureCoords" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GPortionSurrogate.Normals">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GMesh.Normals" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GPortionSurrogate.Edges">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GMesh.Edges" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GPortionSurrogate.SmoothingAngle">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GMesh.SmoothingAngle" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GPortionSurrogate.LightWeight">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GMesh.LightWeight" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GPortionSurrogate.Id">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GSolid.Portion.Id" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GPortionSurrogate.EdgeDatas">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GSolid.Portion.EdgeDatas" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GPortionSurrogate.Faces">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GSolid.Portion.Faces" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GPortionSurrogate.Cycles">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GSolid.Portion.Cycles" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GPortionSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="T:devDept.Geometry.Entities.GSolid.Portion" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GSolidSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GSolid" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GSolidSurrogate.#ctor(devDept.Geometry.Entities.GSolid)">
      <summary>
            Standard Constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GSolidSurrogate.TextureMapping">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GSolid.TextureMapping" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GSolidSurrogate.Portions">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GSolid.Portions" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GSolidSurrogate.SmoothingAngle">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GSolid.SmoothingAngle" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GSolidSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GSolid.#ctor(System.Boolean,System.Collections.Generic.IList{devDept.Geometry.Entities.GSolid.Portion})" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.FemIndexLineExSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Fem.IndexLineEx" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.FemIndexLineExSurrogate.#ctor(devDept.Geometry.Fem.IndexLineEx)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.FemIndexLineExSurrogate.ElementIndex">
      <summary>
            See <see cref="P:devDept.Geometry.Fem.IndexLineEx.ElementIndex" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.FemIndexLineExSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Fem.IndexLineEx.#ctor(System.Int32,System.Int32,System.Int32)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.FemIndexTriangleExSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Fem.IndexTriangleEx" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.FemIndexTriangleExSurrogate.#ctor(devDept.Geometry.Fem.IndexTriangleEx)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.FemIndexTriangleExSurrogate.ElementIndex">
      <summary>
            See <see cref="P:devDept.Geometry.Fem.IndexTriangleEx.ElementIndex" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.FemIndexTriangleExSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Fem.IndexTriangleEx.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GBrepFaceSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GBrep.Face" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GBrepFaceSurrogate.#ctor(devDept.Geometry.Entities.GBrep.Face)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepFaceSurrogate.Surface">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GBrep.Face.Surface" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepFaceSurrogate.Loops">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GBrep.Face.Loops" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepFaceSurrogate.Sense">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GBrep.Face.Sense" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepFaceSurrogate.ARGB">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GBrep.Face.ARGB" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepFaceSurrogate.TextureOffsetU">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GBrep.Face.TextureOffsetU" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepFaceSurrogate.TextureScaleU">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GBrep.Face.TextureScaleU" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepFaceSurrogate.TextureOffsetV">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GBrep.Face.TextureOffsetV" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepFaceSurrogate.TextureScaleV">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GBrep.Face.TextureScaleV" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GBrepFaceSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GBrep.Face.#ctor(devDept.Geometry.AnalyticSurf,devDept.Geometry.Entities.GBrep.Loop[],System.Boolean,System.Nullable{System.Int32})" /> constructor to create the object.
             </remarks>
    </member>
    <member name="M:devDept.Serialization.GBrepFaceSurrogate.op_Implicit(devDept.Serialization.GBrepFaceSurrogate)~devDept.Geometry.Entities.GBrep.Face">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GBrepFaceSurrogate.op_Implicit(devDept.Geometry.Entities.GBrep.Face)~devDept.Serialization.GBrepFaceSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.GBrepEdgeSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GBrep.Edge" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GBrepEdgeSurrogate.#ctor(devDept.Geometry.Entities.GBrep.Edge)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepEdgeSurrogate.StartPointIndex">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GBrep.Edge.StartPointIndex" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepEdgeSurrogate.EndPointIndex">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GBrep.Edge.EndPointIndex" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepEdgeSurrogate.Curve">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GBrep.Edge.Curve" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepEdgeSurrogate.ShellIndex">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GBrep.Edge.ShellIndex" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepEdgeSurrogate.Parents">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GBrep.Edge.Parents" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GBrepEdgeSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GBrep.Edge.#ctor(devDept.Geometry.Entities.IGCurve,System.Int32,System.Int32)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.GBrepEdgeSurrogate.op_Implicit(devDept.Serialization.GBrepEdgeSurrogate)~devDept.Geometry.Entities.GBrep.Edge">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GBrepEdgeSurrogate.op_Implicit(devDept.Geometry.Entities.GBrep.Edge)~devDept.Serialization.GBrepEdgeSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.GBrepLoopSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GBrep.Loop" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GBrepLoopSurrogate.#ctor(devDept.Geometry.Entities.GBrep.Loop)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepLoopSurrogate.Segments">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GBrep.Loop.Segments" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepLoopSurrogate.Sense">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GBrep.Loop.Sense" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GBrepLoopSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GBrep.Loop.#ctor(devDept.Geometry.Entities.GBrep.OrientedEdge[],System.Boolean)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.GBrepLoopSurrogate.op_Implicit(devDept.Serialization.GBrepLoopSurrogate)~devDept.Geometry.Entities.GBrep.Loop">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GBrepLoopSurrogate.op_Implicit(devDept.Geometry.Entities.GBrep.Loop)~devDept.Serialization.GBrepLoopSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.GBrepOrientedEdgeSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GBrep.OrientedEdge" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GBrepOrientedEdgeSurrogate.#ctor(devDept.Geometry.Entities.GBrep.OrientedEdge)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepOrientedEdgeSurrogate.Sense">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GBrep.OrientedEdge.Sense" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepOrientedEdgeSurrogate.CurveIndex">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GBrep.OrientedEdge.CurveIndex" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GBrepOrientedEdgeSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GBrep.OrientedEdge.#ctor(System.Int32,System.Boolean)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="M:devDept.Serialization.GBrepOrientedEdgeSurrogate.op_Implicit(devDept.Serialization.GBrepOrientedEdgeSurrogate)~devDept.Geometry.Entities.GBrep.OrientedEdge">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GBrepOrientedEdgeSurrogate.op_Implicit(devDept.Geometry.Entities.GBrep.OrientedEdge)~devDept.Serialization.GBrepOrientedEdgeSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.GBrepSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GSolid.Brep" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GBrepSurrogate.#ctor(devDept.Geometry.Entities.GBrep)">
      <summary>
            Standard Constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepSurrogate.Vertices">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GBrep.Vertices" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepSurrogate.Edges">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GBrep.Edges" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepSurrogate.Faces">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GBrep.Faces" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepSurrogate.Inners">
      <summary>
            The <see cref="P:devDept.Geometry.Entities.GBrep.Inners" /> as list of <see cref="T:devDept.Serialization.ProtoJaggedArray`1" />.
            </summary>
      <remarks>ProtoBuf-Net does not support serializing/deserializing jagged arrays.</remarks>
    </member>
    <member name="F:devDept.Serialization.GBrepSurrogate.RebuildTolerance">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GBrep.RebuildTolerance" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GBrepSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses a <see cref="T:devDept.Geometry.Entities.GBrep" /> internal constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GBrepVertexSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GBrep.Vertex" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GBrepVertexSurrogate.#ctor(devDept.Geometry.Entities.GBrep.Vertex)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GBrepVertexSurrogate.Parents">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GBrep.Vertex.Parents" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GBrepVertexSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GBrep.Vertex.#ctor(System.Double,System.Double,System.Double)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.AnalyticSurfSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.AnalyticSurf" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.AnalyticSurfSurrogate.#ctor(devDept.Geometry.AnalyticSurf)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.AnalyticSurfSurrogate.Index">
      <summary>
            See <see cref="P:devDept.Geometry.AnalyticSurf.Index" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.AnalyticSurfSurrogate.ConvertToObject">
      <inheritdoc />
    </member>
    <member name="M:devDept.Serialization.AnalyticSurfSurrogate.op_Implicit(devDept.Serialization.AnalyticSurfSurrogate)~devDept.Geometry.AnalyticSurf">
      <summary>
            Converts the surrogate to the related object during the deserialization process.
            </summary>
    </member>
    <member name="M:devDept.Serialization.AnalyticSurfSurrogate.op_Implicit(devDept.Geometry.AnalyticSurf)~devDept.Serialization.AnalyticSurfSurrogate">
      <summary>
            Converts the object to the related surrogate during the serialization process.
            </summary>
    </member>
    <member name="T:devDept.Serialization.ConicalSurfSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ConicalSurf" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.ConicalSurfSurrogate.#ctor(devDept.Geometry.ConicalSurf)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.ConicalSurfSurrogate.HalfAngle">
      <summary>
            See <see cref="P:devDept.Geometry.ConicalSurf.HalfAngle" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.ConicalSurfSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.ConicalSurf.#ctor(devDept.Geometry.Plane,System.Double,System.Double,System.Int32)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.CylindricalSurfSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.CylindricalSurf" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.CylindricalSurfSurrogate.#ctor(devDept.Geometry.CylindricalSurf)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.CylindricalSurfSurrogate.Radius">
      <summary>
            See <see cref="P:devDept.Geometry.CylindricalSurf.Radius" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.CylindricalSurfSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.CylindricalSurf.#ctor(devDept.Geometry.Plane,System.Double,System.Int32)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.NurbsSurfSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.NurbsSurf" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.NurbsSurfSurrogate.#ctor(devDept.Geometry.NurbsSurf)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.NurbsSurfSurrogate.DegreeU">
      <summary>
            See <see cref="P:devDept.Geometry.NurbsSurf.DegreeU" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.NurbsSurfSurrogate.KnotVectorU">
      <summary>
            See <see cref="P:devDept.Geometry.NurbsSurf.KnotVectorU" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.NurbsSurfSurrogate.DegreeV">
      <summary>
            See <see cref="P:devDept.Geometry.NurbsSurf.DegreeV" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.NurbsSurfSurrogate.KnotVectorV">
      <summary>
            See <see cref="P:devDept.Geometry.NurbsSurf.KnotVectorV" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.NurbsSurfSurrogate.ControlPoints">
      <summary>
            The <see cref="P:devDept.Geometry.NurbsSurf.ControlPoints" /> as many single-dimension arrays.
            </summary>
      <remarks>ProtoBuf-Net does not support serializing/deserializing multi-dimensional arrays.</remarks>
    </member>
    <member name="M:devDept.Serialization.NurbsSurfSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.NurbsSurf.#ctor(System.Int32,System.Double[],System.Int32,System.Double[],devDept.Geometry.Point4D[0:,0:],System.Int32)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.PlanarSurfSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.PlanarSurf" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PlanarSurfSurrogate.#ctor(devDept.Geometry.PlanarSurf)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.PlanarSurfSurrogate.Plane">
      <summary>
            See <see cref="P:devDept.Geometry.PlanarSurf.Plane" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.PlanarSurfSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.PlanarSurf.#ctor(devDept.Geometry.Plane,System.Int32)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.RevolvedSurfSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.RevolvedSurf" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.RevolvedSurfSurrogate.#ctor(devDept.Geometry.RevolvedSurf)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.RevolvedSurfSurrogate.Generatrix">
      <summary>
            See <see cref="P:devDept.Geometry.RevolvedSurf.Generatrix" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.RevolvedSurfSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="T:devDept.Geometry.RevolvedSurf" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.SphericalSurfSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.SphericalSurf" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SphericalSurfSurrogate.#ctor(devDept.Geometry.SphericalSurf)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.Serialization.SphericalSurfSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.SphericalSurf.#ctor(devDept.Geometry.Plane,System.Double,System.Int32)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.TabulatedSurfSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.TabulatedSurf" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.TabulatedSurfSurrogate.#ctor(devDept.Geometry.TabulatedSurf)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.TabulatedSurfSurrogate.Directrix">
      <summary>
            See <see cref="P:devDept.Geometry.TabulatedSurf.Directrix" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.TabulatedSurfSurrogate.Generatrix">
      <summary>
            See <see cref="P:devDept.Geometry.TabulatedSurf.Generatrix" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.TabulatedSurfSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="T:devDept.Geometry.TabulatedSurf" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.ToroidalSurfSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.ToroidalSurf" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.ToroidalSurfSurrogate.#ctor(devDept.Geometry.ToroidalSurf)">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.ToroidalSurfSurrogate.MajorRadius">
      <summary>
            See <see cref="P:devDept.Geometry.ToroidalSurf.MajorRadius" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.ToroidalSurfSurrogate.MinorRadius">
      <summary>
            See <see cref="P:devDept.Geometry.ToroidalSurf.MinorRadius" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.ToroidalSurfSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.ToroidalSurf.#ctor(devDept.Geometry.Plane,System.Double,System.Double,System.Int32)" /> constructor to create the object.        
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GConicalSurfaceSurrogate">
      <summary>
            Defines the <see cref="!:Eyeshot.Entities.GConicalSurface" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GConicalSurfaceSurrogate.#ctor(devDept.Geometry.Entities.GConicalSurface)">
      <summary>
            Standard Constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GConicalSurfaceSurrogate.HalfAngle">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GConicalSurface.HalfAngle" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GConicalSurfaceSurrogate.Tip">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GConicalSurface.Tip" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GConicalSurfaceSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GConicalSurface.#ctor(System.Int32,System.Double[],System.Int32,System.Double[],devDept.Geometry.Point4D[0:,0:],devDept.Geometry.Entities.IGCurve,System.Double,devDept.Geometry.Plane,System.Double,devDept.Geometry.Point3D)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GCylindricalSurfaceSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GCylindricalSurface" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GCylindricalSurfaceSurrogate.#ctor(devDept.Geometry.Entities.GCylindricalSurface)">
      <summary>
            Standard Constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GCylindricalSurfaceSurrogate.Radius">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GCylindricalSurface.Radius" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GCylindricalSurfaceSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GCylindricalSurface.#ctor(System.Int32,System.Double[],System.Int32,System.Double[],devDept.Geometry.Point4D[0:,0:],devDept.Geometry.Entities.IGCurve,System.Double,devDept.Geometry.Plane)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GSurfaceSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GSurface" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GSurfaceSurrogate.#ctor(devDept.Geometry.Entities.GSurface)">
      <summary>
            Standard Constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GSurfaceSurrogate.ControlPoints">
      <summary>
            The <see cref="F:devDept.Geometry.Entities.GSurface.Pw" /> as many single-dimension arrays.
            </summary>
      <remarks>ProtoBuf-Net does not support serializing/deserializing multi-dimensional arrays.</remarks>
    </member>
    <member name="F:devDept.Serialization.GSurfaceSurrogate.DegreeV">
      <summary>
            V degree.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GSurfaceSurrogate.KnotVectorV">
      <summary>
            V knot vector.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GSurfaceSurrogate.Trimming">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GSurface.Trimming" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GSurfaceSurrogate.TextureScaleU">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GSurface.TextureScaleU" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GSurfaceSurrogate.TextureScaleV">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GSurface.TextureScaleV" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GSurfaceSurrogate.TextureOffsetU">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GSurface.TextureOffsetU" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GSurfaceSurrogate.TextureOffsetV">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GSurface.TextureOffsetV" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GSurfaceSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GSurface.#ctor(System.Int32,System.Double[],System.Int32,System.Double[],devDept.Geometry.Point4D[0:,0:])" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GPlanarSurfaceSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GPlanarSurface" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GPlanarSurfaceSurrogate.#ctor(devDept.Geometry.Entities.GPlanarSurface)">
      <summary>
            Standard Constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GPlanarSurfaceSurrogate.Plane">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GPlanarSurface.Plane" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GPlanarSurfaceSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GPlanarSurface.#ctor(System.Int32,System.Double[],System.Int32,System.Double[],devDept.Geometry.Point4D[0:,0:],devDept.Geometry.Plane)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GTabulatedSurfaceSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GTabulatedSurface" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GTabulatedSurfaceSurrogate.#ctor(devDept.Geometry.Entities.GTabulatedSurface)">
      <summary>
            Standard Constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GTabulatedSurfaceSurrogate.Generatrix">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GTabulatedSurface.Generatrix" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GTabulatedSurfaceSurrogate.Directrix">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GTabulatedSurface.Directrix" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GTabulatedSurfaceSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GTabulatedSurface.#ctor(System.Int32,System.Double[],System.Int32,System.Double[],devDept.Geometry.Point4D[0:,0:],devDept.Geometry.Vector3D,devDept.Geometry.Entities.IGCurve)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GRevolvedSurfaceSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GRevolvedSurface" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GRevolvedSurfaceSurrogate.#ctor(devDept.Geometry.Entities.GRevolvedSurface)">
      <summary>
            Standard Constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GRevolvedSurfaceSurrogate.Generatrix">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GRevolvedSurface.Generatrix" />.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GRevolvedSurfaceSurrogate.SeamPlane">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GRevolvedSurface.SeamPlane" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GRevolvedSurfaceSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GRevolvedSurface.#ctor(System.Int32,System.Double[],System.Int32,System.Double[],devDept.Geometry.Point4D[0:,0:],devDept.Geometry.Entities.IGCurve,devDept.Geometry.Plane)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GSphericalSurfaceSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GSphericalSurface" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GSphericalSurfaceSurrogate.#ctor(devDept.Geometry.Entities.GSphericalSurface)">
      <summary>
            Standard Constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GSphericalSurfaceSurrogate.Radius">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GSphericalSurface.Radius" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GSphericalSurfaceSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GSphericalSurface.#ctor(System.Int32,System.Double[],System.Int32,System.Double[],devDept.Geometry.Point4D[0:,0:],devDept.Geometry.Entities.IGCurve,System.Double,devDept.Geometry.Plane)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GToroidalSurfaceSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GToroidalSurface" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GToroidalSurfaceSurrogate.#ctor(devDept.Geometry.Entities.GToroidalSurface)">
      <summary>
            Standard Constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GToroidalSurfaceSurrogate.MajorRadius">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GToroidalSurface.MajorRadius" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GToroidalSurfaceSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GToroidalSurface.#ctor(System.Int32,System.Double[],System.Int32,System.Double[],devDept.Geometry.Point4D[0:,0:],devDept.Geometry.Entities.IGCurve,System.Double,System.Double,devDept.Geometry.Plane)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GCurveSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GCurve" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GCurveSurrogate.#ctor(devDept.Geometry.Entities.GCurve)">
      <summary>
            Standard Constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GCurveSurrogate.Pw">
      <summary>
            See <see cref="F:devDept.Geometry.Entities.GCurve.Pw" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GCurveSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="M:devDept.Geometry.Entities.GCurve.#ctor(System.Int32,System.Double[],devDept.Geometry.Point4D[],System.Boolean)" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.Serialization.GNurbsBaseSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GNurbsBase" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GNurbsBaseSurrogate.#ctor(devDept.Geometry.Entities.GNurbsBase)">
      <summary>
            Standard Constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GNurbsBaseSurrogate.p">
      <summary>
            U degree.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GNurbsBaseSurrogate.U">
      <summary>
            U knot vector.
            </summary>
    </member>
    <member name="T:devDept.Serialization.GTrimCurveSurrogate">
      <summary>
            Defines the <see cref="T:devDept.Geometry.Entities.GTrimCurve" /> surrogate.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GTrimCurveSurrogate.#ctor(devDept.Geometry.Entities.GTrimCurve)">
      <summary>
            Standard Constructor.
            </summary>
    </member>
    <member name="F:devDept.Serialization.GTrimCurveSurrogate.Edge">
      <summary>
            See <see cref="P:devDept.Geometry.Entities.GTrimCurve.Edge" />.
            </summary>
    </member>
    <member name="M:devDept.Serialization.GTrimCurveSurrogate.ConvertToObject">
      <inheritdoc />
      <remarks>
             This method uses the <see cref="T:devDept.Geometry.Entities.GTrimCurve" /> constructor to create the object.
             </remarks>
    </member>
    <member name="T:devDept.WorkFailedEventArgs">
      <summary>Provides data for the Workspace.WorkFailed event.</summary>
    </member>
    <member name="M:devDept.WorkFailedEventArgs.#ctor(devDept.WorkUnit,System.Exception)">
      <summary>
            Standard constructor.
            </summary>
      <param name="error">The error string</param>
    </member>
    <member name="P:devDept.WorkFailedEventArgs.Exception">
      <summary>
            Gets the exception.
            </summary>
    </member>
    <member name="P:devDept.WorkFailedEventArgs.Error">
      <summary>
            Gets the error string.
            </summary>
      <remarks>Includes also inner exceptions messages.</remarks>
    </member>
    <member name="T:devDept.WorkCompletedEventArgs">
      <summary>Provides data for the Workspace.WorkCompleted event.</summary>
    </member>
    <member name="M:devDept.WorkCompletedEventArgs.#ctor(devDept.WorkUnit)">
      <summary>
            Standard constructor.
            </summary>
      <param name="wu">The work unit</param>
    </member>
    <member name="T:devDept.WorkUnitEventArgs">
      <summary>Provides data for the <see cref="T:devDept.WorkManager`1" /> events.</summary>
    </member>
    <member name="M:devDept.WorkUnitEventArgs.#ctor(devDept.WorkUnit)">
      <summary>
            Standard constructor.
            </summary>
      <param name="wu">The work unit</param>
    </member>
    <member name="P:devDept.WorkUnitEventArgs.WorkUnit">
      <summary>
            Gets the work unit.
            </summary>
    </member>
    <member name="T:devDept.workUnitStatus">
      <summary>
            WorkUnit progress status during <see cref="T:devDept.WorkManager`1" /> queue handling.
            </summary>
    </member>
    <member name="F:devDept.workUnitStatus.Idle">
      <summary>
            Idle.
            </summary>
    </member>
    <member name="F:devDept.workUnitStatus.InProgress">
      <summary>
            In progress.
            </summary>
    </member>
    <member name="F:devDept.workUnitStatus.Cancelled">
      <summary>
            Cancelled.
            </summary>
    </member>
    <member name="F:devDept.workUnitStatus.Failed">
      <summary>
            Failed.
            </summary>
    </member>
    <member name="F:devDept.workUnitStatus.Completed">
      <summary>
            Completed.
            </summary>
    </member>
    <member name="T:devDept.WorkUnit">
      <summary>
        <para>Base class for background working support. Overriding this class you can build a model or do your CPU intensive calculations on a separate thread keeping
            your application UI responsive.</para>
        <para>Depending on the nature of the work you may need to override both the <see cref="M:devDept.WorkUnit.DoWork" /> and <see cref="M:devDept.WorkUnit.WorkCompleted(System.Object)" /> methods or only the <see cref="M:devDept.WorkUnit.DoWork" /> one and provide a 
            <see cref="T:devDept.WorkUnit.WorkCompletedEventHandler" /> to be notified when the work has completed.</para>
      </summary>
      <example>
            The following sample demonstrates the WorkUnit class usage for building a solid model.
            <code lang="CS">
            public void Lego(Viewport viewport)
            {
              
                BuildLego bl = new BuildLego();
              
                viewport.StartWork(bl);
            }
            
            private class BuildLego : WorkUnit
            {
              
                private Solid[] model;
              
                protected override void DoWork(System.ComponentModel.BackgroundWorker worker, System.ComponentModel.DoWorkEventArgs doWorkEventArgs)
                {
                    // dimensions
                    double width = 95.75;
                    double depth = 47.75;
                    double height = 3.25;
             
                    // rows ans columns number
                    int nRows = 6;
                    int nColumns = 12;
              
                    // top cylinders size and position
                    double cylRadius = 2.55;
                    double distFromBorder = 1;
                    double cylHeight = 1.6;
                    Point2D startPos = new Point2D(3.55, 3.55);
              
                    // creates the plate
                    model = new Solid[]{Solid.CreateBox(width, depth, height)};
                            
                    // adds cylinders to the upper side
                    double xOffset, yOffset;
              
                    if (nColumns &lt;= 1)
                        xOffset = 0;
                    else
                        xOffset = (width - 2 * distFromBorder - 2 * cylRadius) / (nColumns - 1);
              
                    if (nRows &lt;= 1)
                        yOffset = 0;
                    else
                        yOffset = (depth - 2 * distFromBorder - 2 * cylRadius) / (nRows - 1);
            
                    Circle circle = new Circle(startPos.X, startPos.Y, height, cylRadius);
              
                    CompositeCurve curve = new CompositeCurve(circle);
              
                    int currentValue = 0;
              
                    for (int i = 0; i &lt; nRows; i++)
                    {
                        Solid solid = model[0];
              
                        for (int j = 0; j &lt; nColumns; j++)
                        {
                            model = solid.ExtrudeAdd(curve, 0.2, new Vector3D(0, 0, cylHeight), true);
              
                            if (model != null)
                            {
                                solid = model[0];
              
                                curve.Translate(xOffset, 0, 0);
              
                                // updates progress using build in progress bar
                                UpdateProgress(++currentValue, nRows * nColumns, "Adding top cylinders...", worker);
             
                                // checks for cancellation using built in progress bar cancel button
                                if (Canceled(worker, doWorkEventArgs))
                                    return;
                            }
                        }
              
                        curve.Translate(-nColumns * xOffset, yOffset, 0);
                    }
             
                }
             
                protected override void WorkCompleted(Viewport viewport)
                {
                    // adds the result to viewport entities collection
                    Workspace._entities.AddRange(model, 0, Color.Green);
                    viewport.ZoomFit();
             
                    // prints the execution time
                    Console.WriteLine("Execution time: " + ExecutionTime + " ms");
                }
            }</code><code lang="VB.NET">Public Sub Lego(viewport As Viewport)
              
                 Dim bl As New BuildLego()
              
                 viewport.StartWork(bl)
              
             End Sub
              
             Private Class BuildLego
                 Inherits WorkUnit
              
                 Private model As Solid()
              
                 Protected Overrides Sub DoWork(worker As System.ComponentModel.BackgroundWorker, doWorkEventArgs As System.ComponentModel.DoWorkEventArgs)
              
                     ' dimensions
                     Dim width As Double = 95.75
                     Dim depth As Double = 47.75
                     Dim height As Double = 3.25
              
                     ' rows ans columns number
                     Dim nRows As Integer = 6
                     Dim nColumns As Integer = 12
              
                     ' top cylinders size and position
                     Dim cylRadius As Double = 2.55
                     Dim distFromBorder As Double = 1
                     Dim cylHeight As Double = 1.6
                     Dim startPos As New Point2D(3.55, 3.55)
              
                     ' creates the plate
                     model = New Solid() {Solid.CreateBox(width, depth, height)}
              
                     ' adds cylinders to the upper side
                     Dim xOffset As Double, yOffset As Double
              
                     If nColumns &lt;= 1 Then
                         xOffset = 0
                     Else
                         xOffset = (width - 2 * distFromBorder - 2 * cylRadius) / (nColumns - 1)
                     End If
              
                     If nRows &lt;= 1 Then
                         yOffset = 0
                     Else
                         yOffset = (depth - 2 * distFromBorder - 2 * cylRadius) / (nRows - 1)
                     End If
              
                     Dim circle As New Circle(startPos.X, startPos.Y, height, cylRadius)
              
                     Dim curve As New CompositeCurve(circle)
              
                     Dim currentValue As Integer = 0
              
                     For i As Integer = 0 To nRows - 1
              
                         Dim theSolid As Solid = model(0)
              
                         For j As Integer = 0 To nColumns - 1
              
                             model = theSolid.ExtrudeAdd(curve, 0.2, New Vector3D(0, 0, cylHeight), True)
              
                             If model IsNot Nothing Then
              
                                 theSolid = model(0)
              
                                 curve.Translate(xOffset, 0, 0)
              
                                 ' updates progress using build in progress bar
                                 UpdateProgress(System.Threading.Interlocked.Increment(currentValue), nRows * nColumns, "Adding top cylinders...", worker)
              
                                 ' checks for cancellation using built in progress bar cancel button
                                 If Canceled(worker, doWorkEventArgs) Then
                                     Return
                                 End If
              
                             End If
              
                         Next
              
                         curve.Translate(-nColumns * xOffset, yOffset, 0)
                     Next
              
                 End Sub
              
                 Protected Overrides Sub WorkCompleted(viewport As Viewport)
                     ' adds the result to viewport entities collection
                     Workspace._entities.AddRange(model, 0, Color.Green)
                     viewport.ZoomFit()
             
                     ' prints the execution time
                     Console.WriteLine("Execution time: " + ExecutionTime + " ms")
                 End Sub
             End Class</code></example>
    </member>
    <member name="M:devDept.WorkUnit.AppendToLog(System.String)">
      <summary>
            Appends a message to the log.
            </summary>
      <param name="message">The message to append.</param>
      <seealso cref="P:devDept.WorkUnit.Log" />
    </member>
    <member name="P:devDept.WorkUnit.Log">
      <summary>
            Gets the list of errors and warnings generated during execution.
            </summary>
      <seealso cref="!:AppendToLog(string message)" />
    </member>
    <member name="F:devDept.WorkUnit.HighestNumberOfTicks">
      <summary>
            Max number of progress bar updates. This means that the screen is repainted a max of 32 times even if it gets 100 progress updates.
            </summary>
    </member>
    <member name="P:devDept.WorkUnit.Status">
      <summary>
            Gets the WorkUnit status.
            </summary>
      <remarks>Status is updated by <see cref="T:devDept.WorkManager`1" />.</remarks>
    </member>
    <member name="P:devDept.WorkUnit.ExecutionTime">
      <summary>
            Gets or sets the (last) work execution time in milliseconds.
            </summary>
    </member>
    <member name="T:devDept.WorkUnit.WorkCompletedEventHandler">
      <summary>Represents the method that will handle the <see cref="M:devDept.WorkUnit.WorkCompleted(System.Object)" /> event.</summary>
      <param name="sender">The source of the event.</param>
      <param name="e">A <see cref="T:devDept.WorkCompletedEventArgs" /> that contains the event data.</param>
    </member>
    <member name="T:devDept.WorkUnit.WorkCancelledEventHandler">
      <summary>Represents the method that will handle the <see cref="M:devDept.WorkUnit.WorkCancelled(System.Object)" /> event.</summary>
      <param name="sender">The source of the event.</param>
      <param name="e">A <see cref="T:System.EventArgs" /> that contains the event data.</param>
    </member>
    <member name="T:devDept.WorkUnit.WorkFailedEventHandler">
      <summary>Represents the method that will handle the <see cref="M:devDept.WorkUnit.WorkFailed(System.Object)" /> event.</summary>
      <param name="sender">The source of the event.</param>
      <param name="e">A <see cref="T:devDept.WorkFailedEventArgs" /> that contains the error message.</param>
    </member>
    <member name="T:devDept.WorkUnit.ProgressChangedEventArgs">
      <summary>Provides data for the <see cref="E:devDept.WorkUnit.ProgressChanged" /> event.</summary>
    </member>
    <member name="M:devDept.WorkUnit.ProgressChangedEventArgs.#ctor(System.Int32,System.String)">
      <summary>
            Standard constructor.
            </summary>
      <param name="progress">A value representing the current progress in the range [0-100].</param>
      <param name="text">The progress text.</param>
    </member>
    <member name="M:devDept.WorkUnit.ProgressChangedEventArgs.#ctor(System.Int32)">
      <summary>
            Standard constructor.
            </summary>
      <param name="progress">A value representing the current progress in the range [0-100].</param>
    </member>
    <member name="P:devDept.WorkUnit.ProgressChangedEventArgs.Progress">
      <summary>
            Current progress (0-100).
            </summary>
    </member>
    <member name="P:devDept.WorkUnit.ProgressChangedEventArgs.Text">
      <summary>
            The progress text. Can be empty.
            </summary>
    </member>
    <member name="T:devDept.WorkUnit.ProgressChangedEventHandler">
      <summary>Represents the method that will handle the <see cref="E:devDept.WorkUnit.ProgressChanged" /> event.</summary>
      <param name="sender">The source of the event.</param>
      <param name="e">A <see cref="T:devDept.WorkUnit.ProgressChangedEventArgs" /> that contains the event data.</param>
    </member>
    <member name="E:devDept.WorkUnit.ProgressChanged">
      <summary>
            Occurs when the DoWork() is called synchronously and the progress has changed.
            </summary>
    </member>
    <member name="M:devDept.WorkUnit.DoWork">
      <summary>
            Executes the work synchronously.
            </summary>
    </member>
    <member name="M:devDept.WorkUnit.DoWork(System.ComponentModel.BackgroundWorker,System.ComponentModel.DoWorkEventArgs)">
      <summary>Does the actual work allowing progress bar update and cancellation.</summary>
      <param name="worker">The background worker thread</param>
      <param name="doWorkEventArgs">DoWork event arguments</param>
    </member>
    <member name="M:devDept.WorkUnit.WorkCompleted(System.Object)">
      <summary>Called when the work has completed. In the case you are modeling something, the <paramref name="sender" /> parameter allows you to easily add the content to the entities collection.</summary>
      <param name="sender">The parent workspace control.</param>
    </member>
    <member name="M:devDept.WorkUnit.WorkCancelled(System.Object)">
      <summary>
            Called when the work is cancelled.
            </summary>
      <param name="sender">The parent workspace control.</param>
    </member>
    <member name="M:devDept.WorkUnit.WorkFailed(System.Object)">
      <summary>Called when the work has failed.</summary>
      <param name="sender">The parent workspace control.</param>
    </member>
    <member name="M:devDept.WorkUnit.UpdateProgress(System.Int32,System.Int32,System.String,System.ComponentModel.BackgroundWorker,System.Boolean,System.String[])">
      <summary>Updates the progress bar value.</summary>
      <param name="current">The current step</param>
      <param name="total">The total number of steps</param>
      <param name="text">The progress bar text</param>
      <param name="worker">The background worker thread</param>
      <param name="forceUpdate">When true the event is always fired. Must be used with caution!</param>
      <param name="args">A string array that contains zero or more strings to format for the progress bar text</param>
    </member>
    <member name="M:devDept.WorkUnit.UpdateProgressAndCheckCancelled(System.Int32,System.Int32,System.String,System.ComponentModel.BackgroundWorker,System.ComponentModel.DoWorkEventArgs,System.Boolean,System.String[])">
      <summary>
            Updates the progress bar value and checks if the worker thread has been canceled.
            </summary>
      <param name="current">The current step</param>
      <param name="total">The total number of steps</param>
      <param name="text">The progress bar text</param>
      <param name="worker">The background worker thread</param>
      <param name="doWorkEventArgs">DoWork event arguments</param>
      <param name="forceUpdate">When true the event is always fired. Must be used with caution!</param>
      <param name="args">A string array that contains zero or more strings to format for the progress bar text</param>
      <returns>False if the worker thread was canceled, true otherwise.</returns>
    </member>
    <member name="M:devDept.WorkUnit.UpdateProgress(System.Double,System.Double,System.String,System.ComponentModel.BackgroundWorker,System.Boolean,System.String[])">
      <summary>Updates the progress bar value.</summary>
      <param name="current">The current step</param>
      <param name="total">The total number of steps</param>
      <param name="text">The progress bar text</param>
      <param name="worker">The background worker thread</param>
      <param name="forceUpdate">When true the event is always fired. Must be used with caution!</param>
      <param name="args">A string array that contains zero or more strings to format for the progress bar text</param>
    </member>
    <member name="M:devDept.WorkUnit.StartContinuousAnimation(System.String,System.ComponentModel.BackgroundWorker,System.String[])">
      <summary>
            Start the animation for the continuous progress bar.
            </summary>
      <param name="text">The progress bar text</param>
      <param name="worker">The background worker thread</param>
      <param name="args">A string array that contains zero or more strings to format for the progress bar text</param>
    </member>
    <member name="M:devDept.WorkUnit.StopContinuousAnimation(System.ComponentModel.BackgroundWorker)">
      <summary>
            Stop the animation for the continuous progress bar.
            </summary>
      <param name="worker">The background worker thread</param>
    </member>
    <member name="M:devDept.WorkUnit.UpdateProgressTo100(System.String,System.ComponentModel.BackgroundWorker,System.String[])">
      <summary>
            Set the progress bar to 100% and forces screen update.
            </summary>
      <param name="text">The progress bar text</param>
      <param name="worker">The background worker thread</param>
      <param name="args">A string array that contains zero or more strings to format for the progress bar text</param>
    </member>
    <member name="M:devDept.WorkUnit.ResetProgress">
      <summary>
            Resets the progress.
            </summary>
      <param name="worker">
      </param>
    </member>
    <member name="M:devDept.WorkUnit.UpdateProgressParallel(System.Double,System.String,System.ComponentModel.BackgroundWorker,System.String[])">
      <summary>
            Updates the progress bar value for a parallel loop.
            </summary>
      <param name="total">The total number of steps</param>
      <param name="text">The progress bar text</param>
      <param name="worker">The background worker thread</param>
      <param name="args">A string array that contains zero or more strings to format for the progress bar text</param>
      <remarks>Call <see cref="M:devDept.WorkUnit.ResetProgressParallel(System.Int32)" /> before starting the parallel loop.</remarks>
    </member>
    <member name="M:devDept.WorkUnit.UpdateProgressAndCheckCancelledParallel(System.Int32,System.String,System.ComponentModel.BackgroundWorker,System.ComponentModel.DoWorkEventArgs,System.String[])">
      <summary>
            Updates the progress bar value and checks if the worker thread has been canceled, for a parallel loop.
            </summary>
      <param name="total">The total number of steps</param>
      <param name="text">The progress bar text</param>
      <param name="worker">The background worker thread</param>
      <param name="doWorkEventArgs">DoWork event arguments</param>
      <param name="args">A string array that contains zero or more strings to format for the progress bar text</param>
      <returns>False if the worker thread was canceled, true otherwise.</returns>
      <remarks>Call <see cref="M:devDept.WorkUnit.ResetProgressParallel(System.Int32)" /> before starting the parallel loop.</remarks>
    </member>
    <member name="M:devDept.WorkUnit.ResetProgressParallel(System.Int32)">
      <summary>
            Resets the progress bar for a parallel loop.
            </summary>
      <remarks>Call it before starting a parallel loop.</remarks>
    </member>
    <member name="M:devDept.WorkUnit.Cancelled(System.ComponentModel.BackgroundWorker,System.ComponentModel.DoWorkEventArgs)">
      <summary>Checks if the user has requested cancellation of the background operation.
            </summary>
      <param name="worker">The background worker thread</param>
      <param name="doWorkEventArgs">DoWork event arguments</param>
      <returns>True if the user has requested cancellation of the background operation.</returns>
    </member>
    <member name="T:devDept.WorkUnitUserState">
      <summary>
            Helper class for background working support.
            </summary>
      <remarks>This class contains info for progress bar drawing.</remarks>
    </member>
    <member name="M:devDept.WorkUnitUserState.#ctor(System.String,System.Boolean)">
      <summary>
            Standard constructor.
            </summary>
      <param name="text">
      </param>
      <param name="continuous">
      </param>
    </member>
    <member name="P:devDept.WorkUnitUserState.Text">
      <summary>
            Gets or sets the text of the current operation.
            </summary>
    </member>
    <member name="P:devDept.WorkUnitUserState.Continuous">
      <summary>
            Gets or sets the value indicating whether the progress bar is shown as continuous or not.
            </summary>
    </member>
    <member name="T:devDept.Eyeshot.TextureMappingData">
      <summary>
            Texture mapping data.
            </summary>
    </member>
    <member name="P:devDept.Eyeshot.TextureMappingData.Transformation">
      <summary>
            Gets or sets the transformation applied to the mapping.
            </summary>
    </member>
    <member name="P:devDept.Eyeshot.TextureMappingData.Max">
      <summary>
            Gets or sets bounding box min point.
            </summary>
    </member>
    <member name="P:devDept.Eyeshot.TextureMappingData.Min">
      <summary>
            Gets or sets bounding box max point.
            </summary>
    </member>
    <member name="P:devDept.Eyeshot.TextureMappingData.MappingMode">
      <summary>
            Gets or sets indicates the way material's texture is wrapped on the object.
            </summary>
    </member>
    <member name="P:devDept.Eyeshot.TextureMappingData.ScaleX">
      <summary>
            Gets or sets material's texture scale along the X axis.
            </summary>
    </member>
    <member name="P:devDept.Eyeshot.TextureMappingData.ScaleY">
      <summary>
            Gets or sets material's texture scale along the Y axis.
            </summary>
    </member>
    <member name="M:devDept.Eyeshot.TextureMappingData.Clone">
      <summary>
            Creates a deep copy of this texture mapping data.
            </summary>
      <returns>The new texture mapping data object.</returns>
    </member>
    <member name="T:devDept.ISupportWorkManager">
      <summary>
            Represents an object that supports the <see cref="T:devDept.WorkManager`1" /> handling.
            </summary>
    </member>
    <member name="E:devDept.ISupportWorkManager.WorkCompleted">
      <summary>
            Occurs when the background work has completed.
            </summary>
    </member>
    <member name="E:devDept.ISupportWorkManager.WorkCancelled">
      <summary>
            Occurs when the background work is cancelled.
            </summary>
    </member>
    <member name="E:devDept.ISupportWorkManager.WorkFailed">
      <summary>
            Occurs when the background work has failed.
            </summary>
    </member>
    <member name="E:devDept.ISupportWorkManager.ProgressChanged">
      <summary>
            Occurs when the background work is running.
            </summary>
    </member>
    <member name="P:devDept.ISupportWorkManager.IsBusy">
      <summary>
            Gets background worker thread status.
            </summary>
    </member>
    <member name="M:devDept.ISupportWorkManager.DoWork(devDept.WorkUnit)">
      <summary>Accomplishes the work and call <see cref="M:devDept.WorkUnit.WorkCompleted(System.Object)" /> method.</summary>
      <seealso cref="M:devDept.ISupportWorkManager.CancelWork">CancelWork() method.</seealso>
      <seealso cref="M:devDept.ISupportWorkManager.StartWork(devDept.WorkUnit)">StartWork() method.</seealso>
      <seealso cref="T:devDept.WorkUnit">WorkUnit class.</seealso>
    </member>
    <member name="M:devDept.ISupportWorkManager.StartWork(devDept.WorkUnit)">
      <summary>
            Starts the work asynchronously.
            </summary>
      <seealso cref="M:devDept.ISupportWorkManager.CancelWork">CancelWork() method.</seealso>
      <seealso cref="M:devDept.ISupportWorkManager.DoWork(devDept.WorkUnit)">DoWork() method.</seealso>
      <seealso cref="T:devDept.WorkUnit">WorkUnit class.</seealso>
      <remarks>
        <para>It can handle just one WorkUnit at the time. Every additional call when the first thread is not completed will raise an Exception.</para>
        <para>For handling a queue of WorkUnits, use <see cref="T:devDept.WorkManager`1" /> instead.</para>
      </remarks>
    </member>
    <member name="M:devDept.ISupportWorkManager.CancelWork">
      <summary>
            Stops the asynchronous background work.
            </summary>
      <seealso cref="M:devDept.ISupportWorkManager.StartWork(devDept.WorkUnit)">StartWork() method.</seealso>
      <seealso cref="M:devDept.ISupportWorkManager.DoWork(devDept.WorkUnit)">DoWork() method.</seealso>
      <seealso cref="T:devDept.WorkUnit">WorkUnit class.</seealso>
    </member>
    <member name="T:devDept.WorkManager`1">
      <summary>
            Helper class to handle WorkUnits work.
            </summary>
    </member>
    <member name="M:devDept.WorkManager`1.#ctor">
      <summary>
            Standard constructor.
            </summary>
    </member>
    <member name="M:devDept.WorkManager`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Constructor with a collection of WorkUnits.
            </summary>
      <param name="workUnits">A collection of WorkUnits.</param>
    </member>
    <member name="M:devDept.WorkManager`1.#ctor(`0)">
      <summary>
            Constructor with a single <see cref="T:devDept.WorkUnit" />.
            </summary>
      <param name="workUnit">The WorkUnit.</param>
    </member>
    <member name="P:devDept.WorkManager`1.IsQueueEmpty">
      <summary>
            Indicates whether the queue is empty or not.
            </summary>
    </member>
    <member name="M:devDept.WorkManager`1.AppendToQueue(`0)">
      <summary>
            Appends a WorkUnit to the working queue.
            </summary>
      <param name="workUnit">The WorkUnit to append to the queue.</param>
    </member>
    <member name="M:devDept.WorkManager`1.AppendToQueue(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Appends a collection of WorkUnit to the working queue.
            </summary>
      <param name="workUnits">The collection to append to the queue.</param>
    </member>
    <member name="M:devDept.WorkManager`1.RemoveFromQueue(`0)">
      <summary>
            Removes a WorkUnit from the working queue.
            </summary>
      <param name="workUnit">The WorkUnit to remove from the queue.</param>
      <remarks>
            You can call this method to remove a completed WorkUnit to free up memory.
            If the <paramref name="workUnit" /> is currently working, the operation will be interrupted.
            </remarks>
    </member>
    <member name="M:devDept.WorkManager`1.RemoveFromQueue(devDept.workUnitStatus)">
      <summary>
            Removes all the WorkUnits from the working queue according to their status.
            </summary>
      <param name="status">The status of the WorkUnit that must be removed from the queue.</param>
      <remarks>
            You can call this method to remove a completed WorkUnit to free up memory.
            If the <paramref name="status" /> is <see cref="F:devDept.workUnitStatus.InProgress" />, the current operation will be interrupted.
            </remarks>
    </member>
    <member name="M:devDept.WorkManager`1.ClearQueue">
      <summary>
            Clears the queue.
            </summary>
      <remarks>
            If a WorkUnit is currently running, the operation will be interrupted.
            </remarks>
    </member>
    <member name="P:devDept.WorkManager`1.QueueCount">
      <summary>
            Gets the number of WorkUnits.
            </summary>
    </member>
    <member name="M:devDept.WorkManager`1.GetQueueItems">
      <summary>
            Gets the queue of WorkUnits.
            </summary>
      <returns>The array of WorkUnits queued.</returns>
      <remarks>The queue can include items with a different <see cref="T:devDept.workUnitStatus" />.</remarks>
    </member>
    <member name="M:devDept.WorkManager`1.Run">
      <summary>
            Runs the first WorkUnit synchronously.
            </summary>
      <seealso cref="M:devDept.WorkManager`1.RunAll" />
      <seealso cref="M:devDept.WorkManager`1.Run(devDept.ISupportWorkManager)" />
      <seealso cref="M:devDept.WorkManager`1.RunAll(devDept.ISupportWorkManager)" />
    </member>
    <member name="M:devDept.WorkManager`1.RunAll">
      <summary>
            Runs all the WorkUnits of the queue one-by-one synchronously.
            </summary>
      <seealso cref="M:devDept.WorkManager`1.Run" />
      <seealso cref="M:devDept.WorkManager`1.Run(devDept.ISupportWorkManager)" />
      <seealso cref="M:devDept.WorkManager`1.RunAll(devDept.ISupportWorkManager)" />
    </member>
    <member name="M:devDept.WorkManager`1.Run(devDept.ISupportWorkManager)">
      <summary>
            Runs the first WorkUnit asynchronously.
            </summary>
      <param name="externalObj">The <see cref="T:devDept.ISupportWorkManager" /> object where the async work will be run.</param>
      <seealso cref="M:devDept.WorkManager`1.RunAll(devDept.ISupportWorkManager)" />
      <seealso cref="M:devDept.WorkManager`1.Run" />
      <seealso cref="M:devDept.WorkManager`1.RunAll" />
    </member>
    <member name="M:devDept.WorkManager`1.RunAll(devDept.ISupportWorkManager)">
      <summary>
            Runs all the WorkUnits of the queue one-by-one asynchronously.
            </summary>
      <param name="externalObj">The <see cref="T:devDept.ISupportWorkManager" /> object where the async work will be run.</param>
      <seealso cref="M:devDept.WorkManager`1.Run(devDept.ISupportWorkManager)" />
      <seealso cref="M:devDept.WorkManager`1.Run" />
      <seealso cref="M:devDept.WorkManager`1.RunAll" />
    </member>
    <member name="M:devDept.WorkManager`1.Cancel">
      <summary>
            Cancels the current WorkUnit work.
            </summary>
    </member>
    <member name="M:devDept.WorkManager`1.Reset">
      <summary>
            Stops the current work and clear the queue.
            </summary>
    </member>
    <member name="M:devDept.WorkManager`1.Dispose">
      <summary>
            Stops the current work, clear the queue, and release every resource.
            </summary>
      <seealso cref="M:devDept.WorkManager`1.Reset" />
    </member>
    <member name="T:devDept.WorkManager`1.QueueCompletedEventHandler">
      <summary>Represents the method that will handle the <see cref="E:devDept.WorkManager`1.QueueCompleted" /> event.</summary>
      <param name="sender">The source of the event.</param>
      <param name="e">A <see cref="T:System.EventArgs" /> that contains the event data.</param>
    </member>
    <member name="T:devDept.WorkManager`1.QueueCancelledEventHandler">
      <summary>Represents the method that will handle the <see cref="E:devDept.WorkManager`1.QueueCancelled" /> event.</summary>
      <param name="sender">The source of the event.</param>
      <param name="e">A <see cref="T:devDept.WorkUnitEventArgs" /> that contains the event data.</param>
    </member>
    <member name="T:devDept.WorkManager`1.WorkUnitCompletedEventHandler">
      <summary>Represents the method that will handle the <see cref="E:devDept.WorkManager`1.WorkUnitCompleted" /> event.</summary>
      <param name="sender">The source of the event.</param>
      <param name="e">A <see cref="T:devDept.WorkUnitEventArgs" /> that contains the event data.</param>
    </member>
    <member name="T:devDept.WorkManager`1.WorkUnitFailedEventHandler">
      <summary>Represents the method that will handle the <see cref="E:devDept.WorkManager`1.WorkUnitFailed" /> event.</summary>
      <param name="sender">The source of the event.</param>
      <param name="e">A <see cref="T:devDept.WorkUnitEventArgs" /> that contains the event data.</param>
    </member>
    <member name="T:devDept.WorkManager`1.WorkUnitProgressChangedEventHandler">
      <summary>Represents the method that will handle the <see cref="E:devDept.WorkManager`1.WorkUnitProgressChanged" /> event.</summary>
      <param name="sender">The source of the event.</param>
      <param name="e">A <see cref="T:devDept.WorkUnit.ProgressChangedEventArgs" /> that contains the event data.</param>
    </member>
    <member name="E:devDept.WorkManager`1.QueueCompleted">
      <summary>
            Occurs when the background work of a single WorkUnit is completed.
            </summary>
      <remarks>It is raised every time a WorkUnit in the queue completes its work.</remarks>
    </member>
    <member name="E:devDept.WorkManager`1.QueueCancelled">
      <summary>
            Occurs when the background work is cancelled.
            </summary>
      <remarks>It is raised when the current WorkUnit in the queue completes its work.</remarks>
    </member>
    <member name="E:devDept.WorkManager`1.WorkUnitCompleted">
      <summary>
            Occurs when the background work of a single WorkUnit is completed.
            </summary>
      <remarks>It is raised every time a WorkUnit in the queue fails its work.</remarks>
    </member>
    <member name="E:devDept.WorkManager`1.WorkUnitFailed">
      <summary>
            Occurs when the background work of a single WorkUnit fails.
            </summary>
      <remarks>It is raised every time a WorkUnit in the queue fails its work.</remarks>
    </member>
    <member name="E:devDept.WorkManager`1.WorkUnitProgressChanged">
      <summary>
            Occurs during the single WorkUnit work.
            </summary>
      <seealso cref="E:devDept.WorkUnit.ProgressChanged" />
    </member>
    <!-- Badly formed XML comment ignored for member "M:cavc.utils.mathutils.deltaAngle(System.Double,System.Double)" -->
    <!-- Badly formed XML comment ignored for member "M:vector2.Vector2.isLeftOrEqual(cavc.Vector,cavc.Vector,cavc.Vector)" -->
  </members>
</doc>